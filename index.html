<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ficha de Personagem - Sistema FAC</title>
    <!-- Bootstrap 5 CSS -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <style>
      .hexagon-container {
        display: flex;
        justify-content: center;
        margin: 10px 0;
      }
      .hexagon {
        width: 40px;
        height: 35px;
        border: 2px solid #333;
        margin: 2px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        clip-path: polygon(
          25% 0%,
          75% 0%,
          100% 50%,
          75% 100%,
          25% 100%,
          0% 50%
        );
        background: white;
      }
      .attribute-circle {
        width: 80px;
        height: 80px;
        border: 3px solid #333;
        border-radius: 50%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        background: white;
        margin: 10px auto;
      }
      .attribute-label {
        font-size: 12px;
        font-weight: bold;
      }
      .attribute-value {
        font-size: 20px;
        font-weight: bold;
      }
      .skill-section {
        border: 2px solid #333;
        padding: 10px;
        margin: 5px 0;
        background: #f8f9fa;
      }
      .section-title {
        background: #333;
        color: white;
        padding: 5px 10px;
        margin: -10px -10px 10px -10px;
        font-weight: bold;
        text-align: center;
      }
      .checkbox-list {
        columns: 1;
        column-gap: 20px;
      }
      .form-check {
        margin-bottom: 8px;
        break-inside: avoid;
      }
      .skill-levels {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
        padding: 4px;
        border: 1px solid #e0e0e0;
        border-radius: 4px;
        background: white;
      }
      .skill-name {
        font-weight: 500;
        min-width: 120px;
        margin-bottom: 0;
      }
      .skill-level-boxes {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .skill-level {
        margin: 0 2px;
        width: 16px;
        height: 16px;
      }
      .level-label {
        font-size: 11px;
        font-weight: bold;
        margin: 0 4px 0 0;
        min-width: 8px;
        text-align: center;
      }
      .skill-levels.disabled {
        opacity: 0.4;
        background: #f8f9fa;
      }
      .skill-levels.disabled .skill-level {
        cursor: not-allowed;
      }
      .skill-level:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .skill-level:disabled + .level-label {
        color: #6c757d;
        opacity: 0.5;
      }
      .hp-mana-section {
        border: 2px solid #333;
        padding: 10px;
        text-align: center;
      }
      .large-input {
        font-size: 18px;
        text-align: center;
        font-weight: bold;
      }
      .attack-table th,
      .attack-table td {
        text-align: center;
        vertical-align: middle;
      }
      .resources-section,
      .inventory-section {
        border: 2px solid #333;
        background: white;
        min-height: 200px;
      }
      .section-header {
        background: #333;
        color: white;
        padding: 10px;
        text-align: center;
        font-weight: bold;
        margin: 0;
      }
      .point-category {
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 5px;
        margin: 2px;
        background: #f8f9fa;
      }
      .point-category.total-points {
        background: #fff3cd;
        border-color: #ffeaa7;
      }
      .point-label {
        font-size: 12px;
        font-weight: bold;
        color: #666;
        margin-bottom: 5px;
      }
      .point-value {
        font-size: 24px;
        font-weight: bold;
        color: #333;
        margin-bottom: 5px;
      }
      .total-points .point-value {
        color: #856404;
      }
      .point-cost {
        font-size: 10px;
        color: #999;
      }
      .points-exceeded {
        background-color: #f8d7da !important;
        border-color: #dc3545 !important;
        color: #721c24 !important;
      }
      .attribute-exceeded {
        background-color: #f8d7da !important;
        border-color: #dc3545 !important;
      }
      .skill-exceeded {
        background-color: #fff3cd !important;
        border-color: #ffc107 !important;
      }

      /* Magic Creation Section Styles */
      .magic-item {
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 10px;
        margin-bottom: 8px;
        background: #fff;
        transition: all 0.2s ease;
      }

      .magic-item:hover {
        border-color: #007bff;
        box-shadow: 0 2px 4px rgba(0, 123, 255, 0.1);
      }

      .magic-name {
        font-weight: bold;
        color: #333;
        font-size: 14px;
        margin-bottom: 4px;
      }

      .magic-component {
        font-size: 12px;
        color: #666;
        background: #f8f9fa;
        padding: 2px 6px;
        border-radius: 4px;
        display: inline-block;
        margin-right: 8px;
      }

      .magic-cost {
        font-size: 12px;
        color: #007bff;
        font-weight: bold;
      }

      .magic-details {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 4px;
      }

      .magic-remove-btn {
        float: right;
        background: none;
        border: none;
        color: #dc3545;
        font-size: 16px;
        cursor: pointer;
        padding: 0;
        line-height: 1;
      }

      .magic-remove-btn:hover {
        color: #c82333;
      }

      #magic-list-container {
        background: #f8f9fa;
      }

      #magic-list-container:empty::before {
        content: "Nenhuma magia adicionada ainda.";
        color: #6c757d;
        font-style: italic;
        display: block;
        text-align: center;
        padding: 20px;
      }

      /* Magic Components Selection Styles */
      #magic-components-container {
        background: #f8f9fa;
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 15px;
      }

      .magic-component-select {
        margin-bottom: 10px;
      }

      .form-label {
        font-weight: 600;
        margin-bottom: 5px;
      }

      .form-text {
        font-size: 12px;
        margin-top: 3px;
      }

      /* Essences Selection Styles */
      .essence-checkboxes {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
      }

      .essence-checkboxes .form-check {
        margin-bottom: 5px;
      }

      .magic-essences {
        font-size: 12px;
        color: #6c757d;
        margin-bottom: 5px;
      }

      .magic-components {
        font-size: 12px;
        color: #6c757d;
        margin-bottom: 5px;
      }

      .magic-cost-breakdown {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .magic-base-cost {
        font-size: 12px;
        color: #28a745;
      }

      .magic-final-cost {
        font-weight: bold;
        color: #007bff;
      }

      .magic-proximity {
        font-size: 11px;
        margin-bottom: 3px;
      }

      .magic-proximity small {
        background-color: #e3f2fd;
        padding: 2px 6px;
        border-radius: 3px;
        border: 1px solid #90caf9;
      }

      .form-check-label strong {
        color: #495057;
      }
    </style>
  </head>
  <body class="bg-light">
    <div class="container-fluid py-3">
      <!-- Header Section - Character Name and Description -->
      <div class="row mb-3">
        <div class="col-md-4">
          <div class="card">
            <div class="card-header bg-dark text-white text-center">
              <strong>Nome do Personagem</strong>
            </div>
            <div class="card-body">
              <input
                type="text"
                class="form-control form-control-lg text-center"
                placeholder="Nome do personagem"
              />
            </div>
          </div>
        </div>
        <div class="col-md-8">
          <div class="card">
            <div class="card-header bg-dark text-white text-center">
              <strong>Descri√ß√£o:</strong>
            </div>
            <div class="card-body">
              <textarea
                class="form-control"
                rows="4"
                placeholder="Descri√ß√£o do personagem..."
              ></textarea>
            </div>
          </div>
        </div>
      </div>

      <!-- Main Attributes Section -->
      <div class="row mb-3">
        <!-- Dynamic Skill Sections Container -->
        <div class="col-md-12" id="dynamic-skill-sections">
          <!-- All skill sections will be rendered here from JSON -->
        </div>
      </div>

      <!-- HP and Mana Section -->
      <div id="resource-sections-container">
        <!-- HP and Mana sections will be rendered here from JSON -->
      </div>

      <!-- Bottom Section - Movimento and Point Calculator -->
      <div class="row mb-3 justify-content-center">
        <!-- Movimento -->
        <div class="col-md-3">
          <div class="card">
            <div class="card-header bg-secondary text-white text-center">
              <strong>Movimento</strong>
            </div>
            <div class="card-body text-center">
              <input
                type="number"
                class="form-control large-input mb-2"
                placeholder="Valor"
                id="movement"
              />
            </div>
          </div>
        </div>

        <!-- Point Calculator -->
        <div class="col-md-6">
          <div class="card">
            <div class="card-header bg-warning text-dark text-center">
              <strong>Calculadora de Pontos</strong>
            </div>
            <div class="card-body">
              <div class="row text-center">
                <div class="col-md-4">
                  <div class="point-category">
                    <div class="point-label">N√≠vel Atual</div>
                    <div
                      class="point-value"
                      id="character-level"
                      contenteditable="true"
                      style="cursor: text"
                      onclick="editLevel(this)"
                      onblur="saveLevel(this)"
                      onkeypress="handleLevelKeypress(event, this)"
                    >
                      0
                    </div>
                    <div class="point-cost">n√≠vel</div>
                  </div>
                </div>
                <div class="col-md-4">
                  <div class="point-category">
                    <div class="point-label">Per√≠cias Prim√°rias</div>
                    <div class="point-value" id="attribute-points">0</div>
                    <div class="point-cost">
                      <span id="attribute-used">0</span> /
                      <span id="attribute-available">5</span> dispon√≠veis
                    </div>
                  </div>
                </div>
                <div class="col-md-4">
                  <div class="point-category">
                    <div class="point-label">Per√≠cias Secund√°rias</div>
                    <div class="point-value" id="skill-points">0</div>
                    <div class="point-cost">
                      <span id="skill-used">0</span> /
                      <span id="skill-available">10</span> dispon√≠veis
                    </div>
                  </div>
                </div>
              </div>
              <!-- Clear data button -->
              <div class="text-center mt-2">
                <button
                  type="button"
                  class="btn btn-sm btn-outline-secondary"
                  onclick="clearSavedCharacterData()"
                  title="Limpar dados salvos automaticamente"
                >
                  üóëÔ∏è Limpar Dados Salvos
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Additional Dynamic Skill Sections Container -->
      <div class="row mb-3" id="additional-skill-sections">
        <!-- Additional skill sections will be rendered here from JSON -->
      </div>

      <!-- Resources, Inventory and Attacks Section -->
      <div class="row">
        <!-- Resources -->
        <div class="col-md-4">
          <div class="resources-section" data-section="recursos">
            <div
              class="section-header"
              onclick="handleSectionClick('recursos')"
              style="cursor: pointer"
            >
              Recursos
            </div>
            <div class="p-3">
              <textarea
                class="form-control"
                rows="8"
                placeholder="Liste seus recursos aqui..."
              ></textarea>
            </div>
          </div>
        </div>

        <!-- Inventory -->
        <div class="col-md-4">
          <div class="resources-section">
            <div class="section-header">Invent√°rio</div>
            <div class="p-3">
              <textarea
                class="form-control"
                rows="8"
                placeholder="Lista de itens do invent√°rio..."
              ></textarea>
            </div>
          </div>
        </div>

        <!-- Attacks -->
        <div class="col-md-4">
          <div class="resources-section">
            <div class="section-header">Ataques</div>
            <div class="p-3">
              <table class="table table-sm attack-table">
                <thead>
                  <tr>
                    <th>Nome</th>
                    <th>Dano</th>
                    <th>Alcance</th>
                    <th>Tipo</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </div>

      <!-- Magic Creation Section -->
      <div class="row mt-4">
        <div class="col-12">
          <div class="resources-section" id="magic-creation-section">
            <div class="section-header">‚ú® Cria√ß√£o de Magias</div>
            <div class="p-3">
              <div class="row">
                <!-- Magic Creation Form -->
                <div class="col-md-6">
                  <h6 class="mb-3">Adicionar Nova Magia</h6>
                  <div class="mb-3">
                    <label for="magic-name-input" class="form-label"
                      >Nome da Magia</label
                    >
                    <input
                      type="text"
                      class="form-control"
                      id="magic-name-input"
                      placeholder="Digite o nome da magia..."
                      onkeypress="handleMagicInputKeypress(event)"
                    />
                  </div>
                  <div class="mb-3">
                    <div
                      id="magic-essences-container"
                      class="p-2 bg-light border rounded"
                    >
                      <!-- Essences selection will be populated by JavaScript -->
                    </div>
                  </div>
                  <div class="mb-3">
                    <label class="form-label">Componentes da Magia</label>
                    <div id="magic-components-container" class="p-2">
                      <!-- Component select fields will be populated by JavaScript -->
                    </div>
                    <small class="text-muted"
                      >Configure os componentes para a magia. Campos marcados
                      com * s√£o obrigat√≥rios.</small
                    >
                  </div>
                  <div class="mb-3">
                    <label for="magic-cost-input" class="form-label"
                      >Custo Base (Calculado)</label
                    >
                    <input
                      type="number"
                      class="form-control"
                      id="magic-cost-input"
                      placeholder="1"
                      value="1"
                      min="1"
                      readonly
                      title="O custo base √© calculado automaticamente pelas ess√™ncias selecionadas"
                    />
                  </div>
                  <button
                    type="button"
                    class="btn btn-primary"
                    onclick="addMagicSpell()"
                  >
                    ‚ûï Adicionar Magia
                  </button>
                </div>

                <!-- Magic List Display -->
                <div class="col-md-6">
                  <h6 class="mb-3">Magias Conhecidas</h6>
                  <div
                    id="magic-list-container"
                    class="border rounded p-2"
                    style="
                      min-height: 200px;
                      max-height: 300px;
                      overflow-y: auto;
                    "
                  >
                    <p class="text-muted text-center" id="no-magic-message">
                      Nenhuma magia adicionada ainda.
                    </p>
                  </div>
                  <div
                    class="mt-2 d-flex justify-content-between align-items-center"
                  >
                    <small class="text-muted"
                      >Total de magias: <span id="magic-count">0</span></small
                    >
                    <small class="text-info"
                      ><strong
                        >Custo Total:
                        <span id="magic-total-cost">0</span></strong
                      ></small
                    >
                    <button
                      type="button"
                      class="btn btn-sm btn-outline-danger"
                      onclick="clearAllMagics()"
                      title="Remover todas as magias"
                    >
                      üóëÔ∏è Limpar Todas
                    </button>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Bootstrap 5 JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>

    <script>
      // Extensible Component System for Character Sheet
      class SkillSectionComponent {
        constructor(containerId) {
          this.container = document.getElementById(containerId);
        }

        // Render a skill section from JSON configuration
        renderSection(config) {
          const attributeHtml = config.attribute
            ? `
            <div class="text-center mb-3">
              <div class="attribute-circle">
                <div class="attribute-label">${config.attribute.label}</div>
                <input
                  type="number"
                  class="form-control form-control-sm"
                  style="width: 50px; text-align: center"
                  value="0"
                  min="0"
                  max="3"
                  data-attribute="${config.attribute.dataAttribute}"
                  onchange="validateAttributeAndSkills('${config.attribute.dataAttribute}', '${config.sectionId}')"
                />
              </div>
              <button class="btn btn-sm btn-outline-primary mt-1" onclick="rollAttribute('${config.attribute.dataAttribute}', '${config.attribute.label}')" title="Rolar ${config.attribute.label}">
                üé≤ Rolar
              </button>
            </div>
          `
            : "";

          const sectionHtml = `
                    <div class="skill-${config.sectionId}-section">
                        ${attributeHtml}
                        <div class="section-title" onclick="${
                          config.onClick || "void(0)"
                        }" style="cursor: ${
            config.onClick ? "pointer" : "default"
          }">
                            ${config.label}
                        </div>
                        <div class="checkbox-list">
                            ${this.generateCheckboxes(
                              config.skills,
                              config.sectionId
                            )}
                        </div>
                    </div>
                `;
          return sectionHtml;
        }

        // Generate checkboxes based on skills array - now with 3 levels
        generateCheckboxes(skills, sectionId) {
          return skills
            .map(
              (skill, index) => `
                    <div class="form-check skill-levels" data-skill="${skill.name}" data-section="${sectionId}">
                        <label class="form-check-label skill-name">${skill.name}</label>
                        <div class="skill-level-boxes">
                            <input class="form-check-input skill-level" type="checkbox" id="${sectionId}_${index}_1" data-skill="${skill.name}" data-section="${sectionId}" data-level="1" onclick="toggleSkillLevel(this, 1)">
                            <label class="level-label" for="${sectionId}_${index}_1">1</label>
                            <input class="form-check-input skill-level" type="checkbox" id="${sectionId}_${index}_2" data-skill="${skill.name}" data-section="${sectionId}" data-level="2" onclick="toggleSkillLevel(this, 2)">
                            <label class="level-label" for="${sectionId}_${index}_2">2</label>
                            <input class="form-check-input skill-level" type="checkbox" id="${sectionId}_${index}_3" data-skill="${skill.name}" data-section="${sectionId}" data-level="3" onclick="toggleSkillLevel(this, 3)">
                            <label class="level-label" for="${sectionId}_${index}_3">3</label>
                            <button class="btn btn-xs btn-outline-success ms-2" onclick="rollSkill('${sectionId}', '${skill.name}')" title="Rolar ${skill.name}" style="font-size: 10px; padding: 2px 6px;">
                              üé≤
                            </button>
                        </div>
                    </div>
                `
            )
            .join("");
        }

        // Render multiple sections from JSON array
        renderFromJson(sectionsConfig) {
          let html = "";
          sectionsConfig.forEach((config) => {
            html += this.renderSection(config);
          });
          if (this.container) {
            this.container.innerHTML = html;
          }
          return html;
        }
      }

      // Resource/Stat Component for HP, Mana, etc.
      class ResourceComponent {
        constructor() {}

        // Render a resource section from JSON configuration
        renderResourceSection(config) {
          const diceSelector = config.diceType
            ? `
            <div class="col-12 mb-2">
              <div class="d-flex align-items-center justify-content-center">
                <label class="form-label me-2 mb-0"><strong>Dado:</strong></label>
                <select class="form-select form-select-sm dice-selector" style="width: auto;" id="${
                  config.diceSelectId
                }" onchange="onDiceTypeChange('${config.resourceName}')">
                  <option value="d4" ${
                    config.diceType === "d4" ? "selected" : ""
                  }>d4</option>
                  <option value="d6" ${
                    config.diceType === "d6" ? "selected" : ""
                  }>d6</option>
                  <option value="d8" ${
                    config.diceType === "d8" ? "selected" : ""
                  }>d8</option>
                  <option value="d10" ${
                    config.diceType === "d10" ? "selected" : ""
                  }>d10</option>
                  <option value="d12" ${
                    config.diceType === "d12" ? "selected" : ""
                  }>d12</option>
                </select>
                <button class="btn btn-sm btn-outline-warning ms-2" onclick="rollResourceDice('${
                  config.resourceName
                }', '${
                config.diceSelectId
              }')" title="Substituir rolls autom√°ticos por rolls manuais">
                  üé≤ Manual
                </button>
              </div>
            </div>
          `
            : "";

          const resourceHtml = `
            <div class="col-md-${config.columnSize || 6}">
              <div class="hp-mana-section">
                <div class="row">
                  ${diceSelector}
                  <div class="col-4">
                    <label class="form-label"><strong>Base ${
                      config.resourceName
                    }</strong></label>
                    <input
                      type="number"
                      class="form-control large-input"
                      id="${config.baseId}"
                      placeholder="${config.basePlaceholder || "0"}"
                      readonly
                      style="background-color: #f8f9fa; cursor: not-allowed;"
                    />
                    <button class="btn btn-xs btn-outline-info mt-1" style="font-size: 10px; padding: 2px 6px;" onclick="showResourceRollHistory('${
                      config.resourceName
                    }')" title="Ver hist√≥rico de rolls">
                      üìã Hist√≥rico
                    </button>
                  </div>
                  <div class="col-4">
                    <label class="form-label"><strong>Extra ${
                      config.resourceName
                    }</strong></label>
                    <input
                      type="number"
                      class="form-control large-input"
                      id="${config.extraId}"
                      placeholder="${config.extraPlaceholder || "0"}"
                      onchange="calculateResourceTotal('${
                        config.resourceName
                      }')"
                    />
                  </div>
                  <div class="col-4">
                    <label class="form-label"><strong>${
                      config.totalLabel
                    }</strong></label>
                    <input
                      type="number"
                      class="form-control large-input"
                      id="${config.totalId}"
                      placeholder="${config.totalPlaceholder || "0"}"
                      readonly
                      style="background-color: #f8f9fa; cursor: not-allowed;"
                    />
                  </div>
                  <div class="col-12 mt-2">
                    <label class="form-label"><strong>${
                      config.currentLabel
                    }</strong></label>
                    <input
                      type="number"
                      class="form-control large-input"
                      id="${config.currentId}"
                      placeholder="${config.currentPlaceholder || "0"}"
                    />
                  </div>
                </div>
              </div>
            </div>
          `;
          return resourceHtml;
        }

        // Render multiple resource sections from JSON array
        renderFromJson(resourcesConfig, containerId) {
          const container = document.getElementById(containerId);
          if (!container) return "";

          let html = '<div class="row mb-3">';
          resourcesConfig.forEach((config) => {
            html += this.renderResourceSection(config);
          });
          html += "</div>";

          container.innerHTML = html;
          return html;
        }
      }

      // Function to update dice selector availability based on character level
      function updateDiceSelectorAvailability() {
        const level =
          parseInt(document.getElementById("character-level")?.textContent) ||
          0;
        const diceSelectors = document.querySelectorAll(".dice-selector");

        diceSelectors.forEach((selector) => {
          if (level > 0) {
            // Disable selector and gray it out for levels above 0
            selector.disabled = true;
            selector.style.opacity = "0.5";
            selector.style.cursor = "not-allowed";
          } else {
            // Enable selector for level 0 (character creation)
            selector.disabled = false;
            selector.style.opacity = "1";
            selector.style.cursor = "pointer";
          }
        });
      }

      // Function to calculate resource total (Base + Extra = Total)
      function calculateResourceTotal(resourceName) {
        const config = resourceSectionsConfig.find(
          (c) => c.resourceName === resourceName
        );
        if (!config) return;

        const baseInput = document.getElementById(config.baseId);
        const extraInput = document.getElementById(config.extraId);
        const totalInput = document.getElementById(config.totalId);

        if (baseInput && extraInput && totalInput) {
          const baseValue = parseInt(baseInput.value) || 0;
          const extraValue = parseInt(extraInput.value) || 0;
          const total = baseValue + extraValue;

          totalInput.value = total;

          // Trigger auto-save after calculation
          clearTimeout(window.saveTimeout);
          window.saveTimeout = setTimeout(() => {
            saveCharacterDataToStorage();
          }, 500);
        }
      }

      // Configuration JSON for resource sections
      const resourceSectionsConfig = [
        {
          resourceName: "HP",
          totalLabel: "HP Total",
          currentLabel: "HP Atual",
          baseId: "hp-base",
          extraId: "hp-extra",
          totalId: "hp-total",
          currentId: "hp-current",
          columnSize: 6,
          diceType: "d6",
          diceSelectId: "hp-dice-select",
        },
        {
          resourceName: "Mana",
          totalLabel: "Mana Total",
          currentLabel: "Mana Atual",
          baseId: "mana-base",
          extraId: "mana-extra",
          totalId: "mana-total",
          currentId: "mana-current",
          columnSize: 6,
          diceType: "d6",
          diceSelectId: "mana-dice-select",
        },
        // You can easily add more resource types here:
        // {
        //   resourceName: "Stamina",
        //   totalLabel: "Stamina Total",
        //   currentLabel: "Stamina Atual",
        //   baseId: "stamina-base",
        //   extraId: "stamina-extra",
        //   totalId: "stamina-total",
        //   currentId: "stamina-current",
        //   columnSize: 6,
        //   diceType: "d8",
        //   diceSelectId: "stamina-dice-select"
        // }
      ];

      // Configuration JSON for skill sections
      const skillSectionsConfig = [
        // Conhecimento
        {
          label: "Conhecimento",
          sectionId: "conhecimento",
          onClick: "handleSectionClick('conhecimento')",
          attribute: { label: "CON", dataAttribute: "con" },
          skills: [
            { name: "Cartografia" },
            { name: "Ci√™ncias" },
            { name: "Demoli√ß√£o" },
            { name: "Investiga√ß√£o" },
            { name: "Matem√°tica" },
            { name: "Medicina" },
            { name: "Mestre de Venenos" },
            { name: "Natureza" },
            { name: "Psicologia" },
            { name: "Veterin√°ria" },
          ],
        },
        {
          label: "Social",
          sectionId: "social",
          onClick: "handleSectionClick('social')",
          attribute: { label: "SOC", dataAttribute: "soc" },
          skills: [
            { name: "Contar Hist√≥rias" },
            { name: "Discursar" },
            { name: "Embroma√ß√£o" },
            { name: "Intimida√ß√£o" },
            { name: "Mentira" },
            { name: "Negocia√ß√£o" },
            { name: "Persuas√£o" },
            { name: "Pol√≠tica" },
            { name: "Sedu√ß√£o" },
          ],
        },
        {
          label: "Cultura",
          sectionId: "cultura",
          onClick: "handleSectionClick('cultura')",
          attribute: { label: "CUL", dataAttribute: "cul" },
          skills: [
            { name: "Belas Artes" },
            { name: "Folclore" },
            { name: "Hist√≥ria" },
            { name: "Jogos" },
            { name: "Morfologia" },
            { name: "Performance" },
            { name: "Religi√£o" },
            { name: "Forja" },
          ],
        },
        {
          label: "Atletismo",
          sectionId: "atletismo",
          onClick: "handleSectionClick('atletismo')",
          attribute: { label: "ALT", dataAttribute: "alt" },
          skills: [
            { name: "Acrobacia" },
            { name: "Atl√©tica" },
            { name: "Carga" },
            { name: "Constitui√ß√£o" },
            { name: "Equil√≠brio" },
            { name: "For√ßa" },
            { name: "Reflexos" },
          ],
        },
        {
          label: "Manufatura",
          sectionId: "manufatura",
          onClick: "handleSectionClick('manufatura')",
          attribute: { label: "MAN", dataAttribute: "man" },
          skills: [
            { name: "Alfaiatismo" },
            { name: "Alquimia" },
            { name: "Carpintaria" },
            { name: "Disfarce" },
            { name: "Encantamento" },
            { name: "Escriba" },
            { name: "Falsifica√ß√£o" },
            { name: "Forja" },
            { name: "Leather Working" },
          ],
        },
        {
          label: "Combate",
          sectionId: "combate",
          onClick: "handleSectionClick('combate')",
          attribute: { label: "COM", dataAttribute: "com" },
          skills: [
            { name: "Acur√°cia" },
            { name: "Ambidestria" },
            { name: "Combate Improvisado" },
            { name: "Esgrima" },
            { name: "Furioso" },
            { name: "Longa Vista" },
            { name: "Marcial" },
            { name: "Oportunista" },
            { name: "Two-Handed" },
          ],
        },
        {
          label: "Sobreviv√™ncia",
          sectionId: "sobrevivencia",
          onClick: "handleSectionClick('sobrevivencia')",
          attribute: { label: "SOB", dataAttribute: "sob" },
          skills: [
            { name: "Acampamento" },
            { name: "Adestramento" },
            { name: "Companheiro Animal" },
            { name: "Cozinhar" },
            { name: "Esfolagem" },
            { name: "Furtividade" },
            { name: "Improviso" },
            { name: "Lockpick" },
            { name: "Montar Armadilhas" },
            { name: "Montaria" },
            { name: "Percep√ß√£o" },
            { name: "Pick Pocket" },
            { name: "Rastreio" },
            { name: "Vontade" },
          ],
        },

        {
          label: "Magia",
          sectionId: "magia",
          onClick: "handleSectionClick('magia')",
          attribute: { label: "MAG", dataAttribute: "mag" },
          skills: [
            { name: "Acad√™mico" },
            { name: "B√™n√ß√£os" },
            { name: "Conjura√ß√£o" },
            { name: "Energia" },
            { name: "F√©" },
            { name: "Feiti√ßaria" },
            { name: "Ilusionismo" },
            { name: "Invocador" },
            { name: "Ocultismo" },
            { name: "Shamanismo" },
          ],
        },
      ];

      // Roll functions for attributes and skills
      function rollAttribute(attributeKey, attributeName) {
        const attributeInput = document.querySelector(
          `input[data-attribute="${attributeKey}"]`
        );
        if (!attributeInput) {
          alert(`Atributo ${attributeName} n√£o encontrado!`);
          return;
        }

        const attributeLevel = parseInt(attributeInput.value) || 0;

        // Roll dice based on attribute level
        const diceCount = attributeLevel + 2; // +2 for base dice
        const rolls = [];

        for (let i = 0; i < diceCount; i++) {
          rolls.push(Math.floor(Math.random() * 6) + 1);
        }

        const total = rolls.reduce((sum, roll) => sum + roll, 0);
        const result = `üé≤ ${attributeName} (${diceCount}d6): [${rolls.join(
          ", "
        )}] = ${total}`;

        // Display result (you can customize this)
        alert(result);
        console.log(result);
      }

      function rollSkill(sectionId, skillName) {
        // Find the skill configuration
        const config = skillSectionsConfig.find(
          (c) => c.sectionId === sectionId
        );
        if (!config || !config.attribute) {
          alert(`Configura√ß√£o n√£o encontrada para ${skillName}!`);
          return;
        }

        // Get attribute level
        const attributeInput = document.querySelector(
          `input[data-attribute="${config.attribute.dataAttribute}"]`
        );
        if (!attributeInput) {
          alert(`Atributo ${config.attribute.label} n√£o encontrado!`);
          return;
        }
        const attributeLevel = parseInt(attributeInput.value) || 0;

        // Get skill level
        const skillContainer = document.querySelector(
          `[data-skill="${skillName}"][data-section="${sectionId}"]`
        );
        if (!skillContainer) {
          alert(`Habilidade ${skillName} n√£o encontrada!`);
          return;
        }

        const levelCheckboxes = skillContainer.querySelectorAll(
          ".skill-level:checked"
        );
        let skillLevel = 0;
        levelCheckboxes.forEach((checkbox) => {
          const level = parseInt(checkbox.dataset.level);
          if (level > skillLevel) skillLevel = level;
        });

        // TODO Implement skill adapter
        const flatBonus = 0; // Placeholder for flat bonus logic

        const diceCount = attributeLevel + 2; // +2 for base dice
        const rolls = [];

        for (let i = 0; i < diceCount; i++) {
          rolls.push(Math.floor(Math.random() * 6) + 1);
        }

        const flatBonusString = flatBonus > 0 ? ` + ${flatBonus}` : "";

        // Calculate total dice (attribute + skill)
        const total = rolls.reduce((sum, roll) => sum + roll, 0) + flatBonus;
        const result = `üé≤ ${skillName} (${diceCount}d6): [${rolls.join(
          ", "
        )}] ${flatBonusString} = ${total}`;

        // Display result (you can customize this)
        alert(result);
        console.log(result);
      }

      // Roll function for resource dice (HP, Mana, etc.)
      function rollResourceDice(resourceName, diceSelectId) {
        const diceSelect = document.getElementById(diceSelectId);
        if (!diceSelect) {
          alert(`Seletor de dado para ${resourceName} n√£o encontrado!`);
          return;
        }

        const level =
          parseInt(document.getElementById("character-level")?.textContent) ||
          0;
        const diceType = diceSelect.value;
        const diceSides = parseInt(diceType.substring(1)); // Remove 'd' and get number

        if (level === 0) {
          // Level 0: Set base to maximum dice value
          const maxValue = diceSides;
          initializeResourceBase(resourceName, maxValue, diceType);

          const result = `üé≤ ${resourceName} (N√≠vel 0): Base inicializada com valor m√°ximo ${maxValue}`;
          alert(result);
          console.log(result);
        } else {
          // Level 1+: Show confirmation and clear automatic history
          const confirmMessage = `Isso ir√° substituir todos os rolls autom√°ticos com rolls manuais.\n\nDeseja continuar e rolar manualmente para ${resourceName}?`;
          if (!confirm(confirmMessage)) {
            return;
          }

          // Clear existing history and start fresh with manual rolls
          clearResourceHistoryAndStartManual(resourceName, diceType, level);
        }
      }

      // Function to clear automatic history and start manual rolling
      function clearResourceHistoryAndStartManual(
        resourceName,
        diceType,
        currentLevel
      ) {
        const config = resourceSectionsConfig.find(
          (c) => c.resourceName === resourceName
        );
        if (!config) return;

        // Start fresh history - keep only level 0 if it exists
        const existingHistory = getResourceRollHistory(resourceName);
        const level0Entry = existingHistory.find((entry) => entry.level === 0);

        let newHistory = [];
        let baseValue = 0;

        if (level0Entry) {
          // Keep level 0 initialization
          newHistory.push(level0Entry);
          baseValue = level0Entry.roll;
        } else {
          // Create level 0 entry with max dice value
          const diceSides = parseInt(diceType.substring(1));
          const maxValue = diceSides;
          newHistory.push({
            level: 0,
            roll: maxValue,
            diceType: diceType,
            description: `N√≠vel 0: Valor m√°ximo do ${diceType}`,
          });
          baseValue = maxValue;
        }

        // Now roll manually for each level from 1 to current level
        for (let level = 1; level <= currentLevel; level++) {
          const diceSides = parseInt(diceType.substring(1));
          const roll = Math.floor(Math.random() * diceSides) + 1;
          baseValue += roll;

          newHistory.push({
            level: level,
            roll: roll,
            diceType: diceType,
            description: `N√≠vel ${level}: Rolou ${roll} no ${diceType} (manual)`,
          });
        }

        // Update the base input
        const baseInput = document.getElementById(config.baseId);
        if (baseInput) {
          baseInput.value = baseValue;
        }

        // Save the new manual history
        saveResourceRollHistory(resourceName, newHistory);

        // Show summary of manual rolls
        showManualRollSummary(
          resourceName,
          newHistory.filter((entry) => entry.level > 0)
        );

        // Recalculate total
        calculateResourceTotal(resourceName);
      }

      // Function to show summary of manual rolls
      function showManualRollSummary(resourceName, manualRolls) {
        if (manualRolls.length === 0) return;

        let summary = `üé≤ Rolls Manuais - ${resourceName}:\n\n`;
        let totalGained = 0;

        manualRolls.forEach((roll) => {
          summary += `N√≠vel ${roll.level}: Rolou ${roll.roll} no ${roll.diceType}\n`;
          totalGained += roll.roll;
        });

        summary += `\nTotal ganho nos rolls: +${totalGained}`;
        summary += `\nHist√≥rico autom√°tico foi substitu√≠do pelos rolls manuais.`;

        alert(summary);
      }

      // Function to initialize base resource at level 0
      function initializeResourceBase(resourceName, baseValue, diceType) {
        const config = resourceSectionsConfig.find(
          (c) => c.resourceName === resourceName
        );
        if (!config) return;

        const baseInput = document.getElementById(config.baseId);
        if (baseInput) {
          baseInput.value = baseValue;
        }

        // Initialize roll history
        const rollHistory = [
          {
            level: 0,
            roll: baseValue,
            diceType: diceType,
            description: `N√≠vel 0: Valor m√°ximo do ${diceType}`,
          },
        ];

        // Save roll history to resource data
        saveResourceRollHistory(resourceName, rollHistory);

        // Recalculate total
        calculateResourceTotal(resourceName);
      }

      // Function to roll dice and add to resource base
      function rollAndAddToResource(resourceName, diceType, level) {
        const config = resourceSectionsConfig.find(
          (c) => c.resourceName === resourceName
        );
        if (!config) return;

        const baseInput = document.getElementById(config.baseId);
        if (!baseInput) return;

        const diceSides = parseInt(diceType.substring(1));
        const roll = Math.floor(Math.random() * diceSides) + 1;
        const currentBase = parseInt(baseInput.value) || 0;
        const newBase = currentBase + roll;

        baseInput.value = newBase;

        // Get existing roll history and add new roll
        const existingHistory = getResourceRollHistory(resourceName);
        existingHistory.push({
          level: level,
          roll: roll,
          diceType: diceType,
          description: `N√≠vel ${level}: Rolou ${roll} no ${diceType}`,
        });

        saveResourceRollHistory(resourceName, existingHistory);

        const result = `üé≤ ${resourceName} (N√≠vel ${level}): Rolou ${roll} no ${diceType}. Base: ${currentBase} + ${roll} = ${newBase}`;
        alert(result);
        console.log(result);

        // Recalculate total
        calculateResourceTotal(resourceName);
      }

      // Function to save resource roll history
      function saveResourceRollHistory(resourceName, rollHistory) {
        const key = `${resourceName.toLowerCase()}_roll_history`;
        try {
          localStorage.setItem(key, JSON.stringify(rollHistory));
        } catch (error) {
          console.error(
            `Error saving roll history for ${resourceName}:`,
            error
          );
        }
      }

      // Function to get resource roll history
      function getResourceRollHistory(resourceName) {
        const key = `${resourceName.toLowerCase()}_roll_history`;
        try {
          const history = localStorage.getItem(key);
          return history ? JSON.parse(history) : [];
        } catch (error) {
          console.error(
            `Error loading roll history for ${resourceName}:`,
            error
          );
          return [];
        }
      }

      // Function to show resource roll history
      function showResourceRollHistory(resourceName) {
        const history = getResourceRollHistory(resourceName);

        if (history.length === 0) {
          alert(`Nenhum hist√≥rico de rolls encontrado para ${resourceName}.`);
          return;
        }

        let historyText = `Hist√≥rico de Rolls - ${resourceName}:\n\n`;
        let total = 0;

        history.forEach((entry, index) => {
          historyText += `${entry.description}\n`;
          total = index === 0 ? entry.roll : total + entry.roll;
        });

        historyText += `\nTotal Base: ${total}`;

        alert(historyText);
      }

      // Function to show summary of automatic rolls
      function showAutoRollSummary(levelsRolled) {
        if (levelsRolled.length === 0) return;

        let summary = `üé≤ Rolls Autom√°ticos - N√≠veis ${levelsRolled.join(
          ", "
        )}:\n\n`;

        resourceSectionsConfig.forEach((config) => {
          const history = getResourceRollHistory(config.resourceName);
          const levelRolls = history.filter((entry) =>
            levelsRolled.includes(entry.level)
          );

          if (levelRolls.length > 0) {
            summary += `${config.resourceName}:\n`;
            levelRolls.forEach((roll) => {
              summary += `  N√≠vel ${roll.level}: ${roll.roll} no ${roll.diceType}\n`;
            });

            // Calculate total gained
            const totalGained = levelRolls.reduce(
              (sum, roll) => sum + roll.roll,
              0
            );
            summary += `  Total ganho: +${totalGained}\n\n`;
          }
        });

        summary += `Clique no bot√£o "üìã Hist√≥rico" para ver todos os rolls detalhados.`;
        alert(summary);
      }

      // Function called when dice type changes
      function onDiceTypeChange(resourceName) {
        // Always trigger resource recalculation when dice type changes, clearing history
        updateResourceBaseValues(true); // true indicates dice type changed

        // Always trigger auto-save when dice type changes
        clearTimeout(window.saveTimeout);
        window.saveTimeout = setTimeout(() => {
          saveCharacterDataToStorage();
        }, 500);
      }

      // Single comprehensive function to handle all resource base calculations
      function updateResourceBaseValues(diceTypeChanged = false) {
        const currentLevel =
          parseInt(document.getElementById("character-level")?.textContent) ||
          0;

        console.log(
          `Updating resource base values for level ${currentLevel}${
            diceTypeChanged ? " (dice type changed)" : ""
          }`
        );

        resourceSectionsConfig.forEach((config) => {
          const diceSelect = document.getElementById(config.diceSelectId);
          const baseInput = document.getElementById(config.baseId);

          if (!diceSelect || !baseInput) return;

          const diceType = diceSelect.value;
          const diceSides = parseInt(diceType.substring(1));

          // Get existing roll history
          let rollHistory = getResourceRollHistory(config.resourceName);

          // If dice type changed, check if we need to clear history
          if (diceTypeChanged && rollHistory.length > 0) {
            // Check if the existing history has different dice types
            const existingDiceType = rollHistory[0]?.diceType;
            if (existingDiceType && existingDiceType !== diceType) {
              console.log(
                `Dice type changed from ${existingDiceType} to ${diceType} for ${config.resourceName}, clearing history`
              );
              rollHistory = []; // Clear the history
              localStorage.setItem(
                `${config.resourceName.toLowerCase()}_roll_history`,
                JSON.stringify(rollHistory)
              );
            }
          }

          const existingLevels = new Set(
            rollHistory.map((entry) => entry.level)
          );

          // Ensure level 0 exists in history
          if (!existingLevels.has(0)) {
            const maxValue = diceSides;
            rollHistory.unshift({
              level: 0,
              roll: maxValue,
              diceType: diceType,
              description: `N√≠vel 0: Valor m√°ximo do ${diceType}`,
            });
            existingLevels.add(0);
            console.log(
              `Auto-initialized ${config.resourceName} level 0 with ${maxValue}`
            );
          }

          // Find and roll for missing levels from 1 to currentLevel
          const missingLevels = [];
          for (let level = 1; level <= currentLevel; level++) {
            if (!existingLevels.has(level)) {
              missingLevels.push(level);
            }
          }

          // Roll for missing levels
          missingLevels.forEach((level) => {
            const roll = Math.floor(Math.random() * diceSides) + 1;
            rollHistory.push({
              level: level,
              roll: roll,
              diceType: diceType,
              description: `N√≠vel ${level}: Rolou ${roll} no ${diceType} (autom√°tico)`,
            });
            console.log(
              `üé≤ ${config.resourceName} (N√≠vel ${level}): Rolou ${roll} no ${diceType}`
            );
          });

          // Sort history by level
          rollHistory.sort((a, b) => a.level - b.level);

          // Calculate base value up to current level
          let calculatedBase = 0;
          rollHistory.forEach((entry) => {
            if (entry.level <= currentLevel) {
              if (entry.level === 0) {
                calculatedBase = entry.roll; // Level 0 sets the base
              } else {
                calculatedBase += entry.roll; // Subsequent levels add to base
              }
            }
          });

          // Update the base input
          baseInput.value = calculatedBase;
          console.log(
            `Updated ${config.resourceName} base to ${calculatedBase} (up to level ${currentLevel})`
          );

          // Save updated roll history (only if we added new rolls)
          if (missingLevels.length > 0) {
            saveResourceRollHistory(config.resourceName, rollHistory);
          }

          // Recalculate total after base update
          calculateResourceTotal(config.resourceName);
        });
      }

      // Level editing functions
      function editLevel(element) {
        // Store current level before editing for comparison
        element.dataset.previousLevel = element.textContent;

        element.focus();
        // Select all text when clicking to edit
        if (window.getSelection && document.createRange) {
          const range = document.createRange();
          range.selectNodeContents(element);
          const selection = window.getSelection();
          selection.removeAllRanges();
          selection.addRange(range);
        }
      }

      function saveLevel(element) {
        const previousLevel = parseInt(element.dataset.previousLevel) || 0;
        let level = parseInt(element.textContent) || 0;
        if (level < 0) level = 0;
        if (level > 20) level = 20; // Set a reasonable max level
        element.textContent = level;

        // Store the new level for next comparison
        element.dataset.previousLevel = level;

        console.log(`Level changed from ${previousLevel} to ${level}`);

        // Update available points when level changes
        updateMaxPointsOnLevelUp();

        // Update dice selector availability based on new level
        updateDiceSelectorAvailability();

        // Update all resource base values for the new level
        updateResourceBaseValues(false); // false indicates level change, not dice type change

        // Trigger auto-save
        clearTimeout(window.saveTimeout);
        window.saveTimeout = setTimeout(() => {
          saveCharacterDataToStorage();
        }, 500);
      }
      function handleLevelKeypress(event, element) {
        // Allow only numbers and enter key
        if (event.key === "Enter") {
          element.blur();
          return false;
        }

        // Allow only digits, backspace, delete, arrow keys
        if (
          !/[\d]/.test(event.key) &&
          !["Backspace", "Delete", "ArrowLeft", "ArrowRight"].includes(
            event.key
          )
        ) {
          event.preventDefault();
          return false;
        }
      }

      // Function to update available points when leveling up
      function updateMaxPointsOnLevelUp() {
        // Currently empty as requested
        // This function will be used to calculate available points based on level progression

        // For now, calculate basic available points
        calculateAvailablePoints();
      }

      // Configuration for level progression
      const levelProgressionConfig = {
        // Skill points gained at each level (cumulative) - array index = level
        skillPointsPerLevel: [
          10, // Level 0: Starting skill points
          4, // Level 1: +4 skill points when reaching level 1
          6, // Level 2: +6 skill points when reaching level 2
          8, // Level 3: +8 skill points when reaching level 3
          8, // Level 4: +8 skill points when reaching level 4
          8, // Level 5: +8 skill points when reaching level 5
          10, // Level 6: +10 skill points when reaching level 6
          12, // Level 7: +12 skill points when reaching level 7
          14, // Level 8: +14 skill points when reaching level 8
          14, // Level 9: +14 skill points when reaching level 9
          16, // Level 10: +16 skill points when reaching level 10
          16, // Level 11: +16 skill points when reaching level 11
          14, // Level 12: +14 skill points when reaching level 12
          14, // Level 13: +14 skill points when reaching level 13
          12, // Level 14: +12 skill points when reaching level 14
          10, // Level 15: +10 skill points when reaching level 15
          8, // Level 16: +8 skill points when reaching level 16
          8, // Level 17: +8 skill points when reaching level 17
          8, // Level 18: +8 skill points when reaching level 18
          6, // Level 19: +6 skill points when reaching level 19
          4, // Level 20: +4 skill points when reaching level 20
        ],
        // Attribute points: base 5 + 1 for every even level
        attributePointsBase: 5,
        attributePointsPerEvenLevel: 1,
      };

      // Function to calculate available points based on character level
      function calculateAvailablePoints() {
        const level =
          parseInt(document.getElementById("character-level").textContent) || 0;

        // Calculate attribute points: base + bonus for even levels
        const evenLevelBonus =
          Math.floor(level / 2) *
          levelProgressionConfig.attributePointsPerEvenLevel;
        const availableAttributePoints =
          levelProgressionConfig.attributePointsBase + evenLevelBonus;

        // Calculate cumulative skill points
        let availableSkillPoints = 0;

        // Sum up skill points from level 0 to current level
        for (let i = 0; i <= level; i++) {
          if (i < levelProgressionConfig.skillPointsPerLevel.length) {
            availableSkillPoints +=
              levelProgressionConfig.skillPointsPerLevel[i];
          }
          // If level goes beyond array size, ignore (no additional points)
        }

        // Update the display
        document.getElementById("attribute-available").textContent =
          availableAttributePoints;
        document.getElementById("skill-available").textContent =
          availableSkillPoints;

        return {
          attributes: availableAttributePoints,
          skills: availableSkillPoints,
        };
      }

      // Event handler for section clicks
      function handleSectionClick(sectionId) {
        console.log(`Section clicked: ${sectionId}`);

        // Example: Toggle section highlight
        const section = document.querySelector(`[data-section="${sectionId}"]`);
        if (section) {
          section.classList.toggle("highlighted");
        }

        // Custom logic can be added here for each section
        switch (sectionId) {
          case "social":
            console.log("Social skills section clicked");
            break;
          case "cultura":
            console.log("Cultura skills section clicked");
            break;
          case "atletismo":
            console.log("Atletismo skills section clicked");
            break;
          case "manual":
            console.log("Manual skills section clicked");
            break;
          case "combate":
            console.log("Combate skills section clicked");
            break;
          case "sobrevivencia":
            console.log("Sobreviv√™ncia skills section clicked");
            break;
          case "sistema_faq":
            console.log("Sistema FAQ section clicked");
            break;
          case "magia":
            console.log("Magia section clicked");
            break;
          case "recursos":
            console.log("Recursos section clicked");
            break;
          default:
            console.log("Unknown section clicked");
        }
      }

      // Function to save character data to localStorage
      function saveCharacterDataToStorage() {
        const data = saveCharacterData();
        try {
          localStorage.setItem("fac_character_sheet", JSON.stringify(data));
          console.log("Character data saved to localStorage");
        } catch (error) {
          console.error("Error saving to localStorage:", error);
        }
      }

      // Function to load character data from localStorage
      function loadCharacterDataFromStorage() {
        try {
          const savedData = localStorage.getItem("fac_character_sheet");
          if (savedData) {
            const data = JSON.parse(savedData);
            loadCharacterData(data);
            // Recalculate points after loading
            calculateTotalPoints();
            console.log("Character data loaded from localStorage");
            return true;
          }
        } catch (error) {
          console.error("Error loading from localStorage:", error);
        }
        return false;
      }

      // Function to clear saved character data
      function clearSavedCharacterData() {
        try {
          localStorage.removeItem("fac_character_sheet");
          localStorage.removeItem("fac_character_magics");
          // Clear roll histories for all resources
          resourceSectionsConfig.forEach((config) => {
            localStorage.removeItem(
              `${config.resourceName.toLowerCase()}_roll_history`
            );
          });

          // Clear magic manager
          if (magicManager) {
            magicManager.magics = [];
            magicManager.renderMagicList();
          }

          console.log("All saved character data cleared");
          alert("Todos os dados salvos foram removidos.");
        } catch (error) {
          console.error("Error clearing localStorage:", error);
        }
      }

      // Function to save character data to JSON
      function saveCharacterData() {
        const data = {
          characterName: document.querySelector(
            'input[placeholder="Nome do personagem"]'
          ).value,
          description: document.querySelector(
            'textarea[placeholder="Descri√ß√£o do personagem..."]'
          ).value,
          level:
            parseInt(document.getElementById("character-level").textContent) ||
            0,
          attributes: {
            con:
              document.querySelector('input[data-attribute="con"]')?.value || 0,
            soc:
              document.querySelector('input[data-attribute="soc"]')?.value || 0,
            mag:
              document.querySelector('input[data-attribute="mag"]')?.value || 0,
            alt:
              document.querySelector('input[data-attribute="alt"]')?.value || 0,
            man:
              document.querySelector('input[data-attribute="man"]')?.value || 0,
            com:
              document.querySelector('input[data-attribute="com"]')?.value || 0,
            sob:
              document.querySelector('input[data-attribute="sob"]')?.value || 0,
            cul:
              document.querySelector('input[data-attribute="cul"]')?.value || 0,
          },
          skills: {},
          hp: {
            base: document.getElementById("hp-base")?.value || 0,
            extra: document.getElementById("hp-extra")?.value || 0,
            total: document.getElementById("hp-total")?.value || 0,
            current: document.getElementById("hp-current")?.value || 0,
            diceType: document.getElementById("hp-dice-select")?.value || "d6",
            rollHistory: getResourceRollHistory("HP"),
          },
          mana: {
            base: document.getElementById("mana-base")?.value || 0,
            extra: document.getElementById("mana-extra")?.value || 0,
            total: document.getElementById("mana-total")?.value || 0,
            current: document.getElementById("mana-current")?.value || 0,
            diceType:
              document.getElementById("mana-dice-select")?.value || "d6",
            rollHistory: getResourceRollHistory("Mana"),
          },
        };

        // Collect skill levels (1, 2, 3) instead of just checked/unchecked
        document.querySelectorAll(".skill-levels").forEach((skillContainer) => {
          const skillName = skillContainer.dataset.skill;
          const levelCheckboxes = skillContainer.querySelectorAll(
            ".skill-level:checked"
          );

          // Find the highest checked level for this skill
          let maxLevel = 0;
          levelCheckboxes.forEach((checkbox) => {
            const level = parseInt(checkbox.dataset.level);
            if (level > maxLevel) maxLevel = level;
          });

          data.skills[skillName] = maxLevel;
        });

        // Collect resources and inventory text
        const resourcesTextarea = document.querySelector(
          '[data-section="recursos"] textarea'
        );
        if (resourcesTextarea) {
          data.resources = resourcesTextarea.value;
        }

        const inventoryTextarea = document.querySelector(
          '.resources-section:not([data-section="recursos"]) textarea'
        );
        if (inventoryTextarea) {
          data.inventory = inventoryTextarea.value;
        }

        // Collect movement value
        const movementInput = document.getElementById("movement");
        if (movementInput) {
          data.movement = movementInput.value;
        }

        // Collect magics data
        if (magicManager) {
          data.magics = magicManager.getMagicsData();
        }

        return data;
      }

      // Function to load character data from JSON
      function loadCharacterData(data) {
        if (data.characterName) {
          document.querySelector(
            'input[placeholder="Nome do personagem"]'
          ).value = data.characterName;
        }
        if (data.description) {
          document.querySelector(
            'textarea[placeholder="Descri√ß√£o do personagem..."]'
          ).value = data.description;
        }

        // Load character level
        if (data.level !== undefined) {
          const levelElement = document.getElementById("character-level");
          if (levelElement) {
            levelElement.textContent = data.level;
            // Initialize previous level for future comparisons
            levelElement.dataset.previousLevel = data.level;
          }
        }

        // Load attributes
        Object.keys(data.attributes || {}).forEach((attr) => {
          const input = document.querySelector(
            `input[data-attribute="${attr}"]`
          );
          if (input) input.value = data.attributes[attr];
        });

        // Load skills with levels
        Object.keys(data.skills || {}).forEach((skillName) => {
          const skillLevel = data.skills[skillName];
          const skillContainer = document.querySelector(
            `[data-skill="${skillName}"].skill-levels`
          );

          if (skillContainer && skillLevel > 0) {
            // Check all levels up to the saved level
            for (let level = 1; level <= skillLevel; level++) {
              const checkbox = skillContainer.querySelector(
                `input[data-level="${level}"]`
              );
              if (checkbox) checkbox.checked = true;
            }
          }
        });

        // Load resources
        if (data.resources !== undefined) {
          const resourcesTextarea = document.querySelector(
            '[data-section="recursos"] textarea'
          );
          if (resourcesTextarea) {
            resourcesTextarea.value = data.resources;
          }
        }

        // Load inventory
        if (data.inventory !== undefined) {
          const inventoryTextarea = document.querySelector(
            '.resources-section:not([data-section="recursos"]) textarea'
          );
          if (inventoryTextarea) {
            inventoryTextarea.value = data.inventory;
          }
        }

        // Load movement
        if (data.movement !== undefined) {
          const movementInput = document.getElementById("movement");
          if (movementInput) {
            movementInput.value = data.movement;
          }
        }

        // Load HP and Mana values
        if (data.hp) {
          if (data.hp.base !== undefined) {
            const hpBaseInput = document.getElementById("hp-base");
            if (hpBaseInput) hpBaseInput.value = data.hp.base;
          }
          if (data.hp.extra !== undefined) {
            const hpExtraInput = document.getElementById("hp-extra");
            if (hpExtraInput) hpExtraInput.value = data.hp.extra;
          }
          if (data.hp.total !== undefined) {
            const hpTotalInput = document.getElementById("hp-total");
            if (hpTotalInput) hpTotalInput.value = data.hp.total;
          }
          if (data.hp.current !== undefined) {
            const hpCurrentInput = document.getElementById("hp-current");
            if (hpCurrentInput) hpCurrentInput.value = data.hp.current;
          }
          if (data.hp.diceType !== undefined) {
            const hpDiceSelect = document.getElementById("hp-dice-select");
            if (hpDiceSelect) hpDiceSelect.value = data.hp.diceType;
          }
          if (data.hp.rollHistory !== undefined) {
            saveResourceRollHistory("HP", data.hp.rollHistory);
          }
        }

        if (data.mana) {
          if (data.mana.base !== undefined) {
            const manaBaseInput = document.getElementById("mana-base");
            if (manaBaseInput) manaBaseInput.value = data.mana.base;
          }
          if (data.mana.extra !== undefined) {
            const manaExtraInput = document.getElementById("mana-extra");
            if (manaExtraInput) manaExtraInput.value = data.mana.extra;
          }
          if (data.mana.total !== undefined) {
            const manaTotalInput = document.getElementById("mana-total");
            if (manaTotalInput) manaTotalInput.value = data.mana.total;
          }
          if (data.mana.current !== undefined) {
            const manaCurrentInput = document.getElementById("mana-current");
            if (manaCurrentInput) manaCurrentInput.value = data.mana.current;
          }
          if (data.mana.diceType !== undefined) {
            const manaDiceSelect = document.getElementById("mana-dice-select");
            if (manaDiceSelect) manaDiceSelect.value = data.mana.diceType;
          }
          if (data.mana.rollHistory !== undefined) {
            saveResourceRollHistory("Mana", data.mana.rollHistory);
          }
        }

        // Revalidate and recalculate after loading
        // Update skill availability for all sections based on loaded attribute values
        skillSectionsConfig.forEach((config) => {
          if (config.attribute) {
            const attributeInput = document.querySelector(
              `input[data-attribute="${config.attribute.dataAttribute}"]`
            );
            const attributeValue = attributeInput
              ? parseInt(attributeInput.value) || 0
              : 0;
            updateSkillAvailability(config.sectionId, attributeValue);
          }
        });

        // Update available points first, then calculate totals
        calculateAvailablePoints();
        validateAttributeAndSkills();
        calculateTotalPoints();

        // Recalculate resource totals after loading
        resourceSectionsConfig.forEach((config) => {
          calculateResourceTotal(config.resourceName);
        });

        // Load magics data
        if (data.magics && magicManager) {
          magicManager.loadMagicsData(data.magics);
        }

        // Update dice selector availability based on loaded level
        updateDiceSelectorAvailability();
      }

      // Add CSS for highlighted sections
      const style = document.createElement("style");
      style.textContent = `
            .highlighted .section-title {
                background: #007bff !important;
                transform: scale(1.02);
                transition: all 0.2s ease;
            }
            .section-title:hover {
                opacity: 0.8;
                transition: opacity 0.2s ease;
            }
            .skill-level:disabled {
                opacity: 0.3 !important;
                cursor: not-allowed !important;
            }
            .skill-level:disabled + .level-label {
                color: #6c757d !important;
                opacity: 0.3 !important;
            }
            .skill-levels:not(.disabled) .skill-level:not(:disabled) {
                opacity: 1;
                cursor: pointer;
            }
            .skill-levels:not(.disabled) .skill-level:not(:disabled) + .level-label {
                color: inherit;
                opacity: 1;
            }
            input[data-attribute] {
                border: 2px solid #333;
                font-weight: bold;
            }
            input[data-attribute]:focus {
                border-color: #007bff;
                box-shadow: 0 0 0 0.2rem rgba(0,123,255,.25);
            }
        `;
      document.head.appendChild(style);

      // Initialize the extensible components when the page loads
      document.addEventListener("DOMContentLoaded", function () {
        console.log("Character Sheet Extensible Components Initialized");

        // Initialize magic manager
        magicManager = new MagicManager();

        // Render dynamic sections using the component system
        const skillComponent = new SkillSectionComponent();
        const resourceComponent = new ResourceComponent();

        // Render resource sections (HP, Mana, etc.)
        resourceComponent.renderFromJson(
          resourceSectionsConfig,
          "resource-sections-container"
        );

        // Generate all sections HTML
        let allSectionsHtml = "";
        skillSectionsConfig.forEach((config) => {
          allSectionsHtml += skillComponent.renderSection(config);
        });

        // Render all JSON sections together in the main layout
        renderAllSectionsInLayout(skillComponent);

        // Also render all sections in the preview container if it exists
        const allSectionsContainer = document.getElementById(
          "all-sections-container"
        );
        if (allSectionsContainer) {
          allSectionsContainer.innerHTML = allSectionsHtml;
        }

        // Update the Sistema FAQ section (Conhecimento)
        const sistemaFaqSection = document.querySelector(
          '[data-section="sistema_faq"] .card-body'
        );
        if (sistemaFaqSection && skillSectionsConfig[0]) {
          // Conhecimento is index 0
          const conhecimentoConfig = skillSectionsConfig[0];
          const conhecimentoHtml = `
            <div class="checkbox-list">
              ${skillComponent.generateCheckboxes(
                conhecimentoConfig.skills,
                conhecimentoConfig.sectionId
              )}
            </div>
          `;
          sistemaFaqSection.innerHTML = conhecimentoHtml;
        }

        // Update the Magia section in the top area if it exists
        const magiaSection = document.querySelector(
          '[data-section="magia"] .card-body'
        );
        if (magiaSection && skillSectionsConfig[7]) {
          // Magia is index 7
          const magiaConfig = skillSectionsConfig[7];
          const magiaHtml = `
            <div class="checkbox-list">
              ${skillComponent.generateCheckboxes(
                magiaConfig.skills,
                magiaConfig.sectionId
              )}
            </div>
          `;
          magiaSection.innerHTML = magiaHtml;
        }

        console.log(
          "All sections have been dynamically updated with their configurations"
        );

        // Initial point calculation
        calculateTotalPoints();

        // Calculate available points
        calculateAvailablePoints();

        // Load any saved character data
        const hasLoadedData = loadCharacterDataFromStorage();

        // If no saved data was loaded, initialize skill availability with default values
        if (!hasLoadedData) {
          skillSectionsConfig.forEach((config) => {
            if (config.attribute) {
              updateSkillAvailability(config.sectionId, 0); // Start with 0 attribute values
            }
          });

          // Initialize previous level for new characters
          const levelElement = document.getElementById("character-level");
          if (levelElement) {
            levelElement.dataset.previousLevel =
              levelElement.textContent || "0";
          }
        }

        // Set up automatic saving
        setupAutoSave();

        // Update dice selector availability on initial load
        updateDiceSelectorAvailability();

        // Recalculate base resources after everything is loaded
        updateResourceBaseValues(false); // false indicates initialization, not dice type change

        // Render initial magic list
        if (magicManager) {
          magicManager.renderComponentOptions();
          magicManager.renderEssencesSelection();
          magicManager.renderMagicList();
        }
      });

      function setupAutoSave() {
        // Save whenever any input changes
        document.addEventListener("input", function (e) {
          // Debounce saving to avoid too many saves
          clearTimeout(window.saveTimeout);
          window.saveTimeout = setTimeout(() => {
            saveCharacterDataToStorage();
          }, 500);
        });

        // Save whenever checkboxes change
        document.addEventListener("change", function (e) {
          if (e.target.type === "checkbox") {
            clearTimeout(window.saveTimeout);
            window.saveTimeout = setTimeout(() => {
              saveCharacterDataToStorage();
            }, 500);
          }
        });
      }

      // Function to render all sections from JSON in the main layout
      function renderAllSectionsInLayout(skillComponent) {
        const dynamicContainer = document.getElementById(
          "dynamic-skill-sections"
        );
        const additionalContainer = document.getElementById(
          "additional-skill-sections"
        );

        if (!dynamicContainer || !additionalContainer) return;

        // Clear containers
        dynamicContainer.innerHTML = "";
        additionalContainer.innerHTML = "";

        // Define which sections go where (customize as needed)
        const mainSections = [0, 1, 2, 7]; // Conhecimento, Social, Cultura, Magia (indices in skillSectionsConfig)
        const additionalSections = [3, 4, 5, 6]; // Atletismo, Manufatura, Combate, Sobreviv√™ncia

        // Render main sections (Conhecimento, Social, Cultura, Magia)
        let mainHtml = '<div class="row">';
        mainSections.forEach((configIndex) => {
          if (skillSectionsConfig[configIndex]) {
            const config = skillSectionsConfig[configIndex];
            const attributeHtml = config.attribute
              ? `
              <div class="text-center mb-3">
                <div class="attribute-circle">
                  <div class="attribute-label">${config.attribute.label}</div>
                  <input
                    type="number"
                    class="form-control form-control-sm"
                    style="width: 50px; text-align: center"
                    value="0"
                    min="0"
                    max="3"
                    data-attribute="${config.attribute.dataAttribute}"
                    onchange="validateAttributeAndSkills('${config.attribute.dataAttribute}', '${config.sectionId}')"
                  />
                </div>
                <button class="btn btn-sm btn-outline-primary mt-1" onclick="rollAttribute('${config.attribute.dataAttribute}', '${config.attribute.label}')" title="Rolar ${config.attribute.label}">
                  üé≤ Rolar
                </button>
              </div>
            `
              : "";

            mainHtml += `
              <div class="col-md-3">
                <div class="skill-section" data-section="${config.sectionId}">
                  ${attributeHtml}
                  <div class="section-title" onclick="${
                    config.onClick
                  }" style="cursor: pointer">
                    ${config.label}
                  </div>
                  <div class="checkbox-list">
                    ${skillComponent.generateCheckboxes(
                      config.skills,
                      config.sectionId
                    )}
                  </div>
                </div>
              </div>
            `;
          }
        });
        mainHtml += "</div>";
        dynamicContainer.innerHTML = mainHtml;

        // Render additional sections (Atletismo, Manufatura, Combate, Sobreviv√™ncia)
        let additionalHtml = '<div class="row">';
        additionalSections.forEach((configIndex) => {
          if (skillSectionsConfig[configIndex]) {
            const config = skillSectionsConfig[configIndex];
            const attributeHtml = config.attribute
              ? `
              <div class="text-center mb-3">
                <div class="attribute-circle">
                  <div class="attribute-label">${config.attribute.label}</div>
                  <input
                    type="number"
                    class="form-control form-control-sm"
                    style="width: 50px; text-align: center"
                    value="0"
                    min="0"
                    max="3"
                    data-attribute="${config.attribute.dataAttribute}"
                    onchange="validateAttributeAndSkills('${config.attribute.dataAttribute}', '${config.sectionId}')"
                  />
                </div>
                <button class="btn btn-sm btn-outline-primary mt-1" onclick="rollAttribute('${config.attribute.dataAttribute}', '${config.attribute.label}')" title="Rolar ${config.attribute.label}">
                  üé≤ Rolar
                </button>
              </div>
            `
              : "";

            additionalHtml += `
              <div class="col-md-3">
                <div class="skill-section" data-section="${config.sectionId}">
                  ${attributeHtml}
                  <div class="section-title" onclick="${
                    config.onClick
                  }" style="cursor: pointer">
                    ${config.label}
                  </div>
                  <div class="checkbox-list">
                    ${skillComponent.generateCheckboxes(
                      config.skills,
                      config.sectionId
                    )}
                  </div>
                </div>
              </div>
            `;
          }
        });
        additionalHtml += "</div>";
        additionalContainer.innerHTML = additionalHtml;

        console.log(
          "All JSON sections rendered in main layout with attributes"
        );

        // Don't initialize skill availability here - wait for data to load first
      }

      // Validation function for attribute changes
      function validateAttributeAndSkills(attributeName, sectionId) {
        const attributeInput = document.querySelector(
          `input[data-attribute="${attributeName}"]`
        );
        if (!attributeInput) return;

        // Ensure attribute value is between 0 and 3
        let value = parseInt(attributeInput.value);
        if (isNaN(value) || value < 0) {
          value = 0;
          attributeInput.value = 0;
        } else if (value > 3) {
          value = 3;
          attributeInput.value = 3;
        }

        // Update skill availability based on attribute value
        updateSkillAvailability(sectionId, value);

        // Update point calculation
        calculateTotalPoints();
      }

      // Function to toggle skill levels (1, 2, 3)
      function toggleSkillLevel(checkbox, level) {
        const sectionId = checkbox.dataset.section;
        const skillName = checkbox.dataset.skill;

        if (!sectionId) return;

        // Find the corresponding attribute for this section
        const config = skillSectionsConfig.find(
          (c) => c.sectionId === sectionId
        );
        if (!config || !config.attribute) return;

        const attributeInput = document.querySelector(
          `input[data-attribute="${config.attribute.dataAttribute}"]`
        );
        if (!attributeInput) return;

        const attributeValue = parseInt(attributeInput.value) || 0;

        // Check if the level is allowed based on attribute value
        if (level > attributeValue) {
          checkbox.checked = false;
          alert(
            `Voc√™ precisa ter pelo menos ${level} pontos em ${config.attribute.label} para selecionar o n√≠vel ${level} de ${skillName}`
          );
          return false;
        }

        // Get all level checkboxes for this skill
        const skillContainer = checkbox.closest(".skill-levels");
        const levelCheckboxes = skillContainer.querySelectorAll(".skill-level");

        if (checkbox.checked) {
          // If checking a level, also check all lower levels
          levelCheckboxes.forEach((cb) => {
            const cbLevel = parseInt(cb.dataset.level);
            if (cbLevel <= level) {
              cb.checked = true;
            }
          });
        } else {
          // If unchecking a level, also uncheck all higher levels
          levelCheckboxes.forEach((cb) => {
            const cbLevel = parseInt(cb.dataset.level);
            if (cbLevel >= level) {
              cb.checked = false;
            }
          });
        }

        // Update point calculation after skill change
        calculateTotalPoints();
        return true;
      }

      // Function to update skill availability based on attribute value
      function updateSkillAvailability(sectionId, attributeValue) {
        const sectionElement = document.querySelector(
          `[data-section="${sectionId}"]`
        );
        if (!sectionElement) return;

        const skillContainers =
          sectionElement.querySelectorAll(".skill-levels");

        skillContainers.forEach((container) => {
          const levelCheckboxes = container.querySelectorAll(".skill-level");

          levelCheckboxes.forEach((checkbox) => {
            const level = parseInt(checkbox.dataset.level);

            if (level > attributeValue) {
              // Disable and uncheck levels higher than attribute value
              checkbox.disabled = true;
              checkbox.checked = false;
            } else if (attributeValue >= 1) {
              // Enable levels within attribute value (only if attribute is at least 1)
              checkbox.disabled = false;
            } else {
              // If attribute is 0, disable all levels
              checkbox.disabled = true;
              checkbox.checked = false;
            }
          });

          // Update visual state of the entire skill container
          console.log("attributeValue:", attributeValue);
          if (attributeValue === 0) {
            container.classList.add("disabled");
          } else {
            container.classList.remove("disabled");
          }
        });
      }

      // Function to calculate skill level cost
      function calculateSkillCost(level) {
        switch (level) {
          case 1:
            return 1;
          case 2:
            return 1 + 2;
          case 3:
            return 1 + 2 + 4;
          default:
            return 0;
        }
      }

      // Function to calculate total points
      function calculateTotalPoints() {
        let attributePoints = 0;
        let skillPoints = 0;

        // Calculate attribute points (1 point per level)
        document.querySelectorAll("input[data-attribute]").forEach((input) => {
          const value = parseInt(input.value) || 0;
          attributePoints += value;
        });

        // Calculate skill points (1/2/4 points for levels 1/2/3)
        // Exclude recursos section since it's now just text
        document.querySelectorAll(".skill-levels").forEach((skillContainer) => {
          const sectionId = skillContainer.dataset.section;

          // Skip recursos section
          if (sectionId === "recursos") return;

          const levelCheckboxes = skillContainer.querySelectorAll(
            ".skill-level:checked"
          );

          // Find the highest checked level for this skill
          let maxLevel = 0;
          levelCheckboxes.forEach((checkbox) => {
            const level = parseInt(checkbox.dataset.level);
            if (level > maxLevel) maxLevel = level;
          });

          skillPoints += calculateSkillCost(maxLevel);
        });

        // Get available points
        const availableAttributePoints =
          parseInt(
            document.getElementById("attribute-available").textContent
          ) || 5;
        const availableSkillPoints =
          parseInt(document.getElementById("skill-available").textContent) ||
          10;

        // Update the display
        document.getElementById("attribute-points").textContent =
          attributePoints;
        document.getElementById("skill-points").textContent = skillPoints;

        // Update used points display
        document.getElementById("attribute-used").textContent = attributePoints;
        document.getElementById("skill-used").textContent = skillPoints;

        // Apply warning colors if points are exceeded
        checkAndApplyWarningColors(
          attributePoints,
          skillPoints,
          availableAttributePoints,
          availableSkillPoints
        );

        return {
          attributes: attributePoints,
          skills: skillPoints,
        };
      }

      // Function to check and apply warning colors when points are exceeded
      function checkAndApplyWarningColors(
        usedAttributePoints,
        usedSkillPoints,
        availableAttributePoints,
        availableSkillPoints
      ) {
        // Check attribute points
        const attributeExceeded =
          usedAttributePoints > availableAttributePoints;
        const skillExceeded = usedSkillPoints > availableSkillPoints;

        // Update point category colors
        const attributeCategory = document
          .querySelector("#attribute-points")
          .closest(".point-category");
        const skillCategory = document
          .querySelector("#skill-points")
          .closest(".point-category");

        if (attributeExceeded) {
          attributeCategory.classList.add("points-exceeded");
        } else {
          attributeCategory.classList.remove("points-exceeded");
        }

        if (skillExceeded) {
          skillCategory.classList.add("points-exceeded");
        } else {
          skillCategory.classList.remove("points-exceeded");
        }

        // Apply colors to individual attribute inputs
        document.querySelectorAll("input[data-attribute]").forEach((input) => {
          if (attributeExceeded) {
            input.classList.add("attribute-exceeded");
          } else {
            input.classList.remove("attribute-exceeded");
          }
        });

        // Apply colors to individual skill containers
        document.querySelectorAll(".skill-levels").forEach((skillContainer) => {
          const sectionId = skillContainer.dataset.section;

          // Skip recursos section
          if (sectionId === "recursos") return;

          if (skillExceeded) {
            skillContainer.classList.add("skill-exceeded");
          } else {
            skillContainer.classList.remove("skill-exceeded");
          }
        });
      }

      // Magic System Classes and Functions

      // MagicComponentField class to represent different component field types
      class MagicComponentField {
        constructor(id, title, description, options = [], required = false) {
          this.id = id;
          this.title = title;
          this.description = description;
          this.options = options; // Array of {id, name, costModifier}
          this.required = required;
        }

        // Create MagicComponentField from JSON
        static fromJSON(data) {
          return new MagicComponentField(
            data.id,
            data.title,
            data.description,
            data.options || [],
            data.required || false
          );
        }

        // Convert to JSON for storage
        toJSON() {
          return {
            id: this.id,
            title: this.title,
            description: this.description,
            options: this.options,
            required: this.required,
          };
        }
      }

      // Magic class to represent individual spells
      class Magic {
        constructor(
          name,
          componentSelections = {},
          selectedEssences = [],
          baseCost = null
        ) {
          this.id = Date.now() + Math.random(); // Simple unique ID
          this.name = name;
          this.componentSelections = componentSelections; // Object with fieldId: optionId
          this.selectedEssences = selectedEssences; // Array of essence IDs
          this.baseCost = baseCost || this.calculateBaseCostFromEssences();
          this.createdAt = new Date();
        }

        // Calculate base cost from selected essences with hemisphere proximity modifiers
        calculateBaseCostFromEssences() {
          if (!this.selectedEssences || this.selectedEssences.length === 0) {
            return 1;
          }

          let totalCost = 0;

          // Calculate base cost from essences
          this.selectedEssences.forEach((essenceId) => {
            for (let hemisphere of essencesConfig) {
              const essence = hemisphere.essences.find(
                (e) => e.id === essenceId
              );
              if (essence) {
                totalCost += essence.cost;
                break;
              }
            }
          });

          // Apply hemisphere proximity modifiers
          const proximityResult = calculateHemisphereProximityModifier(
            this.selectedEssences
          );
          totalCost *= proximityResult.modifier;

          return Math.max(Math.ceil(totalCost), 1); // Minimum cost of 1
        }

        // Calculate final cost based on component selections
        getFinalCost(componentFields) {
          let totalModifier = 1.0;

          // Apply modifiers from each field selection
          Object.keys(this.componentSelections).forEach((fieldId) => {
            const optionId = this.componentSelections[fieldId];
            if (!optionId) return;

            const field = componentFields.find((f) => f.id === fieldId);
            if (!field) return;

            const option = field.options.find((o) => o.id === optionId);
            if (option && option.costModifier) {
              totalModifier *= option.costModifier;
            }
          });

          return Math.ceil(this.baseCost * totalModifier);
        }

        // Get selected essences as display string
        getEssencesDisplay() {
          if (!this.selectedEssences || this.selectedEssences.length === 0) {
            return "Nenhuma ess√™ncia";
          }

          const essenceNames = [];
          this.selectedEssences.forEach((essenceId) => {
            for (let hemisphere of essencesConfig) {
              const essence = hemisphere.essences.find(
                (e) => e.id === essenceId
              );
              if (essence) {
                essenceNames.push(essence.name);
                break;
              }
            }
          });

          return essenceNames.join(", ");
        }

        // Get hemisphere proximity modifier details
        getHemisphereProximityDetails() {
          if (!this.selectedEssences || this.selectedEssences.length <= 1) {
            return { modifier: 1.0, description: "" };
          }

          let rawCost = 0;

          // Calculate raw cost
          this.selectedEssences.forEach((essenceId) => {
            for (let hemisphere of essencesConfig) {
              const essence = hemisphere.essences.find(
                (e) => e.id === essenceId
              );
              if (essence) {
                rawCost += essence.cost;
                break;
              }
            }
          });

          const proximityResult = calculateHemisphereProximityModifier(
            this.selectedEssences
          );

          // Format description from details
          const description = proximityResult.details
            .map(
              (detail) =>
                `${detail.pair}: ${detail.relationship} (√ó${detail.modifier})`
            )
            .join(", ");

          return {
            modifier: proximityResult.modifier,
            description: description,
            rawCost: rawCost,
            finalCost: Math.ceil(rawCost * proximityResult.modifier),
          };
        }

        // Get component selections as display string
        getComponentSelectionsDisplay(componentFields) {
          const selections = [];

          Object.keys(this.componentSelections).forEach((fieldId) => {
            const optionId = this.componentSelections[fieldId];
            if (!optionId) return;

            const field = componentFields.find((f) => f.id === fieldId);
            if (!field) return;

            const option = field.options.find((o) => o.id === optionId);
            if (option) {
              selections.push(`${field.title}: ${option.name}`);
            }
          });

          return selections.length > 0 ? selections.join(" | ") : "Nenhum";
        }

        // Convert to JSON for storage
        toJSON() {
          return {
            id: this.id,
            name: this.name,
            componentSelections: this.componentSelections,
            selectedEssences: this.selectedEssences,
            baseCost: this.baseCost,
            createdAt: this.createdAt.toISOString(),
          };
        }

        // Create Magic from JSON data
        static fromJSON(data) {
          const magic = new Magic(
            data.name,
            data.componentSelections || {},
            data.selectedEssences || [],
            data.baseCost || 1
          );
          magic.id = data.id;
          magic.createdAt = new Date(data.createdAt);
          return magic;
        }
      }

      // Essences configuration for calculating base cost
      const essencesConfig = [
        {
          id: "energetico",
          name: "Energ√©tico",
          essences: [
            { id: "ignis", name: "Ignis", cost: 1 },
            { id: "fax", name: "Fax", cost: 2 },
            { id: "potentia", name: "Potentia", cost: 2 },
            { id: "kinetica", name: "Kinetica", cost: 2 },
            { id: "anarchia", name: "Anarchia", cost: 3 },
          ],
        },
        {
          id: "material",
          name: "Material",
          essences: [
            { id: "tatio", name: "Tatio", cost: 1 },
            { id: "aqua", name: "Aqua", cost: 2 },
            { id: "terra", name: "Terra", cost: 2 },
            { id: "era", name: "Era", cost: 2 },
            { id: "metallum", name: "Metallum", cost: 4 },
          ],
        },
        {
          id: "ilusorio",
          name: "Ilus√≥rio",
          essences: [
            { id: "ambiens", name: "Ambiens", cost: 1 },
            { id: "ego", name: "Ego", cost: 2 },
            { id: "suego", name: "Suego", cost: 5 },
            { id: "sensus", name: "Sensus", cost: 1 },
            { id: "realitas", name: "Realitas", cost: 10 },
          ],
        },
        {
          id: "conjurador",
          name: "Conjurador",
          essences: [
            { id: "for", name: "For", cost: 1 },
            { id: "dyn", name: "Dyn", cost: 2 },
            { id: "creatio", name: "Creatio", cost: 2 },
            { id: "clavis", name: "Clavis", cost: 1 },
            { id: "influentia", name: "Influentia", cost: 7 },
          ],
        },
        {
          id: "vida",
          name: "Vida",
          essences: [
            { id: "vita", name: "Vita", cost: 1 },
            { id: "roratio", name: "Roratio", cost: 2 },
            { id: "puri", name: "Puri", cost: 2 },
            { id: "bene", name: "Bene", cost: 5 },
            { id: "renatio", name: "Renatio", cost: 3 },
          ],
        },
        {
          id: "morte",
          name: "Morte",
          essences: [
            { id: "pest", name: "Pest", cost: 4 },
            { id: "infirmi", name: "Infirmi", cost: 2 },
            { id: "corruptio", name: "Corruptio", cost: 4 },
            { id: "maledictio", name: "Maledictio", cost: 2 },
            { id: "necro", name: "Necro", cost: 5 },
          ],
        },
      ];

      // Hemisphere proximity configuration for calculating modifiers
      const hemisphereProximity = {
        energetico: {
          close: ["morte", "ilusorio"],
        },
        material: {
          close: ["conjurdor", "vida"],
        },
        ilusorio: {
          close: ["morte", "energetico"],
        },
        conjurador: {
          close: ["material", "vida"],
        },
        vida: {
          close: ["material", "conjurador"],
        },
        morte: {
          close: ["ilusorio", "energetico"],
        },
      };

      // Helper function to calculate hemisphere proximity modifier
      function calculateHemisphereProximityModifier(selectedEssences) {
        if (!selectedEssences || selectedEssences.length === 0) {
          return { modifier: 1.0, details: [] };
        }

        const selectedHemispheres = new Set();

        // Collect hemispheres from selected essences
        selectedEssences.forEach((essenceId) => {
          for (let hemisphere of essencesConfig) {
            const essence = hemisphere.essences.find((e) => e.id === essenceId);
            if (essence) {
              selectedHemispheres.add(hemisphere.id);
              break;
            }
          }
        });

        if (selectedHemispheres.size <= 1) {
          return { modifier: 1.0, details: [] };
        }

        const hemisphereArray = Array.from(selectedHemispheres);
        let proximityModifier = 1.0;
        const proximityDetails = [];

        // Check proximity between consecutive hemispheres only
        for (let i = 1; i < hemisphereArray.length; i++) {
          const hemisphere1 = hemisphereArray[i - 1];
          const hemisphere2 = hemisphereArray[i];

          const proximity1 = hemisphereProximity[hemisphere1];
          let pairModifier = 1.2; // Default: far modifier
          let relationship = "distante";

          if (proximity1) {
            if (proximity1.close && proximity1.close.includes(hemisphere2)) {
              pairModifier = 1.1; // Close modifier
              relationship = "pr√≥ximo";
            }
          }

          proximityModifier *= pairModifier;
          proximityDetails.push({
            pair: `${hemisphere1}+${hemisphere2}`,
            relationship,
            modifier: pairModifier,
          });
        }

        return {
          modifier: proximityModifier,
          details: proximityDetails,
        };
      }

      // Magic Component class to handle magic list management and rendering
      class MagicManager {
        constructor() {
          this.magics = [];
          this.componentFields = [];
          this.essencesConfig = essencesConfig;
          this.initializeDefaultComponentFields();
          this.loadMagicsFromStorage();
        }

        // Initialize default component fields from JSON configuration
        initializeDefaultComponentFields() {
          const defaultComponentFieldsConfig = [
            {
              id: "duration",
              title: "Dura√ß√£o",
              description: "Tempo de dura√ß√£o do efeito",
              required: true,
              options: [
                { id: "instant", name: "Instant√¢nea", costModifier: 1.0 },
                { id: "short", name: "Curta", costModifier: 2.0 },
                { id: "medium", name: "M√©dia", costModifier: 2.2 },
                { id: "long", name: "Longa", costModifier: 2.4 },
                { id: "permanent", name: "Permanente", costModifier: 4.0 },
                { id: "6_hours", name: "At√© 6 horas", costModifier: 4.5 },
                { id: "1_day", name: "At√© 1 dia", costModifier: 6.0 },
                { id: "7_days", name: "At√© 7 dias", costModifier: 7.0 },
                { id: "14_days", name: "At√© 14 dias", costModifier: 9.0 },
                { id: "1_month", name: "At√© 1 m√™s", costModifier: 10.0 },
              ],
            },
            {
              id: "target",
              title: "Alvo",
              description: "Alvos da magia",
              required: false,
              options: [
                { id: "1_target", name: "1 alvo", costModifier: 1.0 },
                { id: "3_targets", name: "At√© 3 alvos", costModifier: 1.3 },
                { id: "6_targets", name: "At√© 6 alvos", costModifier: 1.6 },
                { id: "9_targets", name: "At√© 9 alvos", costModifier: 1.9 },
                { id: "12_targets", name: "At√© 12 alvos", costModifier: 2.2 },
                { id: "15_targets", name: "At√© 15 alvos", costModifier: 2.5 },
                { id: "18_targets", name: "At√© 18 alvos", costModifier: 2.8 },
                { id: "24_targets", name: "At√© 24 alvos", costModifier: 3.1 },
                { id: "30_targets", name: "At√© 30 alvos", costModifier: 4.0 },
              ],
            },
            {
              id: "distance",
              title: "Dist√¢ncia",
              description: "Dist√¢ncia da magia",
              required: false,
              options: [
                { id: "self_touch", name: "Self/Toque", costModifier: 1.0 },
                { id: "5_meters", name: "At√© 5 metros", costModifier: 1.1 },
                { id: "10_meters", name: "At√© 10 metros", costModifier: 1.2 },
                { id: "30_meters", name: "At√© 30 metros", costModifier: 1.5 },
                { id: "50_meters", name: "At√© 50 metros", costModifier: 2.0 },
                { id: "100_meters", name: "At√© 100 metros", costModifier: 2.5 },
                { id: "500_meters", name: "At√© 500 metros", costModifier: 5.0 },
                { id: "10_km", name: "At√© 10 Km", costModifier: 10.0 },
              ],
            },
            {
              id: "area",
              title: "√Årea",
              description: "√Årea de efeito da magia",
              required: false,
              options: [
                { id: "point", name: "Pontual", costModifier: 1.0 },
                {
                  id: "5_m2",
                  name: "5 m¬≤",
                  costModifier: 1.3,
                  description: "Tenda",
                },
                {
                  id: "15_m2",
                  name: "15 m¬≤",
                  costModifier: 1.4,
                  description: "Banheiro",
                },
                {
                  id: "30_m2",
                  name: "30 m¬≤",
                  costModifier: 1.5,
                  description: "Quarto",
                },
                {
                  id: "50_m2",
                  name: "50 m¬≤",
                  costModifier: 1.6,
                  description: "Sal√£o",
                },
                {
                  id: "100_m2",
                  name: "100 m¬≤",
                  costModifier: 1.7,
                  description: "Casebre",
                },
                {
                  id: "250_m2",
                  name: "250 m¬≤",
                  costModifier: 1.8,
                  description: "Casa",
                },
                {
                  id: "500_m2",
                  name: "500 m¬≤",
                  costModifier: 1.9,
                  description: "Casar√£o",
                },
                {
                  id: "1000_m2",
                  name: "1000 m¬≤",
                  costModifier: 2.0,
                  description: "Mans√£o",
                },
                {
                  id: "5000_m2",
                  name: "5000 m¬≤",
                  costModifier: 2.2,
                  description: "Catedral",
                },
                {
                  id: "10000_m2",
                  name: "10000 m¬≤",
                  costModifier: 2.4,
                  description: "Castelo",
                },
                {
                  id: "25000_m2",
                  name: "25000 m¬≤",
                  costModifier: 2.6,
                  description: "Pal√°cio",
                },
                {
                  id: "50000_m2",
                  name: "50000 m¬≤",
                  costModifier: 2.8,
                  description: "Distrito",
                },
                {
                  id: "75000_m2",
                  name: "75000 m¬≤",
                  costModifier: 3.0,
                  description: "Vilarejo",
                },
                {
                  id: "100000_m2",
                  name: "100000 m¬≤",
                  costModifier: 4.0,
                  description: "Cidade",
                },
              ],
            },
            {
              id: "areaType",
              title: "Tipo de √Årea",
              description: "Tipo de √°rea da magia",
              required: false,
              options: [
                { id: "grupal", name: "Grupal", costModifier: 1.0 },
                { id: "seletivo", name: "Seletivo", costModifier: 4.0 },
              ],
            },
          ];

          this.componentFields = defaultComponentFieldsConfig.map((config) =>
            MagicComponentField.fromJSON(config)
          );
        }

        // Add a new magic to the list
        addMagic(name, componentSelections, baseCost = 1) {
          if (!name || !name.trim()) {
            alert("Por favor, digite um nome para a magia.");
            return false;
          }

          // Check if any required fields are missing
          const missingRequired = this.componentFields
            .filter((field) => field.required && !componentSelections[field.id])
            .map((field) => field.title);

          if (missingRequired.length > 0) {
            alert(`Por favor, selecione: ${missingRequired.join(", ")}`);
            return false;
          }

          // Check if magic with same name already exists
          const existingMagic = this.magics.find(
            (magic) => magic.name.toLowerCase() === name.trim().toLowerCase()
          );

          if (existingMagic) {
            alert(`A magia "${name.trim()}" j√° existe na lista.`);
            return false;
          }

          const magic = new Magic(name.trim(), componentSelections, baseCost);
          this.magics.push(magic);
          this.saveMagicsToStorage();
          this.renderMagicList();
          return true;
        }

        // Add a new magic with essences to the list
        addMagicWithEssences(
          name,
          componentSelections,
          selectedEssences,
          baseCost = 1
        ) {
          if (!name || !name.trim()) {
            alert("Por favor, digite um nome para a magia.");
            return false;
          }

          // Check if any required fields are missing
          const missingRequired = this.componentFields
            .filter((field) => field.required && !componentSelections[field.id])
            .map((field) => field.title);

          if (missingRequired.length > 0) {
            alert(`Por favor, selecione: ${missingRequired.join(", ")}`);
            return false;
          }

          // Check if magic with same name already exists
          const existingMagic = this.magics.find(
            (magic) => magic.name.toLowerCase() === name.trim().toLowerCase()
          );

          if (existingMagic) {
            alert(`A magia "${name.trim()}" j√° existe na lista.`);
            return false;
          }

          const magic = new Magic(
            name.trim(),
            componentSelections,
            selectedEssences,
            baseCost
          );
          this.magics.push(magic);
          this.saveMagicsToStorage();
          this.renderMagicList();
          return true;
        }

        // Remove a magic from the list
        removeMagic(magicId) {
          const index = this.magics.findIndex((magic) => magic.id === magicId);
          if (index !== -1) {
            const magic = this.magics[index];
            if (
              confirm(`Tem certeza que deseja remover a magia "${magic.name}"?`)
            ) {
              this.magics.splice(index, 1);
              this.saveMagicsToStorage();
              this.renderMagicList();
              return true;
            }
          }
          return false;
        }

        // Render component field selects
        renderComponentOptions() {
          const container = document.getElementById(
            "magic-components-container"
          );
          if (!container) return;

          // Clear existing content
          container.innerHTML = "";

          // Add component field selects
          this.componentFields.forEach((field) => {
            const fieldDiv = document.createElement("div");
            fieldDiv.className = "mb-3";

            const selectId = `magic-field-${field.id}`;
            const requiredLabel = field.required ? " *" : "";

            fieldDiv.innerHTML = `
              <label for="${selectId}" class="form-label">
                <strong>${field.title}${requiredLabel}</strong>
              </label>
              <select class="form-control magic-component-select" 
                      id="${selectId}" 
                      data-field-id="${field.id}"
                      title="${field.description}">
                <option value="">-- Selecione ${field.title} --</option>
                ${field.options
                  .map(
                    (option) =>
                      `<option value="${option.id}" title="Custo: √ó${option.costModifier}">
                    ${option.name} (√ó${option.costModifier})
                   </option>`
                  )
                  .join("")}
              </select>
              ${
                field.description
                  ? `<small class="form-text text-muted">${field.description}</small>`
                  : ""
              }
            `;

            container.appendChild(fieldDiv);
          });
        }

        // Render essences selection interface
        renderEssencesSelection() {
          const container = document.getElementById("magic-essences-container");
          if (!container) return;

          container.innerHTML = "";

          // Create header
          const headerDiv = document.createElement("div");
          headerDiv.className = "mb-3";
          headerDiv.innerHTML = `
            <h6 class="mb-2">üîÆ Sele√ß√£o de Ess√™ncias</h6>
            <small class="text-muted">Selecione as ess√™ncias para calcular o custo base da magia.</small>
            <div class="mt-2">
              <span id="calculated-base-cost" class="badge bg-info">Custo Base: 1</span>
            </div>
          `;
          container.appendChild(headerDiv);

          // Create essences by hemisphere
          this.essencesConfig.forEach((hemisphere) => {
            const hemisphereDiv = document.createElement("div");
            hemisphereDiv.className = "mb-3 p-2 border rounded";
            hemisphereDiv.innerHTML = `
              <h6 class="mb-2 text-primary">${hemisphere.name}</h6>
              <div class="essence-checkboxes" data-hemisphere="${
                hemisphere.id
              }">
                ${hemisphere.essences
                  .map(
                    (essence) => `
                  <div class="form-check form-check-inline">
                    <input class="form-check-input essence-checkbox" 
                           type="checkbox" 
                           id="essence-${essence.id}" 
                           value="${essence.id}"
                           onchange="updateBaseCostFromEssences()">
                    <label class="form-check-label" for="essence-${essence.id}">
                      ${essence.name} (${essence.cost})
                    </label>
                  </div>
                `
                  )
                  .join("")}
              </div>
            `;
            container.appendChild(hemisphereDiv);
          });
        }

        // Render the complete magic list
        renderMagicList() {
          const container = document.getElementById("magic-list-container");
          const countElement = document.getElementById("magic-count");
          const noMagicMessage = document.getElementById("no-magic-message");

          if (!container) return;

          // Update count
          if (countElement) {
            countElement.textContent = this.magics.length;
          }

          // Clear container
          container.innerHTML = "";

          if (this.magics.length === 0) {
            if (noMagicMessage) {
              container.appendChild(noMagicMessage);
            } else {
              container.innerHTML =
                '<p class="text-muted text-center">Nenhuma magia adicionada ainda.</p>';
            }
            return;
          }

          // Hide no magic message
          if (noMagicMessage) {
            noMagicMessage.style.display = "none";
          }

          // Render each magic
          this.magics.forEach((magic) => {
            const magicElement = this.renderMagicItem(magic);
            container.appendChild(magicElement);
          });

          // Update total cost display
          this.updateTotalCostDisplay();
        }

        // Render individual magic item
        renderMagicItem(magic) {
          const magicDiv = document.createElement("div");
          magicDiv.className = "magic-item";
          magicDiv.dataset.magicId = magic.id;

          const finalCost = magic.getFinalCost(this.componentFields);
          const componentDisplay = magic.getComponentSelectionsDisplay(
            this.componentFields
          );
          const essencesDisplay = magic.getEssencesDisplay();
          const proximityDetails = magic.getHemisphereProximityDetails();

          let proximityInfo = "";
          if (proximityDetails.modifier > 1.0) {
            proximityInfo = `
              <div class="magic-proximity">
                <small class="text-info">Modificador Hemisf√©rios: √ó${proximityDetails.modifier.toFixed(
                  2
                )}</small>
              </div>
            `;
          }

          magicDiv.innerHTML = `
            <button class="magic-remove-btn" onclick="magicManager.removeMagic(${
              magic.id
            })" title="Remover magia">
              ‚úï
            </button>
            <div class="magic-name">${this.escapeHtml(magic.name)}</div>
            <div class="magic-details">
              <div class="magic-essences">
                <small class="text-muted">Ess√™ncias:</small> ${this.escapeHtml(
                  essencesDisplay
                )}
              </div>
              ${proximityInfo}
              <div class="magic-components">
                <small class="text-muted">Componentes:</small> ${this.escapeHtml(
                  componentDisplay
                )}
              </div>
              <div class="magic-cost-breakdown">
                <span class="magic-base-cost">Base: ${magic.baseCost}</span>
                <span class="magic-final-cost">Final: ${finalCost}</span>
              </div>
            </div>
          `;

          return magicDiv;
        }

        // Update total cost display
        updateTotalCostDisplay() {
          const totalCost = this.magics.reduce(
            (sum, magic) => sum + magic.getFinalCost(this.componentFields),
            0
          );

          const totalCostElement = document.getElementById("magic-total-cost");
          if (totalCostElement) {
            totalCostElement.textContent = totalCost;
          }
        }

        // Utility function to escape HTML
        escapeHtml(text) {
          const div = document.createElement("div");
          div.textContent = text;
          return div.innerHTML;
        }

        // Save magics to localStorage
        saveMagicsToStorage() {
          try {
            const data = this.magics.map((magic) => magic.toJSON());
            localStorage.setItem("fac_character_magics", JSON.stringify(data));
            console.log("Magics saved to localStorage");
          } catch (error) {
            console.error("Error saving magics to localStorage:", error);
          }
        }

        // Load magics from localStorage
        loadMagicsFromStorage() {
          try {
            const data = localStorage.getItem("fac_character_magics");
            if (data) {
              const magicsData = JSON.parse(data);
              this.magics = magicsData.map((magicData) =>
                Magic.fromJSON(magicData)
              );
              console.log("Magics loaded from localStorage");
            }
          } catch (error) {
            console.error("Error loading magics from localStorage:", error);
            this.magics = [];
          }
        }

        // Clear all magics
        clearAllMagics() {
          if (this.magics.length === 0) {
            alert("N√£o h√° magias para remover.");
            return;
          }

          if (
            confirm(
              "Tem certeza que deseja remover todas as magias? Esta a√ß√£o n√£o pode ser desfeita."
            )
          ) {
            this.magics = [];
            this.saveMagicsToStorage();
            this.renderMagicList();
          }
        }

        // Get magics data for character save
        getMagicsData() {
          return this.magics.map((magic) => magic.toJSON());
        }

        // Load magics data from character load
        loadMagicsData(magicsData) {
          if (Array.isArray(magicsData)) {
            this.magics = magicsData.map((magicData) =>
              Magic.fromJSON(magicData)
            );
            this.renderMagicList();
          }
        }
      }

      // Global magic manager instance
      let magicManager;

      // Function to update base cost based on selected essences with hemisphere proximity modifiers
      function updateBaseCostFromEssences() {
        const checkedEssences = document.querySelectorAll(
          ".essence-checkbox:checked"
        );
        let totalCost = 0;

        // Calculate base cost from selected essences
        const selectedEssenceIds = Array.from(checkedEssences).map(
          (cb) => cb.value
        );

        selectedEssenceIds.forEach((essenceId) => {
          for (let hemisphere of essencesConfig) {
            const essence = hemisphere.essences.find((e) => e.id === essenceId);
            if (essence) {
              totalCost += essence.cost;
              break;
            }
          }
        });

        // Apply hemisphere proximity modifiers
        const proximityResult =
          calculateHemisphereProximityModifier(selectedEssenceIds);
        totalCost *= proximityResult.modifier;

        // Update the display and input
        const baseCost = Math.max(Math.ceil(totalCost), 1);
        const costInput = document.getElementById("magic-cost-input");
        const costDisplay = document.getElementById("calculated-base-cost");

        if (costInput) {
          costInput.value = baseCost;
        }
        console.log("-----proximityResult", proximityResult);
        if (costDisplay) {
          // Show proximity modifier info if applicable
          let displayText = `Custo Base: ${baseCost}`;
          if (proximityResult.details.length > 0) {
            displayText += ` (√ó${proximityResult.modifier.toFixed(
              2
            )} por hemisf√©rios diferentes)`;
          }
          costDisplay.textContent = displayText;
        }
      }

      // Functions for UI interaction
      function addMagicSpell() {
        const nameInput = document.getElementById("magic-name-input");
        const costInput = document.getElementById("magic-cost-input");
        const componentSelects = document.querySelectorAll(
          ".magic-component-select"
        );
        const essenceCheckboxes = document.querySelectorAll(
          ".essence-checkbox:checked"
        );

        if (!nameInput || !costInput) {
          alert("Erro: Elementos de entrada n√£o encontrados.");
          return;
        }

        const name = nameInput.value;
        const baseCost = parseInt(costInput.value) || 1;

        // Collect selected essences
        const selectedEssences = Array.from(essenceCheckboxes).map(
          (cb) => cb.value
        );

        // Collect component selections
        const componentSelections = {};
        componentSelects.forEach((select) => {
          const fieldId = select.dataset.fieldId;
          const value = select.value;
          if (value) {
            componentSelections[fieldId] = value;
          }
        });

        if (
          magicManager.addMagicWithEssences(
            name,
            componentSelections,
            selectedEssences,
            baseCost
          )
        ) {
          // Clear inputs on success
          nameInput.value = "";
          costInput.value = "1";

          // Reset all component selects
          componentSelects.forEach((select) => (select.value = ""));

          // Reset all essence checkboxes
          essenceCheckboxes.forEach((checkbox) => (checkbox.checked = false));

          // Update base cost display
          updateBaseCostFromEssences();

          // Trigger auto-save
          clearTimeout(window.saveTimeout);
          window.saveTimeout = setTimeout(() => {
            saveCharacterDataToStorage();
          }, 500);
        }
      }

      // Handle keyboard input for magic creation
      function handleMagicInputKeypress(event) {
        if (event.key === "Enter") {
          event.preventDefault();
          addMagicSpell();
        }
      }

      // Function to clear all magics (can be called from UI)
      function clearAllMagics() {
        if (magicManager) {
          magicManager.clearAllMagics();

          // Trigger auto-save
          clearTimeout(window.saveTimeout);
          window.saveTimeout = setTimeout(() => {
            saveCharacterDataToStorage();
          }, 500);
        }
      }
      function toggleAllSectionsPreview() {
        const previewDiv = document.getElementById("all-sections-preview");
        if (previewDiv) {
          if (previewDiv.style.display === "none") {
            previewDiv.style.display = "block";
          } else {
            previewDiv.style.display = "none";
          }
        }
      }
    </script>
  </body>
</html>
