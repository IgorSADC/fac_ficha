<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ficha de Personagem - Sistema FAC</title>
    <!-- Bootstrap 5 CSS -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <style>
      .hexagon-container {
        display: flex;
        justify-content: center;
        margin: 10px 0;
      }
      .hexagon {
        width: 40px;
        height: 35px;
        border: 2px solid #333;
        margin: 2px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        clip-path: polygon(
          25% 0%,
          75% 0%,
          100% 50%,
          75% 100%,
          25% 100%,
          0% 50%
        );
        background: white;
      }
      .attribute-circle {
        width: 80px;
        height: 80px;
        border: 3px solid #333;
        border-radius: 50%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        background: white;
        margin: 10px auto;
      }
      .attribute-label {
        font-size: 12px;
        font-weight: bold;
      }
      .attribute-value {
        font-size: 20px;
        font-weight: bold;
      }
      .skill-section {
        border: 2px solid #333;
        padding: 10px;
        margin: 5px 0;
        background: #f8f9fa;
      }
      .section-title {
        background: #333;
        color: white;
        padding: 5px 10px;
        margin: -10px -10px 10px -10px;
        font-weight: bold;
        text-align: center;
      }
      .checkbox-list {
        columns: 1;
        column-gap: 20px;
      }
      .form-check {
        margin-bottom: 8px;
        break-inside: avoid;
      }
      .skill-levels {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
        padding: 4px;
        border: 1px solid #e0e0e0;
        border-radius: 4px;
        background: white;
      }
      .skill-name {
        font-weight: 500;
        min-width: 120px;
        margin-bottom: 0;
      }
      .skill-level-boxes {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .skill-level {
        margin: 0 2px;
        width: 16px;
        height: 16px;
      }
      .level-label {
        font-size: 11px;
        font-weight: bold;
        margin: 0 4px 0 0;
        min-width: 8px;
        text-align: center;
      }
      .skill-levels.disabled {
        opacity: 0.4;
        background: #f8f9fa;
      }
      .skill-levels.disabled .skill-level {
        cursor: not-allowed;
      }
      .skill-level:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .skill-level:disabled + .level-label {
        color: #6c757d;
        opacity: 0.5;
      }
      .hp-mana-section {
        border: 2px solid #333;
        padding: 10px;
        text-align: center;
      }
      .large-input {
        font-size: 18px;
        text-align: center;
        font-weight: bold;
      }
      .attack-table th,
      .attack-table td {
        text-align: center;
        vertical-align: middle;
      }
      .resources-section,
      .inventory-section {
        border: 2px solid #333;
        background: white;
        min-height: 200px;
      }
      .section-header {
        background: #333;
        color: white;
        padding: 10px;
        text-align: center;
        font-weight: bold;
        margin: 0;
      }
      .point-category {
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 5px;
        margin: 2px;
        background: #f8f9fa;
      }
      .point-category.total-points {
        background: #fff3cd;
        border-color: #ffeaa7;
      }
      .point-label {
        font-size: 12px;
        font-weight: bold;
        color: #666;
        margin-bottom: 5px;
      }
      .point-value {
        font-size: 24px;
        font-weight: bold;
        color: #333;
        margin-bottom: 5px;
      }
      .total-points .point-value {
        color: #856404;
      }
      .point-cost {
        font-size: 10px;
        color: #999;
      }
      .points-exceeded {
        background-color: #f8d7da !important;
        border-color: #dc3545 !important;
        color: #721c24 !important;
      }
      .attribute-exceeded {
        background-color: #f8d7da !important;
        border-color: #dc3545 !important;
      }
      .skill-exceeded {
        background-color: #fff3cd !important;
        border-color: #ffc107 !important;
      }

      /* Magic Creation Section Styles */
      .magic-item {
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 10px;
        margin-bottom: 8px;
        background: #fff;
        transition: all 0.2s ease;
      }

      .magic-item:hover {
        border-color: #007bff;
        box-shadow: 0 2px 4px rgba(0, 123, 255, 0.1);
      }

      .magic-name {
        font-weight: bold;
        color: #333;
        font-size: 14px;
        margin-bottom: 4px;
      }

      .magic-component {
        font-size: 12px;
        color: #666;
        background: #f8f9fa;
        padding: 2px 6px;
        border-radius: 4px;
        display: inline-block;
        margin-right: 8px;
      }

      .magic-cost {
        font-size: 12px;
        color: #007bff;
        font-weight: bold;
      }

      .magic-details {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 4px;
      }

      .magic-remove-btn {
        float: right;
        background: none;
        border: none;
        color: #dc3545;
        font-size: 16px;
        cursor: pointer;
        padding: 0;
        line-height: 1;
      }

      .magic-remove-btn:hover {
        color: #c82333;
      }

      .magic-roll-btn {
        margin-left: 10px;
        font-size: 0.75rem;
        padding: 2px 6px;
        border-radius: 4px;
      }

      .magic-roll-btn:hover {
        background-color: #007bff;
        border-color: #007bff;
        color: white;
      }

      .magic-cost-breakdown {
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 8px;
      }

      #magic-list-container {
        background: #f8f9fa;
        flex: 1;
        overflow-y: auto;
      }

      /* Ensure both magic columns have equal height */
      .magic-creation-row {
        display: flex;
      }

      .magic-creation-row .col-md-6 {
        display: flex;
        flex-direction: column;
      }

      .magic-creation-form,
      .magic-list-section {
        flex: 1;
        display: flex;
        flex-direction: column;
      }

      #magic-list-container {
        background: #f8f9fa;
        flex: 1;
        overflow-y: auto;
      }

      #magic-list-container:empty::before {
        content: "Nenhuma magia adicionada ainda.";
        color: #6c757d;
        font-style: italic;
        display: block;
        text-align: center;
        padding: 20px;
      }

      /* Magic Components Selection Styles */
      #magic-components-container {
        background: #f8f9fa;
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 15px;
      }

      .magic-component-select {
        margin-bottom: 10px;
      }

      .form-label {
        font-weight: 600;
        margin-bottom: 5px;
      }

      .form-text {
        font-size: 12px;
        margin-top: 3px;
      }

      /* Essences Selection Styles */
      .essence-checkboxes {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
      }

      .essence-quantity-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        min-width: 120px;
        margin-bottom: 8px;
      }

      .essence-label {
        font-size: 0.875rem;
        text-align: center;
        margin-bottom: 4px;
        cursor: default;
      }

      .essence-quantity {
        width: 60px;
        height: 32px;
        text-align: center;
        font-size: 0.875rem;
        border: 1px solid #ced4da;
        border-radius: 4px;
      }

      .essence-quantity:focus {
        border-color: #007bff;
        box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
      }

      .essence-checkboxes .form-check {
        margin-bottom: 5px;
      }

      /* Essence Info Popup Styles */
      .essence-info-btn {
        background: none;
        border: none;
        color: #007bff;
        font-size: 10px;
        padding: 0;
        margin-left: 2px;
        vertical-align: super;
        cursor: pointer;
        transition: all 0.2s ease;
        line-height: 1;
        font-weight: bold;
      }

      .essence-info-btn:hover {
        color: #0056b3;
        text-decoration: underline;
      }

      .essence-info-popup {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        border: 2px solid #007bff;
        border-radius: 8px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        z-index: 1000;
        max-width: 400px;
        min-width: 300px;
        padding: 20px;
        display: none;
      }

      .essence-info-popup.show {
        display: block;
        animation: fadeIn 0.3s ease;
      }

      .essence-info-popup-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 1px solid #e0e0e0;
      }

      .essence-info-popup-title {
        font-size: 18px;
        font-weight: bold;
        color: #333;
        margin: 0;
      }

      .essence-info-popup-close {
        background: none;
        border: none;
        font-size: 20px;
        color: #999;
        cursor: pointer;
        padding: 0;
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 4px;
      }

      .essence-info-popup-close:hover {
        background-color: #f0f0f0;
        color: #333;
      }

      .essence-info-popup-content {
        color: #555;
        line-height: 1.5;
        font-size: 14px;
      }

      .essence-info-popup-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 999;
        display: none;
      }

      .essence-info-popup-overlay.show {
        display: block;
        animation: fadeIn 0.3s ease;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      .magic-essences {
        font-size: 12px;
        color: #6c757d;
        margin-bottom: 5px;
      }

      .magic-components {
        font-size: 12px;
        color: #6c757d;
        margin-bottom: 5px;
      }

      .magic-cost-breakdown {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .magic-base-cost {
        font-size: 12px;
        color: #28a745;
      }

      .magic-final-cost {
        font-weight: bold;
        color: #007bff;
      }

      .magic-proximity {
        font-size: 11px;
        margin-bottom: 3px;
      }

      .magic-proximity small {
        background-color: #e3f2fd;
        padding: 2px 6px;
        border-radius: 3px;
        border: 1px solid #90caf9;
      }

      .form-check-label strong {
        color: #495057;
      }
    </style>
  </head>
  <body class="bg-light">
    <div class="container-fluid py-3">
      <!-- Header Section - Character Name and Description -->
      <div class="row mb-3">
        <div class="col-md-4">
          <div class="card">
            <div class="card-header bg-dark text-white text-center">
              <strong>Nome do Personagem</strong>
            </div>
            <div class="card-body">
              <input
                type="text"
                class="form-control form-control-lg text-center"
                placeholder="Nome do personagem"
              />
            </div>
          </div>
        </div>
        <div class="col-md-8">
          <div class="card">
            <div class="card-header bg-dark text-white text-center">
              <strong>Descrição:</strong>
            </div>
            <div class="card-body">
              <textarea
                class="form-control"
                rows="4"
                placeholder="Descrição do personagem..."
              ></textarea>
            </div>
          </div>
        </div>
      </div>

      <!-- Main Attributes Section -->
      <div class="row mb-3">
        <!-- Dynamic Skill Sections Container -->
        <div class="col-md-12" id="dynamic-skill-sections">
          <!-- All skill sections will be rendered here from JSON -->
        </div>
      </div>

      <!-- HP and Mana Section -->
      <div id="resource-sections-container">
        <!-- HP and Mana sections will be rendered here from JSON -->
      </div>

      <!-- Bottom Section - Movimento and Point Calculator -->
      <div class="row mb-3 justify-content-center">
        <!-- Movimento -->
        <div class="col-md-3">
          <div class="card">
            <div class="card-header bg-secondary text-white text-center">
              <strong>Movimento</strong>
            </div>
            <div class="card-body text-center">
              <input
                type="number"
                class="form-control large-input mb-2"
                placeholder="Valor"
                id="movement"
              />
            </div>
          </div>
        </div>

        <!-- Point Calculator -->
        <div class="col-md-6">
          <div class="card">
            <div class="card-header bg-warning text-dark text-center">
              <strong>Calculadora de Pontos</strong>
            </div>
            <div class="card-body">
              <div class="row text-center">
                <div class="col-md-4">
                  <div class="point-category">
                    <div class="point-label">Nível Atual</div>
                    <div
                      class="point-value"
                      id="character-level"
                      contenteditable="true"
                      style="cursor: text"
                      onclick="editLevel(this)"
                      onblur="saveLevel(this)"
                      onkeypress="handleLevelKeypress(event, this)"
                    >
                      0
                    </div>
                    <div class="point-cost">nível</div>
                  </div>
                </div>
                <div class="col-md-4">
                  <div class="point-category">
                    <div class="point-label">Perícias Primárias</div>
                    <div class="point-value" id="attribute-points">0</div>
                    <div class="point-cost">
                      <span id="attribute-used">0</span> /
                      <span id="attribute-available">5</span> disponíveis
                    </div>
                  </div>
                </div>
                <div class="col-md-4">
                  <div class="point-category">
                    <div class="point-label">Perícias Secundárias</div>
                    <div class="point-value" id="skill-points">0</div>
                    <div class="point-cost">
                      <span id="skill-used">0</span> /
                      <span id="skill-available">10</span> disponíveis
                    </div>
                  </div>
                </div>
              </div>
              <div class="row mb-3">
                <div class="col-md-4">
                  <div class="point-category">
                    <div class="point-label">Prestígio</div>
                    <div class="point-value" id="prestigio-points">0</div>
                    <div class="point-cost">
                      <span id="prestigio-used">0</span> pontos de atributo
                    </div>
                  </div>
                </div>
              </div>
              <!-- Clear data button -->
              <div class="text-center mt-2">
                <button
                  type="button"
                  class="btn btn-sm btn-outline-secondary"
                  onclick="clearSavedCharacterData()"
                  title="Limpar dados salvos automaticamente"
                >
                  🗑️ Limpar Dados Salvos
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Additional Dynamic Skill Sections Container -->
      <div class="row mb-3" id="additional-skill-sections">
        <!-- Additional skill sections will be rendered here from JSON -->
      </div>

      <!-- Resources, Inventory and Attacks Section -->
      <div class="row">
        <!-- Resources -->
        <div class="col-md-4">
          <div class="resources-section" data-section="recursos">
            <div
              class="section-header"
              onclick="handleSectionClick('recursos')"
              style="cursor: pointer"
            >
              Recursos
            </div>
            <div class="p-3">
              <textarea
                class="form-control"
                rows="8"
                placeholder="Liste seus recursos aqui..."
              ></textarea>
            </div>
          </div>
        </div>

        <!-- Inventory -->
        <div class="col-md-4">
          <div class="resources-section">
            <div class="section-header">Inventário</div>
            <div class="p-3">
              <textarea
                class="form-control"
                rows="8"
                placeholder="Lista de itens do inventário..."
              ></textarea>
            </div>
          </div>
        </div>

        <!-- Attacks -->
        <div class="col-md-4">
          <div class="resources-section">
            <div class="section-header">Ataques</div>
            <div class="p-3">
              <table class="table table-sm attack-table">
                <thead>
                  <tr>
                    <th>Nome</th>
                    <th>Dano</th>
                    <th>Alcance</th>
                    <th>Tipo</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </div>

      <!-- Magic Creation Section -->
      <div class="row mt-4">
        <div class="col-12">
          <div class="resources-section" id="magic-creation-section">
            <div class="section-header">✨ Criação de Magias</div>
            <div class="p-3">
              <div class="row magic-creation-row">
                <!-- Magic Creation Form -->
                <div class="col-md-6">
                  <div class="magic-creation-form">
                    <h6 class="mb-3">Adicionar Nova Magia</h6>
                    <div class="mb-3">
                      <label for="magic-name-input" class="form-label"
                        >Nome da Magia</label
                      >
                      <input
                        type="text"
                        class="form-control"
                        id="magic-name-input"
                        placeholder="Digite o nome da magia..."
                        onkeypress="handleMagicInputKeypress(event)"
                      />
                    </div>
                    <div class="mb-3">
                      <div
                        id="magic-essences-container"
                        class="p-2 bg-light border rounded"
                      >
                        <!-- Essences selection will be populated by JavaScript -->
                      </div>
                    </div>
                    <div class="mb-3">
                      <label class="form-label">Componentes da Magia</label>
                      <div id="magic-components-container" class="p-2">
                        <!-- Component select fields will be populated by JavaScript -->
                      </div>
                      <small class="text-muted"
                        >Configure os componentes para a magia. Campos marcados
                        com * são obrigatórios.</small
                      >
                    </div>
                    <div class="mb-3">
                      <label for="magic-cost-input" class="form-label"
                        >Custo Base (Calculado)</label
                      >
                      <div class="d-flex gap-2 align-items-center">
                        <input
                          type="number"
                          class="form-control"
                          id="magic-cost-input"
                          placeholder="1"
                          value="1"
                          min="1"
                          readonly
                          title="O custo base é calculado automaticamente pelas essências selecionadas"
                        />
                        <span
                          id="magic-final-cost-input"
                          class="badge bg-success fs-6"
                        >
                          Custo Final: 1
                        </span>
                      </div>
                    </div>
                    <div class="mb-3">
                      <label for="magic-dice-input" class="form-label"
                        >Dados Finais</label
                      >
                      <div class="d-flex gap-2 align-items-center">
                        <input
                          type="text"
                          class="form-control"
                          id="magic-dice-input"
                          placeholder="Nenhum dado"
                          title="Dados calculados automaticamente pelas essências. Você pode editar se necessário."
                        />
                        <small class="text-muted"
                          >Calculado automaticamente, editável</small
                        >
                      </div>
                    </div>
                    <button
                      type="button"
                      class="btn btn-primary"
                      onclick="addMagicSpell()"
                    >
                      ➕ Adicionar Magia
                    </button>
                  </div>
                </div>

                <!-- Magic List Display -->
                <div class="col-md-6">
                  <div class="magic-list-section">
                    <h6 class="mb-3">Magias Conhecidas</h6>
                    <div id="magic-list-container" class="border rounded p-2">
                      <p class="text-muted text-center" id="no-magic-message">
                        Nenhuma magia adicionada ainda.
                      </p>
                    </div>
                    <div
                      class="mt-2 d-flex justify-content-between align-items-center"
                    >
                      <small class="text-muted"
                        >Total de magias: <span id="magic-count">0</span></small
                      >
                      <small class="text-info"
                        ><strong
                          >Custo Total:
                          <span id="magic-total-cost">0</span></strong
                        ></small
                      >
                      <button
                        type="button"
                        class="btn btn-sm btn-outline-danger"
                        onclick="clearAllMagics()"
                        title="Remover todas as magias"
                      >
                        🗑️ Limpar Todas
                      </button>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Bootstrap 5 JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>

    <script>
      // Extensible Component System for Character Sheet
      class SkillSectionComponent {
        constructor(containerId) {
          this.container = document.getElementById(containerId);
        }

        // Render a skill section from JSON configuration
        renderSection(config) {
          const attributeHtml = config.attribute
            ? `
            <div class="text-center mb-3">
              <div class="attribute-circle">
                <div class="attribute-label">${config.attribute.label}</div>
                <input
                  type="number"
                  class="form-control form-control-sm"
                  style="width: 50px; text-align: center"
                  value="0"
                  min="0"
                  max="3"
                  data-attribute="${config.attribute.dataAttribute}"
                  onchange="validateAttributeAndSkills('${config.attribute.dataAttribute}', '${config.sectionId}')"
                />
              </div>
              <button class="btn btn-sm btn-outline-primary mt-1" onclick="rollAttribute('${config.attribute.dataAttribute}', '${config.attribute.label}')" title="Rolar ${config.attribute.label}">
                🎲 Rolar
              </button>
            </div>
          `
            : "";

          console.log("---config");
          console.log(config);

          const sectionHtml = `
                    <div class="skill-${config.sectionId}-section">
                        ${attributeHtml}
                        <div class="section-title" onclick="${
                          config.onClick || "void(0)"
                        }" style="cursor: ${
            config.onClick ? "pointer" : "default"
          }">
                            ${config.label}
                        </div>
                        <div class="checkbox-list">
                            ${this.generateCheckboxes(
                              config.skills,
                              config.sectionId
                            )}
                            ${
                              config.prestigios && config.prestigios.length > 0
                                ? `
                            <div class="prestigio-divider" style="margin: 15px 0; border-top: 2px solid #007bff; position: relative;">
                                <span style="background: #f8f9fa; padding: 0 10px; position: absolute; top: -10px; left: 50%; transform: translateX(-50%); font-weight: bold; color: #007bff;">Prestígio</span>
                            </div>
                            ${this.generatePrestigioCheckboxes(
                              config.prestigios,
                              config.sectionId
                            )}
                            `
                                : ""
                            }
                        </div>
                    </div>
                `;
          return sectionHtml;
        }

        // Generate checkboxes based on skills array - now with 3 levels
        generateCheckboxes(skills, sectionId) {
          return skills
            .map(
              (skill, index) => `
                    <div class="form-check skill-levels" data-skill="${
                      skill.name
                    }" data-section="${sectionId}">
                        <label class="form-check-label skill-name">${
                          skill.name
                        }${
                skill.info
                  ? `<button class="essence-info-btn" onclick="showInfo('skill-${skill.name
                      .replace(/\s+/g, "-")
                      .toLowerCase()}', '${skill.name}', \`${
                      skill.info
                    }\`)" title="Informações sobre ${skill.name}">ℹ</button>`
                  : ""
              }</label>
                        <div class="skill-level-boxes">
                            <input class="form-check-input skill-level" type="checkbox" id="${sectionId}_${index}_1" data-skill="${
                skill.name
              }" data-section="${sectionId}" data-level="1" onclick="toggleSkillLevel(this, 1)">
                            <label class="level-label" for="${sectionId}_${index}_1">1</label>
                            <input class="form-check-input skill-level" type="checkbox" id="${sectionId}_${index}_2" data-skill="${
                skill.name
              }" data-section="${sectionId}" data-level="2" onclick="toggleSkillLevel(this, 2)">
                            <label class="level-label" for="${sectionId}_${index}_2">2</label>
                            <input class="form-check-input skill-level" type="checkbox" id="${sectionId}_${index}_3" data-skill="${
                skill.name
              }" data-section="${sectionId}" data-level="3" onclick="toggleSkillLevel(this, 3)">
                            <label class="level-label" for="${sectionId}_${index}_3">3</label>
                            <button class="btn btn-xs btn-outline-success ms-2" onclick="rollSkill('${sectionId}', '${
                skill.name
              }')" title="Rolar ${
                skill.name
              }" style="font-size: 10px; padding: 2px 6px;">
                              🎲
                            </button>
                        </div>
                    </div>
                `
            )
            .join("");
        }

        // Generate special Prestígio checkboxes (1 attribute point each)
        generatePrestigioCheckboxes(prestigios, sectionId) {
          console.log("----Generationg prestio checkbox----");
          return prestigios
            .map((prestigio, index) => {
              const infoButton = prestigio.info
                ? `<button class="essence-info-btn" onclick="showInfo('prestigio-${prestigio.name
                    .replace(/\s+/g, "-")
                    .toLowerCase()}', '${
                    prestigio.name
                  }', '${prestigio.info.replace(
                    /'/g,
                    "&#39;"
                  )}', '')" title="Informações sobre ${
                    prestigio.name
                  }">ℹ</button>`
                : "";

              return `
                    <div class="form-check skill-levels prestigio-skill" data-skill="${prestigio.name}" data-section="${sectionId}">
                        <label class="form-check-label skill-name" style="color: #007bff; font-weight: bold;">${prestigio.name}${infoButton}</label>
                        <div class="skill-level-boxes">
                            <input class="form-check-input prestigio-level" type="checkbox" id="${sectionId}_prestigio_${index}" data-skill="${prestigio.name}" data-section="${sectionId}" data-prestigio="true" onclick="togglePrestigioSkill(this)">
                            <label class="level-label" for="${sectionId}_prestigio_${index}" style="color: #007bff;">✓</label>
                            <span class="prestigio-cost" style="font-size: 10px; color: #666; margin-left: 5px;">(1 pt. atributo)</span>
                        </div>
                    </div>
                `;
            })
            .join("");
        }

        // Render multiple sections from JSON array
        renderFromJson(sectionsConfig) {
          let html = "";
          sectionsConfig.forEach((config) => {
            html += this.renderSection(config);
          });
          if (this.container) {
            this.container.innerHTML = html;
          }
          return html;
        }
      }

      // Resource/Stat Component for HP, Mana, etc.
      class ResourceComponent {
        constructor() {}

        // Render a resource section from JSON configuration
        renderResourceSection(config) {
          const diceSelector = config.diceType
            ? `
            <div class="col-12 mb-2">
              <div class="d-flex align-items-center justify-content-center">
                <label class="form-label me-2 mb-0"><strong>Dado:</strong></label>
                <select class="form-select form-select-sm dice-selector" style="width: auto;" id="${
                  config.diceSelectId
                }" onchange="onDiceTypeChange('${config.resourceName}')">
                  <option value="d4" ${
                    config.diceType === "d4" ? "selected" : ""
                  }>d4</option>
                  <option value="d6" ${
                    config.diceType === "d6" ? "selected" : ""
                  }>d6</option>
                  <option value="d8" ${
                    config.diceType === "d8" ? "selected" : ""
                  }>d8</option>
                  <option value="d10" ${
                    config.diceType === "d10" ? "selected" : ""
                  }>d10</option>
                  <option value="d12" ${
                    config.diceType === "d12" ? "selected" : ""
                  }>d12</option>
                </select>
                <button class="btn btn-sm btn-outline-warning ms-2" onclick="rollResourceDice('${
                  config.resourceName
                }', '${
                config.diceSelectId
              }')" title="Substituir rolls automáticos por rolls manuais">
                  🎲 Manual
                </button>
              </div>
            </div>
          `
            : "";

          const resourceHtml = `
            <div class="col-md-${config.columnSize || 6}">
              <div class="hp-mana-section">
                <div class="row">
                  ${diceSelector}
                  <div class="col-4">
                    <label class="form-label"><strong>Base ${
                      config.resourceName
                    }</strong></label>
                    <input
                      type="number"
                      class="form-control large-input"
                      id="${config.baseId}"
                      placeholder="${config.basePlaceholder || "0"}"
                      readonly
                      style="background-color: #f8f9fa; cursor: not-allowed;"
                    />
                    <button class="btn btn-xs btn-outline-info mt-1" style="font-size: 10px; padding: 2px 6px;" onclick="showResourceRollHistory('${
                      config.resourceName
                    }')" title="Ver histórico de rolls">
                      📋 Histórico
                    </button>
                  </div>
                  <div class="col-4">
                    <label class="form-label"><strong>Extra ${
                      config.resourceName
                    }</strong></label>
                    <input
                      type="number"
                      class="form-control large-input"
                      id="${config.extraId}"
                      placeholder="${config.extraPlaceholder || "0"}"
                      onchange="calculateResourceTotal('${
                        config.resourceName
                      }')"
                    />
                  </div>
                  <div class="col-4">
                    <label class="form-label"><strong>${
                      config.totalLabel
                    }</strong></label>
                    <input
                      type="number"
                      class="form-control large-input"
                      id="${config.totalId}"
                      placeholder="${config.totalPlaceholder || "0"}"
                      readonly
                      style="background-color: #f8f9fa; cursor: not-allowed;"
                    />
                  </div>
                  <div class="col-12 mt-2">
                    <label class="form-label"><strong>${
                      config.currentLabel
                    }</strong></label>
                    <input
                      type="number"
                      class="form-control large-input"
                      id="${config.currentId}"
                      placeholder="${config.currentPlaceholder || "0"}"
                    />
                  </div>
                </div>
              </div>
            </div>
          `;
          return resourceHtml;
        }

        // Render multiple resource sections from JSON array
        renderFromJson(resourcesConfig, containerId) {
          const container = document.getElementById(containerId);
          if (!container) return "";

          let html = '<div class="row mb-3">';
          resourcesConfig.forEach((config) => {
            html += this.renderResourceSection(config);
          });
          html += "</div>";

          container.innerHTML = html;
          return html;
        }
      }

      // Function to update dice selector availability based on character level
      function updateDiceSelectorAvailability() {
        const level =
          parseInt(document.getElementById("character-level")?.textContent) ||
          0;
        const diceSelectors = document.querySelectorAll(".dice-selector");

        diceSelectors.forEach((selector) => {
          if (level > 0) {
            // Disable selector and gray it out for levels above 0
            selector.disabled = true;
            selector.style.opacity = "0.5";
            selector.style.cursor = "not-allowed";
          } else {
            // Enable selector for level 0 (character creation)
            selector.disabled = false;
            selector.style.opacity = "1";
            selector.style.cursor = "pointer";
          }
        });
      }

      // Function to calculate resource total (Base + Extra = Total)
      function calculateResourceTotal(resourceName) {
        const config = resourceSectionsConfig.find(
          (c) => c.resourceName === resourceName
        );
        if (!config) return;

        const baseInput = document.getElementById(config.baseId);
        const extraInput = document.getElementById(config.extraId);
        const totalInput = document.getElementById(config.totalId);

        if (baseInput && extraInput && totalInput) {
          const baseValue = parseInt(baseInput.value) || 0;
          const extraValue = parseInt(extraInput.value) || 0;
          const total = baseValue + extraValue;

          totalInput.value = total;

          // Trigger auto-save after calculation
          clearTimeout(window.saveTimeout);
          window.saveTimeout = setTimeout(() => {
            saveCharacterDataToStorage();
          }, 500);
        }
      }

      // Configuration JSON for resource sections
      const resourceSectionsConfig = [
        {
          resourceName: "HP",
          totalLabel: "HP Total",
          currentLabel: "HP Atual",
          baseId: "hp-base",
          extraId: "hp-extra",
          totalId: "hp-total",
          currentId: "hp-current",
          columnSize: 6,
          diceType: "d6",
          diceSelectId: "hp-dice-select",
        },
        {
          resourceName: "Mana",
          totalLabel: "Mana Total",
          currentLabel: "Mana Atual",
          baseId: "mana-base",
          extraId: "mana-extra",
          totalId: "mana-total",
          currentId: "mana-current",
          columnSize: 6,
          diceType: "d6",
          diceSelectId: "mana-dice-select",
        },
        // You can easily add more resource types here:
        // {
        //   resourceName: "Stamina",
        //   totalLabel: "Stamina Total",
        //   currentLabel: "Stamina Atual",
        //   baseId: "stamina-base",
        //   extraId: "stamina-extra",
        //   totalId: "stamina-total",
        //   currentId: "stamina-current",
        //   columnSize: 6,
        //   diceType: "d8",
        //   diceSelectId: "stamina-dice-select"
        // }
      ];

      // Configuration JSON for skill sections
      const skillSectionsConfig = [
        // Conhecimento
        {
          label: "Conhecimento",
          sectionId: "conhecimento",
          onClick: "handleSectionClick('conhecimento')",
          attribute: { label: "CON", dataAttribute: "con" },
          skills: [
            {
              name: "Cartografia",
              info: " Descrição: Implica na capacidade do jogador elaborarmapas e/ou compreender-los. <br><br><b>Nível 1:</b> Permite ao jogador ler qualquer tipo de mapasimples e se guiar por ele sem dificuldade. <br><br><b>Nível 2:</b> O segundo nível agracia o jogador com acapacidade de, dado um pouco de conhecimento deambiente, elaborar mapas ou preencher mapasincompletos. <br><br><b>Nível 3:</b> Ao terceiro nível, qualquer mapa pode ser lidopelo jogador (comuns e mágicos), além disso, o jogador écapaz de otimizar rotas e encontrar atalhos comfacilidade, dobrando a velocidade de viagem de qualquerum que o acompanhe. Por fim, o jogador podeconfeccionar mapas de altíssima qualidade.",
            },
            {
              name: "Ciências",
              info: "Mede a capacidade intelectual geral da personagem.<br><br><b>Nível 1:</b>Flat bônus de +1 para todas as rolagens de conhecimento. <br><br><b>Nível 2:</b>Aumento do flat bônus para +2. <br><br><b>Nível 3:</b>Aumento do flat bônus para +3.",
            },
            {
              name: "Demolição",
              info: "Mede a capacidade do personagem de elaborar explosivos improvisados.<br><br><b>Nível 1:</b>O jogador pode fazer uma bomba de fumaça (dura um turno e aplica o efeito de cego em uma área de 5m de raio) ou uma bomba de pólvora negra que faz muito barulho. O preço delas sendo:<br>Bomba de Fumaça: 10 de gold, necessita de 30 minutos para confecção;<br>Bomba de Pólvora: 20 de gold, necessita de 1 hora para confecção; <br><br><b>Nível 2:</b>O personagem poderá agora fazer uma amalgama de mana em suas bombas. Caso a bomba de fumaça seja melhorada durará 3 turnos. Já para a pólvora negra causará 4d4 de dano para qualquer unidade dentro de um raio de 5 metros. <br><br><b>Nível 3:</b>O jogador pode confeccionar uma bomba de alta potência. Esta bomba causa 20d10 de dano em um raio de 50 metros, ela requer: 1000 peças de ouro e 2 dias de confecção. Essa bomba pode causar efeitos extras a depender do mestre.",
            },
            {
              name: "Investigação",
              info: "Refere a capacidade do jogador de realizar uma busca de forma ativa de algo ou alguém.<br><br><b>Nível 1:</b>Flat bônus de +3 para rolagens desta perícia. <br><br><b>Nível 2:</b>Aumenta o flat bônus para +5 em rolagens desta perícia. <br><br><b>Nível 3:</b>A personagem pode encontrar o mercado negro de uma região.",
            },
            {
              name: "Matemática",
              info: "Mede o conhecimento do personagem em matemática para fazer uma análise rápida de trajetórias e afins.<br><br><b>Nível 1:</b>Projéteis físicos ou mágicos tem um aumento de 5 metros de alcance (vale para ataques de no mínimo 20 metros). <br><br><b>Nível 2:</b>Projéteis físicos ou mágicos tem um aumento de 15 metros de alcance (vale para ataques de no mínimo 20 metros). <br><br><b>Nível 3:</b>Projéteis físicos ou mágicos tem um aumento de 25 metros de alcance (vale para ataques de no mínimo 20 metros).",
            },
            {
              name: "Medicina",
              info: "Perícia utilizada para medir o conhecimento de um personagem em medicina, para poder efetuar testes de primeiro socorros em aliados ou NPCs.<br><br><b>Nível 1:</b> <br><br>Recebe um flat bônus de +3 para rolagens de medicina a cerca de conhecimentos teóricos, tais como sobre anatomia, uso de remédios, etc. O jogador pode usar uma ação para estabilizar um aliado caído ao chão sem ter de realizar qualquer teste de dificuldade ou então gastar recursos.<br><br><b>Nível 2:</b>Aumento do bônus para +5. O personagem recebe duas habilidades ao atingir este nível:<br> Primeiros Socorros: O personagem pode curar ferimentos de um jogador, dando a ele uma quantidade de pontos de vida igual a metade dos pontos de mana gastos para realizar a habilidade.<br>Intervenção: O jogador poderá utilizar uma ação e 20 pontos de mana para remover todos os pontos de um dentre os seguintes efeitos: envenenamento, sangramento, incendiado, congelado ou fraco. <br><br><b>Nível 3:</b>O personagem torna-se proficiente em realizar cirurgias, um teste deve ser realizado e um kit cirúrgico será consumido no processo, no entanto, o personagem pode remover qualquer lesão aplicada ao jogador. O processo cirúrgico demora até 12 horas (a critério do mestre) e aplica 2 pontos de exaustão (o procedimento pode devolver até membros amputados ou visão).",
            },
            {
              name: "Natureza",
              info: "Perícia sobre os conhecimentos do personagem com o mundo natural e fenômenos que possam ser correlacionados a ele ou ao mundo mágico.<br><br><b>Nível 1:</b>Flat bônus de +3 para rolagens desta perícia. <br><br><b>Nível 2:</b>Aumenta o flat bônus para +5 em rolagens desta perícia. <br><br><b>Nível 3:</b>A personagem recebe um desconto de 15 de gold na produção de venenos e poções.",
            },
            {
              name: "Psicologia",
              info: "Dita a habilidade do personagem em ler outros seres sapientes, discernir intenções e auxiliar em tratamento de personagens e NPCs.<br><br><b>Nível 1:</b>O personagem pode gastar 15 pontos de mana para determinar se alguém esta mentindo para ele, sem necessidade de roll. <br><br><b>Nível 2:</b>As técnicas terapêuticas do personagem se ampliam, permitindo com que ele possa uma vez por dia tratar um ponto de insanidade de um aliado. <br><br><b>Nível 3:</b>O conhecimento do personagem em psicologia é tamanho que ele pode, uma vez por dia, conversar com o grupo e remover 1 ponto de insanidade do grupo inteiro.",
            },
            {
              name: "Veterinária",
              info: "Dita o conhecimento do personagem sobre como tratar animais e fazer primeiros socorros neles.<br><br><b>Nível 1:</b>Recebe um flat bônus de +3 para rolagens de medicina a cerca de conhecimentos teóricos, tais como sobre anatomia, uso de remédios, etc, em animais. O jogador pode gastar uma ação para estabilizar um animal caído sem ser necessário fazer qualquer teste de dificuldade ou então gastar recursos. <br><br><b>Nível 2:</b>Aumento do bônus para +5. O personagem recebe duas habilidades ao atingir este nível:<br>Primeiros Socorros: O personagem pode curar ferimentos de um animal, dando a ele uma quantidade de pontos de vida igual a metade dos pontos de mana gastos para realizar a habilidade.<br>Intervenção: O jogador poderá utilizar uma ação e 20 pontos de mana para, em um animal, remover todos os pontos dos seguintes efeitos: envenenamento, sangramento, incendiado, congelado ou fraco. <br><br><b>Nível 3:</b>O personagem torna-se proficiente em realizar cirurgias em animais, um teste deve ser realizado e um kit cirúrgico será consumido no processo, no entanto, o personagem pode remover qualquer lesão ou 1 ponto de Morte aplicada ao animal, a menos de 1 semana. O processo cirúrgico demora até 12 horas (a critério do mestre) e aplica 2 pontos de exaustão (o procedimento pode devolver até membros amputados ou visão).",
            },
          ],
          prestigios: [
            {
              name: "Acadêmico",
              info: "Requisito: Você estuda com o professor Gabriel Ikawa.",
            },
            {
              name: "Mestre de Venenos",
              info: "Requisito: Conhecimento. O personagem é um especialista em criar e utilizar venenos.",
            },
          ],
        },
        {
          label: "Social",
          sectionId: "social",
          onClick: "handleSectionClick('social')",
          attribute: { label: "SOC", dataAttribute: "soc" },
          skills: [
            {
              name: "Contar Histórias",
              info: "Uma perícia que mede o quão bem seu personagem pode contar histórias. <br><br><b>Nível 1:</b>O personagem poderá contar histórias simples que são capazes de prender um pequeno grupo de NPC's na sua narrativa, podendo ser utilizado como forma de obter informações ou distração. <br><br><b>Nível 2:</b> Gasta uma ação e 7 de mana para que, a todos que ouçam uma história calma e pacífica, percam 1 ponto de medo, encantado e frenesi. <br><br><b>Nível 3:</b> A capacidade de contar histórias do seu personagem é tamanha que ele é capaz de prender completamente a atenção de um alvo. O alvo ficará tão entretido dentro da narrativa que ficará sob o efeito de encantado. Sendo então capaz de se obter um grande favor deste. O número de pontos de encantado aplicado será igual a duas vezes o número de horas contando a história e gastará 5 de mana por hora de história.",
            },
            {
              name: "Discursar",
              info: "Dita a capacidade do personagem em fazer discursos, podendo enganar, incentivar, repreender ou alegrar plateias. O discurso pode ser feito duas vezes por sessão independente de nível. <br><br><b>Nível 1:</b> O jogador consegue fazer um pequeno discurso que cativará até 3 pessoas a sua escolha. O discurso da 1 ponto de moral. Realizar o discurso consome uma ação e 5 de mana. <br><br><b>Nível 2:</b> A oratória do jogador é melhorada, garantindo que possa discursar para até 6 pessoas. <br><br><b>Nível 3:</b> Ao terceiro nível, o jogador pode fazer seu discurso inflamador, podendo aplicar o efeito de frenesi.",
            },
            {
              name: "Embromação",
              info: "Mede a capacidade do personagem em desviar a atenção de um NPC ou outro jogador, usando de direcionamento e prolixidade. <br><br><b>Nível 1:</b>O personagem pode tentar distrair a um NPC ou jogador, sendo necessário a realização de um teste para que, durante 1 minuto mantenha o alvo da embromação sob o efeito de 1 de Paralisado. Caso seja um combate, será gasto 12 de mana e feito um teste de social todo turno para conceder este ponto. <br><br><b>Nível 2:</b> O personagem pode tentar distrair a um NPC ou jogador, sendo necessário a realização de um teste para que, durante 2 minutos mantenha o alvo da embromação sob o efeito de 1 de Paralisado. Caso seja um combate, será gasto 10 de mana e feito um teste de social todo turno para conceder este ponto. <br><br><b>Nível 3:</b> O personagem pode tentar distrair a um NPC ou jogador, sendo necessário a realização de um teste para que, durante 4 minutos mantenha o alvo da embromação sob o efeito de 1 de Paralisado. Caso seja um combate, será gasto 8 de mana e feito um teste de social todo turno para conceder este ponto.",
            },
            {
              name: "Intimidação",
              info: "Utilizada para que um jogador tente dissuadir um NPC ou outro jogador, pode também ser usada em combates para gerar efeitos de medo ao alvo. <br><br><b>Nível 1:</b> Recebe um flat bônus de +3 para rolagens no dado. <br><br><b>Nível 2:</b> Aumento do flat bônus para +5. O jogador pode queimar uma ação e 4 de mana para intimidar o seu adversário. Aplicando 1 ponto de medo. <br><br><b>Nível 3:</b> O jogador pode gastar sua ação e 8 de mana para intimidar uma área ao seu redor cujo raio é de 5 metros. Todos os alvos dentro desta área receberão 1 ponto de medo.",
            },
            {
              name: "Mentira",
              info: "Implica na capacidade do personagem em elaborar mentiras ou então histórias ou argumentos falaciosos que sejam concisos. <br><br><b>Nível 1:</b> Recebe um flat bônus de +3 para rolagens no dado. <br><br><b>Nível 2:</b> Aumento do flat bônus para +5 para rolagens. <br><br><b>Nível 3:</b> Aumento do flat bônus para +7 para rolagens.",
            },
            {
              name: "Negociação",
              info: "Perícia para medir o quão bem seu personagem é capaz de negociar por novos preços e/ou trocas entre personagens. <br><br><b>Nível 1:</b> Recebe um flat bônus de +3 para rolagens no dado.<br><br><b>Nível 2:</b> Aumento do flat bônus para +5 para rolagens. O jogador é garantido de ter um desconto de 10% no valor do item de compra independente de rolagem. <br><br><b>Nível 3:</b> Acesso aos mercados negros, locais onde itens mais raros e mais poderosos podem ser encontrados, tão bem como qualquer outro objeto de contrabando ou então ilegal.",
            },
            {
              name: "Persuasão",
              info: "Dita o quão bem o jogador consegue alterar o posicionamento de outro personagem, ou NPC, para que ele consiga influencia-lo. <br><br><b>Nível 1:</b> Recebe um flat bônus de +3 para rolagens no dado. <br><br><b>Nível 2:</b> Aumento do flat bônus para +5 para rolagens. <br><br><b>Nível 3:</b> Aumento do flat bônus para +7 para rolagens.",
            },
            {
              name: "Sedução",
              info: "Mede a capacidade do personagem flertar com algum NPC. <br><br><b>Nível 1:</b> Flat bônus de +3 para rolagens desta perícia. <br><br><b>Nível 2:</b> Aumenta o flat bônus para +5 em rolagens desta perícia. A personagem pode usar uma ação e 5 de mana para aplicar 1 ponto de encantado. <br><br><b>Nível 3:</b> A personagem pode usar uma ação e 7 de mana para aplicar 1 ponto de hipnotizado.",
            },
          ],
          prestigios: [
            {
              name: "Folclore",
              info: "Requisito: Cultura ou Social. O personagem tem conhecimento profundo sobre tradições e lendas populares.",
            },
            {
              name: "Política",
              info: "Requisito: Cultura ou Social. O personagem entende os complexos sistemas políticos e é hábil em negociações diplomáticas.",
            },
          ],
        },
        {
          label: "Cultura",
          sectionId: "cultura",
          onClick: "handleSectionClick('cultura')",
          attribute: { label: "CUL", dataAttribute: "cul" },
          skills: [
            {
              name: "Belas Artes",
              info: "Utilizada para quando há a tentativa de expressar por meio da arte, com pinturas, músicas, literatura, etc. <br><br><b>Nível 1:</b> O jogador pode gastar 7 pontos de mana para aplicar dois pontos de confusão ou um ponto de encantado a um alvo. Após o termino do efeito, o mesmo alvo não pode sofrer efeitos dessa habilidade por 5 minutos.<br><br><b>Nível 2:</b> A personagem pode gastar uma ação para, dentro de um raio de 10m, revelar uma grande obra. Podendo assim, aumentar ou diminuir 1 ponto de moral de todos aqueles dentro da área até o seu próximo turno. Caso o jogador escolha diminuir um ponto todos os aliados e inimigos estarão sob esse mesmo efeito. <br><br><b>Nível 3:</b> Fazendo uma grande demonstração artística o jogador pode enaltecer os feitos e conquistas de outro personagem. Concedendo-lhe 1 ponto de Honrado, sendo preciso no mínimo 1 hora de tempo e 20 pontos de mana (a critério do mestre pode ser cobrado algum recurso a ser aplicado na forma de ouro, como tintas que custem 20 de gold).",
            },
            {
              name: "Artífice",
              info: "Permite ao jogador identificar artefatos, aprender sua origem, obter bônus a partir deles e, finalmente, ascender um item ao estado de Artefato. <br><br><b>Nível 1:</b>O jogador pode gastar 1 dia analisando um artefato desconhecido para determinar qual é o seu efeito de artefato. <br><br><b>Nível 2:</b>Toda vez que o jogador identificar um artefato ele poderá escolher um dentre os seguintes bônus: <br>    +4 de HP permanente;<br>    +2 de MP permanente;<br>    +1 em rolagem de Cultura;<br>    +30 de Fervor; <br>    +500 de Gold.<br><br><b>Nível 3:</b>O jogador pode, uma vez em sua vida, ascender um item nível 3, com prístino 3,uma propriedade e 1 encantamento para um artefato. Para isso, este precisa gastar:<br>14 dias;<br>1000 de Gold;<br>Toda a sua mana;<br>Ecolhendo um efeito de artefato e atrelando-o ao item. O item deve então ser nomeado. Além disso, o jogador recebe:<br>2 pontos de exaustão;<br>2 pontos de insanidade. ",
            },

            {
              name: "História",
              info: "Implica nos conhecimentos históricos do personagem a cerca de algum local, ambiente ou cultura. <br><br><b>Nível 1:</b> Para qualquer teste de história que vise obter informação sobre um povo, ambiente, local, pessoas há um bônus de +3 na rolagem. <br><br><b>Nível 2:</b> Há o aumento do bônus de rolagem para +5. A personagem melhora seu entendimento de ruínas, aumentando o bônus de ``Análise de Ruínas'' da perícia Folclore nível 3 de +5 para +7 pontos de folclore. <br><br><b>Nível 3:</b> O jogador pode gastar 1 dia estudando um artefato ou objeto mágico para entender a origem dele, tal como que povo a fez, de onde ela vem, características dela, etc. Caso o jogador possua Folclore nível 1, ele também recebe 4 pontos de folclore.",
            },
            {
              name: "Morfologia",
              info: "Seu personagem é capaz de entender línguas e fundamentos linguísticos, isso permite com que ele possa interpretar mensagens, escrita, etc. <br><br><b>Nível 1:</b> Seu personagem tem total proficiência na em um segundo idioma a escolha dele. <br><br><b>Nível 2:</b> Com mais conhecimento morfológico, o personagem conhece mais de línguas esquecidas ou perdidas, permitindo entender algumas palavras em cavernas, ruínas antigas, etc. O jogador também pode conhecer mais um idioma. <br><br><b>Nível 3:</b> O conhecimento em linguística do personagem é imenso, ele se torna capaz de compreender e identificar qualquer idioma desconhecido a critério do mestre.",
            },
            {
              name: "Performance",
              info: "Mede a habilidade do personagem em efetuar uma performance para poder fazer um show ou encantar uma plateia. <br><br><b>Nível 1:</b> Recebe um flat bônus de +3 para rolagens de performance. O personagem pode fazer uma performance para um pequeno público, deixando a maior parte dos ouvintes apenas desatentos por alguns minutos.<br><br><b>Nível 2:</b> Aumento do flat bônus de +5 em rolagens de performance. O conhecimento de palco do personagem aumenta, ele pode utilizar 10 pontos de mana para realizar uma grande performance de sua escolha que resultará no ganho de algumas moedas de ouro (a quantia de ouro advém de um teste de performance). Recebe 1 ponto de exaustão ao realizar a performance. <br><br><b>Nível 3:</b> Ao terceiro nível, o personagem além de receber mais ouro (a quantia de ouro advém de um teste de performance) no seu grande show, ele também pode receber itens da plateia (a critério do mestre) como forma de pagamento.",
            },
            {
              name: "Religião",
              info: "Mede o conhecimento do personagem sobre teologia e conhecimentos religiosos no geral. <br><br><b>Nível 1:</b> Recebe um flat bônus de +3 para conhecimento a cerca de religião. <br><br><b>Nível 2:</b> Aumento do flat bônus para +5. <br><br><b>Nível 3:</b> Desbloqueia técnicas avançadas de exercício da fé (Verificar perícia de Fé).",
            },
          ],
          prestigios: [
            {
              name: "Folclore",
              info: "Requisito: Cultura ou Social. O personagem tem conhecimento profundo sobre tradições e lendas populares.",
            },
            {
              name: "Fé",
              info: "Requisito: Cultura ou Magia. O personagem possui uma fé profunda que lhe concede poderes divinos.",
            },
          ],
        },
        {
          label: "Atletismo",
          sectionId: "atletismo",
          onClick: "handleSectionClick('atletismo')",
          attribute: { label: "ALT", dataAttribute: "alt" },
          skills: [
            {
              name: "Acrobacia",
              info: "Perícia para descrever as capacidades acrobáticas de um personagem para se deslocar no espaço. <br><br><b>Nível 1:</b> Flat bônus de +3 para rolagens desta perícia. <br><br><b>Nível 2:</b> Aumenta o flat bônus para +5 em rolagens desta perícia. A personagem ganha a capacidade de escalar superfícies verticais (a critério do mestre). <br><br><b>Nível 3:</b> Imunidade a dano de queda.",
            },
            {
              name: "Atlética",
              info: "Mede o condicionamento físico do personagem, indicando o quão bom ele sabe correr, nadar, etc. <br><br><b>Nível 1:</b> Aumento da velocidade de movimento em +2 m. <br><br><b>Nível 2:</b> Aumento da velocidade de movimento em +3 m. Totalizando (com o primeiro nível) 5 m de movimentação extra. <br><br><b>Nível 3:</b> Aumento da velocidade de movimento em +4 m. Totalizando (com o segundo nível) 9 m de movimentação extra.",
            },
            {
              name: "Carga",
              info: "Adiciona mais slots para que o jogador possa carregar seus itens de fácil acesso. <br><br><b>Nível 1:</b> O personagem ganha +1 slot. <br><br><b>Nível 2:</b> O personagem ganha +2 slots, totalizando 3 slots extras. <br><br><b>Nível 3:</b> O personagem ganha +3 slots, totalizando 6 slots extras.",
            },
            {
              name: "Constituição",
              info: "Apresenta a resistência física do jogador a certos efeitos. <br><br><b>Nível 1:</b> Caso a personagem fique inconsciente receba 1 ponto de inconsciente extra. A primeira vez que o jogador receber dano o suficiente para que sua vida chegue à 0 ou abaixo, sua vida será definida para 1 (esse efeito só pode ocorrer a cada 3 dias). <br><br><b>Nível 2:</b> O jogador pode gastar uma ação de reforço e 5 pontos de mana para remover 1d4 de pontos de alguma das seguintes condições: envenenado, congelado, decompondo, fraco, imobilizado, incendiado, lento, paralisado, sangramento. <br><br><b>Nível 3:</b> O jogador poderá escolher um efeito de dano para que possua resistência a ele, além de que o primeiro ponto de exaustão não possui efeito.",
            },
            {
              name: "Equilíbrio",
              info: "Define o quão bom o seu personagem é para movimentar seu corpo mantendo o equilíbrio, implicando na sua capacidade de se manter de pé mesmo frente adversidades. <br><br><b>Nível 1:</b> Flat bônus de +3 para rolagens desta perícia. <br><br><b>Nível 2:</b> Aumenta o flat bônus para +5 em rolagens desta perícia. Se o jogador não usar a sua ação de movimento, sua AD aumenta em +1 até o próximo turno. <br><br><b>Nível 3:</b> Não recebe ponto da condição Caído.",
            },
            {
              name: "Evasão",
              info: "Explicita a habilidade do personagem usar sua ação de reação para desviar de projéteis e áreas de efeito. <br><br><b>Nível 1:</b> Permite com que a personagem, ao receber dano por um ataque à distância de alvo único, use sua reação e 10 de MP para reduzir o dano pela metade.<br><br><b>Nível 2:</b> Mesma descrição do primeiro nível, no entanto, o dano é levado à zero. <br><br><b>Nível 3:</b> A personagem, caso receba dano por uma área de efeito, use sua reação e 10 de MP para reduzir o dano pela metade.",
            },
            {
              name: "Força",
              info: "Perícia utilizada para desbloquear armas do tipo PS, PDM e  auxilia no desbloqueio de ArcP. Os bônus aqui presente são válidos apenas para esses tipo de arma. <br><br><b>Nível 1:</b> O jogador pode usar 4 de mana e sua reação para, após realizar um ataque bem sucedido, aplicar 1 ponto de caído no alvo. <br><br><b>Nível 2:</b> O jogador recebe +4 de dano físico com armas pesadas. <br><br><b>Nível 3:</b> Utilizando sua ação de preparação e 10 de mana o jogador poderá realizar um ataque contundente, caso o ataque seja bem sucedido, o alvo sofrerá 1 ponto de Atordoado.",
            },
            {
              name: "Reflexos",
              info: "Perícia relativa aos reflexos do seu personagem, aprimorando suas capacidades de esquiva com ou sem armaduras. <br><br><b>Nível 1:</b>Ganho de +2 de AD para caso o jogador esteja ou sem armadura ou com uma armadura leve. <br><br><b>Nível 2:</b> O bônus de AD torna-se +3 e o efeito se aplica também para armaduras médias. <br><br><b>Nível 3:</b> O jogador pode utilizar 4 de mana para que em uma reação possa reduzir o dano de um ataque corpo a corpo em 2d8.",
            },
          ],
          prestigios: [
            {
              name: "Furioso",
              info: "Requisito: Atletismo. O personagem pode entrar em fúria de batalha, aumentando significativamente suas habilidades físicas.",
            },
            {
              name: "Marcial",
              info: "Requisito: Combate. O personagem é um mestre em artes marciais e técnicas de combate avançadas.",
            },
          ],
        },
        {
          label: "Manufatura",
          sectionId: "manufatura",
          onClick: "handleSectionClick('manufatura')",
          attribute: { label: "MAN", dataAttribute: "man" },
          skills: [
            {
              name: "Alfaiate",
              info: "Permite com que o jogador possa fazer armaduras leves, roupas e tecidos, mediante uma rolagem de manufatura com dificuldade definida pelo mestre, se houver uma falha os recursos são destruídos. Materiais, custo e tempo de produção ficam a critério do mestre. <br><br><b>Nível 1:</b>Permite com que o personagem faça armaduras leves até nível 1 e com Prístino nível 1. <br><br><b>Nível 2:</b> Ao segundo nível, armaduras leves até o nível 2 podem ser feitas e com Prístino nível 2. <br><br><b>Nível 3:</b> No terceiro nível, armaduras leves podem ser feitas até o nível 3 e com Prístino nível 3 e, toda armadura leve feita pelo personagem, pode receber uma propriedade a escolha, caso possua os materiais necessários.",
            },
            {
              name: "Armeiro",
              info: "Permite com que o jogador faça armas (corpo a corpo) de qualquer classe. Materiais, custo e tempo de produção ficam a critério do mestre. <br><br><b>Nível 1:</b> Permite com que o personagem faça qualquer classe de arma em nível 1 (corpo a corpo) e com Prístino nível 1. <br><br><b>Nível 2:</b> Permite com que o personagem faça qualquer classe de arma em nível 2 (corpo a corpo) e com Prístino nível 2. <br><br><b>Nível 3:</b> Permite com que o personagem faça qualquer classe de arma em nível 3 (corpo a corpo) e com Prístino nível 3. E toda armadura moderada feita pelo personagem, pode receber uma propriedade a escolha, caso tenha os materiais necessários.",
            },
            {
              name: "Armoreiro",
              info: "Permite com que o jogador faça  armaduras pesadas. Materiais, custo e tempo de produção ficam a critério do mestre. <br><br><b>Nível 1:</b> Permite com que o personagem faça armaduras pesadas até nível 1 e com Prístino nível 1.<br><br><b>Nível 2:</b> Permite com que o personagem faça armaduras pesadas até nível 2 e com Prístino nível 2. O jogador pode fazer qualquer tipo de escudo. <br><br><b>Nível 3:</b> Permite com que o personagem faça armaduras pesadas até nível 3 e com Prístino nível 3 e, toda armadura moderada feita pelo personagem, pode receber uma propriedade a escolha, caso tenha os materiais necessários.",
            },
            {
              name: "Carpintaria",
              info: "Permite com que o jogador possa fazer arcos, bestas e bordões. Materiais, custo e tempo de produção ficam a critério do mestre. <br><br><b>Nível 1:</b> Permite com que o personagem faça qualquer arco, arco pesado, bestas ou bordões em nível 1 e com Prístino nível 1. O jogador pode fazer qualquer tipo de escudo.  <br><br><b>Nível 2:</b> Permite com que o personagem faça qualquer arco, arco pesado, bestas ou bordões em nível 2 e com Prístino nível 2. <br><br><b>Nível 3:</b> Permite com que o personagem faça qualquer arco, arco pesado, bestas ou bordões em nível 3 e com Prístino nível 3 e, elas podem receber uma propriedade a escolha, caso possua os materiais necessários.",
            },
            {
              name: "Disfarce",
              info: "Mede a capacidade do personagem em alterar a aparência e enganar aos NPCs próximos. Mediante uma rolagem de manufatura com dificuldade definida pelo mestre, se houver uma falha os recursos são destruídos. Materiais, custo e tempo de produção ficam a critério do mestre. <br><br><b>Nível 1:</b> Utilizando de algumas tintas e plantas, o personagem pode fazer uma camuflagem básica. Recebe um bônus de +1d6 de furtividade para a pessoa camuflada. São necessários 5 de mana para isso.<br><br><b>Nível 2:</b> A personagem pode melhorar a aparência natural de um jogador, dando um bônus de +1d6 em rolagens de performance ou sedução. O custo de mana será de 7. <br><br><b>Nível 3:</b> O jogador consegue fazer uma maquiagem capaz de modificar a aparência geral da pessoa de maneira que esta receba +1d6 em rolagens de mentira para se passar por outra pessoa. São necessários 2 de mana para isso.",
            },
            {
              name: "Coureiro",
              info: "Permite com que o jogador faça  armaduras moderadas. Materiais, custo e tempo de produção ficam a critério do mestre. <br><br><b>Nível 1:</b> Permite com que o personagem faça armaduras moderadas até nível 1 e com Prístino nível 1. <br><br><b>Nível 2:</b> Permite com que o personagem faça armaduras moderadas até nível 2 e com Prístino nível 2. <br><br><b>Nível 3:</b> Permite com que o personagem faça armaduras moderadas até nível 3 e com Prístino nível 3 e, toda armadura moderada feita pelo personagem, pode receber uma propriedade a escolha, caso tenha os materiais necessários.",
            },
            {
              name: "Encantamento",
              info: "Permite com que um item possa ser encantado pelo jogador, mediante uma rolagem de manufatura com dificuldade definida pelo mestre, se houver uma falha o item é destruído. Materiais, custo e tempo de produção ficam a critério do mestre. <br><br><b>Nível 1:</b> No primeiro nível, o jogador pode aplicar uma magia de uma essência no item de escolha. <br><br><b>Nível 2:</b> As magias podem ter até três essências no encantamento. <br><br><b>Nível 3:</b> O encantista pode agora encantar um item até 2 vezes.",
            },
            {
              name: "Escriba",
              info: "Permite com que o jogador fabrique e sele uma magia em um pergaminho de um uso. Mediante uma rolagem de manufatura com dificuldade definida pelo mestre, se houver uma falha o item é destruído. Materiais, custo e tempo de produção ficam a critério do mestre. Um pergaminho demanda muito mais tempo para sua fabricação. <br><br><b>Nível 1:</b> Permite o selamento de uma magia com 1 essência. <br><br><b>Nível 2:</b> Permite o selamento de uma magia com até 2 essências. <br><br><b>Nível 3:</b> Permite o selamento de uma magia com até 3 essências. O tempo de fabricação de um pergaminho é reduzido.",
            },
            {
              name: "Falsificação",
              info: "Permite com que o jogador fabrique documentos e/ou assinaturas falsificados. Mediante uma rolagem de manufatura com dificuldade definida pelo mestre, se houver uma falha o item é destruído. Materiais, custo e tempo de produção ficam a critério do mestre. <br><br><b>Nível 1:</b> Ao primeiro nível, o personagem pode efetuar uma rolagem para elaborar documentos simples que, ao serem apresentados a um personagem ou NPC. <br><br><b>Nível 2:</b> Ao segundo nível, o personagem pode elaborar assinaturas falsas e documentos mais robustos para apresentar. A personagem pode criar um documento falso de uso único que lhe garante +50 de Favor. <br><br><b>Nível 3:</b> No último nível, documentos utilizados em aristocracia, identidades, assinaturas e carimbos podem ser feitos pelo personagem de forma bem profissional. A personagem pode criar um notas promissórias falsas de uso único que lhe garantem 2d100 de gold.",
            },
            {
              name: "Ourives",
              info: "Permite com que o jogador possa fazer joias de diferentes níveis. Estas, são objetos que possuem encantamentos ou propriedades que podem ser usadas pela personagem. A confecção de uma joia exige materiais de alto padrão e alto grau de raridade, sendo, deixado a critério do mestre, o preço e método de obtenção. Recomendamos algo em torno de 10 vezes o preço de uma boa arma. Toda joia ocupa 1 slot. <br><br><b>Nível 1:</b> Permite o jogador fazer uma joia nível 1. Ela pode ter 1 encantamento (ver regras de Encantamento); <br><br><b>Nível 2:</b> O jogador pode fazer uma joia nível 2. Essa pode ter 1 propriedade (ver regras de Propriedade de Joias); <br><br><b>Nível 3:</b> No terceiro nível, o jogador pode criar joias nível 3. Essas podem ter uma encantamento e uma propriedade, simultaneamente.",
            },
          ],
          prestigios: [
            {
              name: "Artíficer",
              info: "Requisito: Manufatura. O personagem é um mestre artesão capaz de criar itens mágicos e artefatos complexos.",
            },
            {
              name: "Alquimia",
              info: "Requisito: Conhecimento ou Magia. O personagem é versado na arte da alquimia e criação de poções.",
            },
          ],
        },
        {
          label: "Combate",
          sectionId: "combate",
          onClick: "handleSectionClick('combate')",
          attribute: { label: "COM", dataAttribute: "com" },
          skills: [
            {
              name: "Acurácia",
              info: "Perícia responsável para desbloquear a capacidade de armas à distância. <br><br><b>Nível 1:</b>Permite o arremesso de armas leves de arremesso (ALA) com distância de até 15 metros. <br><br><b>Nível 2:</b>Bestas podem ser recarregadas com a ação de preparo, arcos pesados podem começar a acertar alvos a partir de 15 metros.  <br><br><b>Nível 3:</b>Permite com que o personagem possa atingir adversários até duas vezes a distância máxima de armas do tipo Arc ao custo de 5 de mana.",
            },
            {
              name: "Ambidestria",
              info: "Dita a capacidade do personagem no domínio do uso das duas mãos, permitindo com que ele possa utilizar duas armas, uma em cada uma de suas mãos. Também auxilia no desbloqueio das armas de tipo Arc e ArcP. <br><br><b>Nível 1:</b>Permite o uso de duas armas leves distintas simultaneamente pelo personagem. Para o combate, é possível utilizar a ação de reforço para desferir um golpe com a arma que esteja na segunda mão (sendo necessário um segundo teste de combate). Esse bônus não é válido para armas Arc. <br><br><b>Nível 2:</b>O personagem pode utilizar armas longas ou cortante/perfurante simples na mão dominante. Esse bônus não é válido para armas Arc.  <br><br><b>Nível 3:</b>O personagem pode usar sua reação e 1 ponto de mana para rolar o dado de dano de sua arma secundária, reduzindo o dano de um ataque corpo a corpo, não mágico, neste valor. Esse bônus não é válido para armas Arc. ",
            },
            {
              name: "Combate Improvisado",
              info: "Habilidade referente à capacidade de criar armas improvisadas ou então entrar em combate desarmado. <br><br><b>Nível 1:</b>O jogador usará 1d4 de dano para ataques desarmados. Além disso, o jogador pode utilizar objetos ao seu redor, como galhos, garrafas, pedras como armas improvisadas, essas armas dão 1d6 de dano e tem 1 uso <br><br><b>Nível 2:</b>O dano do jogador, para ataques desarmados, é aumentado para 2d4. O jogador ganha uma maior proficiência com armas improvisadas, fazendo com que essas causem 1d10 de dano e tenham 6 usos.  <br><br><b>Nível 3:</b>O dano para ataques desarmados torna-se 3d4. O jogador, ao realizar um ataque com arma improvisada, pode usar sua ação de reforço para realizar um novo ataque. ",
            },
            {
              name: "Esgrima",
              info: "Perícia que dita a capacidade de usar armas corpo a corpo leves do tipo CPS e CPP. Os bônus aqui presente são válidos apenas para esses tipo de arma. <br><br><b>Nível 1:</b>.Ataques com armas CPS e CPP aplicam, passivamente, 1 ponto de sangramento se houver sucesso (só pode ocorrer 1 vez por turno). <br><br><b>Nível 2:</b>Remove a restrição de turno do nível anterior.  <br><br><b>Nível 3:</b>O personagem pode realizar um ataque lesionante ao custo de 10 pontos de mana. Caso o ataque seja bem sucedido, o jogador deverá rolar 1d100 e averiguar a lesão. ",
            },
            {
              name: "Longa Vista",
              info: "Utilizada para desbloquear armas dos tipos AL e LP. Os bônus aqui presente são válidos apenas para esses tipo de arma. <br><br><b>Nível 1:</b>Recebe +1.5 metro de área de ameaça. <br><br><b>Nível 2:</b>O jogador pode utilizar da sua ação de reforço para realizar um ataque de pomo em outro alvo que causa 1d6 de dano.  <br><br><b>Nível 3:</b>Ataques com armas AL e LP queimam a reação do alvo. ",
            },
            {
              name: "Oportunista",
              info: "Perícia que é usada para garantir ataques de oportunidade ao jogador uma vez que um monstro/adversário fuja/entre do seu raio de ataque. <br><br><b>Nível 1:</b>Desbloqueia a reação do ataque de oportunidade para ataques corpo a corpo. <br><br><b>Nível 2:</b>Desbloqueia a reação do ataque de oportunidade para armas ranged, este não pode acontecer caso você esteja no raio de ameaça de uma criatura inimiga.  <br><br><b>Nível 3:</b>Desbloqueia a reação do ataque de oportunidade para magias individuais e touch, essa reação não pode ser usada caso você esteja no raio de ameaça de uma criatura inimiga.",
            },
            {
              name: "Bimanual",
              info: "Implica na capacidade do jogador de desbloquear armas do tipo CDM, PDM, CPP, LP e auxilia no desbloqueio da Best. Os bônus aqui presente são válidos apenas para esses tipo de arma. <br><br><b>Nível 1:</b>O raio de ameaça do jogador aumenta em 1.5 metro, exceto para Best e CDM. <br><br><b>Nível 2:</b>Reduz o slot das armas citadas em 1.  <br><br><b>Nível 3:</b>Permite gastar a ação de movimento e 4 de mana para aumentar o dano da arma em 1 dado de dano do nível 1 da sua arma até o seu próximo turno. ",
            },
          ],
          prestigios: [
            {
              name: "Marcial",
              info: "Requisito: Combate. O personagem é um mestre em artes marciais e técnicas de combate avançadas.",
            },
            {
              name: "Furioso",
              info: "Requisito: Atletismo. O personagem pode entrar em fúria de batalha, aumentando significativamente suas habilidades físicas.",
            },
          ],
        },
        {
          label: "Sobrevivência",
          sectionId: "sobrevivencia",
          onClick: "handleSectionClick('sobrevivencia')",
          attribute: { label: "SOB", dataAttribute: "sob" },
          skills: [
            {
              name: "Acampamento",
              info: "Mede o conhecimento do personagem em montar estruturas para um acampamento. <br><br><b>Nível 1:</b> O personagem é capaz de montar pequenas armadilhas para captura de animais pequenos, gastando 40 minutos para tal. Garante 1 ração. <br><br><b>Nível 2:</b> A personagem pode montar um acampamento de alto nível, gastando 2 horas para poder escolher uma condição e remover 1 ponto dela. As condições incluem: Exaustão, Insanidade ou Envenenado. <br><br><b>Nível 3:</b> Um acampamento de alto padrão pode ser realizado, mantendo o efeito do nível 2 e adicionando o ganho de 1 ponto de Honrado pelo remanescente do dia, ao custo de 2 horas de preparo e 1000 de gold em materiais.",
            },
            {
              name: "Adestramento",
              info: "Dita a capacidade do personagem de discernir as intenções ou maneirismos de um animal. <br><br><b>Nível 1:</b> Flat bônus de +3 para entender o comportamento ou se comunicar com animais. Animais domésticos gostam muito do seu personagem. <br><br><b>Nível 2:</b> Aumenta o flat bônus para +5 em rolagens desta perícia. A personagem pode chamar sua montaria em um raio de 3 km. <br><br><b>Nível 3:</b> Criaturas convencionais não são agressivas contra o jogador (averiguar com o mestre quais se enquadram nesse critério).",
            },
            {
              name: "Arrombamento",
              info: "Mede a capacidade do personagem em destravar trancas, cadeados ou mecanismos. A ausência de qualquer ponto nessa perícia garante que, qualquer ganzua usada, e o teste seja uma falha, será consumido. <br><br><b>Nível 1:</b> Para qualquer rolagem de natureza de ganzua recebe um bônus de +3 na rolagem. <br><br><b>Nível 2:</b> O bônus é aumentado para +5 e é possível tentar abrir baús com fechaduras mágicas (a critério do mestre). <br><br><b>Nível 3:</b> O jogador pode abrir qualquer baú de fechadura não mágica sem realizar um teste. Fora isso, o jogador também não ativa mecanismos de alarme ou armadilhas (isso incluí baús mímicos, que são considerados mágicos).",
            },
            {
              name: "Bater Carteira",
              info: "Perícia utilizada para que um personagem possa roubar um NPC ou outro personagem de maneira furtiva. <br><br><b>Nível 1:</b> Para qualquer rolagem de natureza de bater carteira recebe um bônus de +3 na rolagem. <br><br><b>Nível 2:</b> Aumento do bônus de rolagem para +5. Fora isso você também pode andar pelas ruas e, sem realizar rolagens, roubar ouro das pessoas que ficam andando (a quantia de ouro é definida pelo mestre). <br><br><b>Nível 3:</b> Libera a possibilidade de fazer testes de bater carteira para implantar objetos nos outros ao invés de rouba-los.",
            },
            {
              name: "Cozinhar",
              info: "Dita a capacidade gastronômica do personagem. <br><br><b>Nível 1:</b> O personagem será capaz de, sem um kit de cozinha, produzir rações que possuem 2 usos. Para tal, será necessário algum tipo de matéria prima, tal como carne, farinha, etc. As rações duplicadas não podem ser duplicadas novamente. <br><br><b>Nível 2:</b>A personagem pode converter uma ração para que ela seja ou uma ração de vida ou uma ração de mana, permitindo que ela recupere pontos de vida ou mana. Gastando 5 de mana para realizar a conversão;<br>Ração de Vida: Permite com que quem a coma ganhe até 1d10 de vida.<br>Ração de Mana: Permite com que quem a coma ganhe até 1d6 de mana.  <br><br><b>Nível 3:</b>A sua personagem é um grande mestre cuca, podendo cozinhar um banquete que revigora os aliados que o consomem. O banquete consome 5 de mana.<br>Banquete: O banquete recupera 6d6 pontos de vida de todos que o consomem, o tempo de preparo é de 1 hora e exige uma ração por participante. ",
            },
            {
              name: "Furtividade",
              info: "Perícia que mede o quão bem o seu personagem é capaz de se manter oculto e/ou omisso em um dado ambiente. <br><br><b>Nível 1:</b> Para cada rolagem que enfoque em ficar furtivo, se esconder, recebe um bônus de +3 na rolagem. <br><br><b>Nível 2:</b> O bônus é aumentado para +5 e em áreas com alta densidade populacional o bônus torna-se +7.  <br><br><b>Nível 3:</b> Todos os aliados que estejam fazendo um teste de furtividade com o jogador e não possuam nenhum ponto na perícia recebem o bônus de +3 na rolagem.",
            },
            {
              name: "Improviso",
              info: "Habilidade para que o personagem seja capaz de gerar um leve improviso em uma situação, gerando-lhe algum tipo de vantagem menor. <br><br><b>Nível 1:</b> Uma vez por dia pode-se adicionar 1d6 para qualquer rolagem sua. <br><br><b>Nível 2:</b> Duas vezes por dia pode-se adicionar 1d6 para qualquer rolagem sua. <br><br><b>Nível 3:</b> Três vezes por dia pode-se adicionar 1d6 para qualquer rolagem sua.",
            },
            {
              name: "Montar Armadilhas",
              info: "Dita a capacidade do personagem em montar armadilhas para capturar pessoas ou animais. <br><br><b>Nível 1:</b> Com os conhecimentos de montagem de armadilha, a personagem pode montar um sistema de alarme ao redor de uma área. Custando 1 de gold por 15 metros quadrados. Uma criatura que adentrar essa área soará um alarme sonoro. <br><br><b>Nível 2:</b> Uma personagem pode gastar 1 dia para realizar fortificações ao redor de uma área. A personagem e seus aliados terão +2 de AD em combates dentro da área fortificada. A personagem gasta 5 de gold por 10 metros quadrados. <br><br><b>Nível 3:</b> Uma personagem pode gastar mais um dia para que suas fortificações sejam ainda mais poderosas. A personagem e seus aliados terão +1d6 em rolagens de combate dentro da área. A área afetada deve ser a mesma da área fortificada e custará 50 de gold por 10 metros quadrados.",
            },
            {
              name: "Montaria",
              info: "Uma perícia utilizada para poder averiguar o quão bem o personagem consegue se conectar com sua montaria. <br><br><b>Nível 1:</b> Ao primeiro nível, o personagem cria facilidade em ter animais não mágicos de médio porte de maior velocidade, permitindo com que ele possa ter animais de até 30 m em velocidade de corrida (ex: cavalo).<br><br><b>Nível 2:</b> A capacidade de criar vínculos se torna mais intensa, isso permite com que se possa ter animais de grande porte (como elefantes), ou então animais ainda mais rápidos de movimentação até 60 m. <br><br><b>Nível 3:</b> Por fim, o personagem consegue se conectar tão bem com os animais que pode ter uma montaria mágica ou alada. Isso permite também que ele possa ter montarias que cheguem a velocidades muito altas de 90 m.",
            },
            {
              name: "Rastreio",
              info: "Perícia para medir como o personagem consegue rastrear outras criaturas ou pessoas, obtendo informações sobre seus rastros. <br><br><b>Nível 1:</b> Para qualquer rolagem de natureza de rastreio recebe um bônus de +3 na rolagem. <br><br><b>Nível 2:</b> Aumento do bônus de rolagem para +5, junto a isso você pode escolher uma dentre as seguintes classes: animais, humanoide ou seres mágicos e o seu bônus será de +7. <br><br><b>Nível 3:</b> Seu personagem marca um alvo e é capaz de saber com clareza para onde ele foi dentro de uma distância de 10 km.",
            },
            {
              name: "Percepção",
              info: "Mede a capacidade do jogador em perceber seus arredores e mudanças no ambiente ao qual ele se encontra. <br><br><b>Nível 1:</b> Para qualquer rolagem de natureza de percepção recebe um bônus de +3 na rolagem. <br><br><b>Nível 2:</b> Aumento do bônus de rolagem para +5. <br><br><b>Nível 3:</b> Aumento do bônus de rolagem para +7 e o bônus aumenta para +10 se for percepção de armadilha.",
            },
            {
              name: "Vontade",
              info: "A vontade é uma perícia que implica na capacidade psicológica do personagem em suportar situações de estresse tão bem como efeitos que sejam da psique. <br><br><b>Nível 1:</b> O primeiro ponto de insanidade obtido no dia é negado. <br><br><b>Nível 2:</b> O jogador poderá gastar uma ação de reforço e 5 pontos de mana para remover 1d4 dentre as seguintes condições: confusão, encantado, medo, paralisado, triste ou moral. <br><br><b>Nível 3:</b> O personagem pode escolher um dentre as seguintes condições para ter imunidade: atordoado, confusão, encantado, hipnotizado, medo ou triste. Fora isso, o primeiro ponto de insanidade não possuí efeito.",
            },
          ],
          prestigios: [
            {
              name: "Companheiro Animal",
              info: "Requisito: Sobrevivência. O personagem possui um companheiro animal leal que o auxilia em aventuras.",
            },
            {
              name: "Mestre de Venenos",
              info: "Requisito: Conhecimento. O personagem é um especialista em criar e utilizar venenos.",
            },
          ],
        },

        {
          label: "Magia",
          sectionId: "magia",
          onClick: "handleSectionClick('magia')",
          attribute: { label: "MAG", dataAttribute: "mag" },
          skills: [
            {
              name: "Bênçãos",
              info: "Explicita a habilidade inata do personagem em essências do hemisfério de Vida. <br><br><b>Nível 1:</b>Desbloqueia a essência de Vita. <br><br><b>Nível 2:</b>Magias feitas apenas com a essência de Vita recebem um modificador de 0.75 no custo final de mana.  <br><br><b>Nível 3:</b>Aumenta o dado natural de cura da essência de Vita para 1d6. ",
            },
            {
              name: "Conjuração",
              info: "Explicita a habilidade inata do personagem em essências do hemisfério de Conjuração. <br><br><b>Nível 1:</b>Desbloqueia a essência de Forma. <br><br><b>Nível 2:</b>O jogador recebe uma dimensão de bolso que o segue a todo lugar, garantindo 5 slots extras em seu interior.  <br><br><b>Nível 3:</b>A personagem pode analisar um item, cujo valor máximo seja de 1000 de gold, e estuda-lo por 30 minutos. Após isso, ela cria uma replica do item estudado. O valor de mana gasto será o preço do item divido por 10. O item dura por 1 dia. ",
            },
            {
              name: "Contra-Feitiço",
              info: "Explicita a habilidade do personagem usar sua ação de reação para bloquear a execução de uma magia ou um outro contra-feitiço. <br><br><b>Nível 1:</b>A personagem pode, ao ver a execução de uma magia, utilizar sua reação e 15 de MP para negar essa ativação. Essa habilidade só pode ser utilizada 1 vez por dia. <br><br><b>Nível 2:</b>Reduz o preço de mana para 5 MP.  <br><br><b>Nível 3:</b>A personagem pode utilizar um contra-feitiço até 2 vezes por dia. ",
            },

            {
              name: "Energia",
              info: "Explicita a habilidade inata do personagem em essências do hemisfério de Energia. <br><br><b>Nível 1:</b>Desbloqueia a essência de Ignis. <br><br><b>Nível 2:</b>Magias feitas apenas com a essência de Ignis recebem um modificador de 0.75 no custo final de mana.  <br><br><b>Nível 3:</b>Desbloqueia a essência de Fax. ",
            },
            {
              name: "Feitiçaria",
              info: "Melhora a produção de magias pelo personagem, barateando as magias por ele produzidas. <br><br><b>Nível 1:</b>Adiciona um modificador de 0.95 de preço de mana. <br><br><b>Nível 2:</b>Amplifica o modificador para 0.9 de preço de mana.  <br><br><b>Nível 3:</b>Intensifica ainda mais o modificador para 0.85 de preço de mana. ",
            },
            {
              name: "Ilusionismo",
              info: "Explicita a habilidade inata do personagem em essências do hemisfério de Ilusão. <br><br><b>Nível 1:</b>Desbloqueia a essência de Ambiens. <br><br><b>Nível 2:</b>Magias feitas apenas com a essência de Ambiens recebem um modificador de 0.75 no custo final de mana.  <br><br><b>Nível 3:</b>Desbloqueia a essência de Ego. ",
            },
            {
              name: "Invocador",
              info: "Permite com que o personagem tenha uma familiar e possa dar efeitos para ele. <br><br><b>Nível 1:</b>Invoca o familiar com aspecto da escolha do jogador e escolhe 1 habilidade da tabela. <br><br><b>Nível 2:</b>Pode escolher mais uma habilidade.  <br><br><b>Nível 3:</b>Permite escolher a terceira habilidade, o jogador substituir uma das habilidade escolhidas anteriormente. ",
            },
            {
              name: "Ocultismo",
              info: "Explicita a habilidade inata do personagem em essências do hemisfério de Morte. <br><br><b>Nível 1:</b>Desbloqueia a essência de Corruptio. <br><br><b>Nível 2:</b>O jogador pode realizar um ritual que leva 10 minutos, usando o corpo de um alvo e 7 pontos de mana para que este possa realizar 3 perguntas a um alvo que esteja morto. O alvo deve responder as perguntas verdadeiramente.  <br><br><b>Nível 3:</b>O jogador pode escolher um alvo a até 60 metros e definir uma quantia de até 50 MP a queimar, a quantia escolhida será aplicada na forma de dano necrótico contra o alvo. ",
            },
            {
              name: "Shamanismo",
              info: "Explicita a habilidade inata do personagem em essências do hemisfério Material. <br><br><b>Nível 1:</b>O jogador pode escolher uma dentre as seguintes essências para desbloquear: Aqua, Terra ou Aer. <br><br><b>Nível 2:</b>Magias feitas apenas com a essência escolhida recebem um modificador de 0.75 no custo final de mana.  <br><br><b>Nível 3:</b> O jogador pode transmutar metal em ouro. Serão gastos 1 de mana para converter 10 gramas de um metal em uma moeda de ouro.",
            },
          ],
          prestigios: [
            {
              name: "Acadêmico",
              info: "Requisito: Magia. O personagem tem conhecimento acadêmico avançado em áreas mágicas e teóricas.",
            },
            {
              name: "Alquimia",
              info: "Requisito: Conhecimento ou Magia. O personagem é versado na arte da alquimia e criação de poções.",
            },
          ],
        },
      ];

      // Roll functions for attributes and skills
      function rollAttribute(attributeKey, attributeName) {
        const attributeInput = document.querySelector(
          `input[data-attribute="${attributeKey}"]`
        );
        if (!attributeInput) {
          alert(`Atributo ${attributeName} não encontrado!`);
          return;
        }

        const attributeLevel = parseInt(attributeInput.value) || 0;

        // Roll dice based on attribute level
        const diceCount = attributeLevel + 2; // +2 for base dice
        const rolls = [];

        for (let i = 0; i < diceCount; i++) {
          rolls.push(Math.floor(Math.random() * 6) + 1);
        }

        const total = rolls.reduce((sum, roll) => sum + roll, 0);
        const result = `🎲 ${attributeName} (${diceCount}d6): [${rolls.join(
          ", "
        )}] = ${total}`;

        // Display result (you can customize this)
        alert(result);
        console.log(result);
      }

      function rollSkill(sectionId, skillName) {
        // Find the skill configuration
        const config = skillSectionsConfig.find(
          (c) => c.sectionId === sectionId
        );
        if (!config || !config.attribute) {
          alert(`Configuração não encontrada para ${skillName}!`);
          return;
        }

        // Get attribute level
        const attributeInput = document.querySelector(
          `input[data-attribute="${config.attribute.dataAttribute}"]`
        );
        if (!attributeInput) {
          alert(`Atributo ${config.attribute.label} não encontrado!`);
          return;
        }
        const attributeLevel = parseInt(attributeInput.value) || 0;

        // Get skill level
        const skillContainer = document.querySelector(
          `[data-skill="${skillName}"][data-section="${sectionId}"]`
        );
        if (!skillContainer) {
          alert(`Habilidade ${skillName} não encontrada!`);
          return;
        }

        const levelCheckboxes = skillContainer.querySelectorAll(
          ".skill-level:checked"
        );
        let skillLevel = 0;
        levelCheckboxes.forEach((checkbox) => {
          const level = parseInt(checkbox.dataset.level);
          if (level > skillLevel) skillLevel = level;
        });

        // TODO Implement skill adapter
        const flatBonus = 0; // Placeholder for flat bonus logic

        const diceCount = attributeLevel + 2; // +2 for base dice
        const rolls = [];

        for (let i = 0; i < diceCount; i++) {
          rolls.push(Math.floor(Math.random() * 6) + 1);
        }

        const flatBonusString = flatBonus > 0 ? ` + ${flatBonus}` : "";

        // Calculate total dice (attribute + skill)
        const total = rolls.reduce((sum, roll) => sum + roll, 0) + flatBonus;
        const result = `🎲 ${skillName} (${diceCount}d6): [${rolls.join(
          ", "
        )}] ${flatBonusString} = ${total}`;

        // Display result (you can customize this)
        alert(result);
        console.log(result);
      }

      // Roll function for resource dice (HP, Mana, etc.)
      function rollResourceDice(resourceName, diceSelectId) {
        const diceSelect = document.getElementById(diceSelectId);
        if (!diceSelect) {
          alert(`Seletor de dado para ${resourceName} não encontrado!`);
          return;
        }

        const level =
          parseInt(document.getElementById("character-level")?.textContent) ||
          0;
        const diceType = diceSelect.value;
        const diceSides = parseInt(diceType.substring(1)); // Remove 'd' and get number

        if (level === 0) {
          // Level 0: Set base to maximum dice value
          const maxValue = diceSides;
          initializeResourceBase(resourceName, maxValue, diceType);

          const result = `🎲 ${resourceName} (Nível 0): Base inicializada com valor máximo ${maxValue}`;
          alert(result);
          console.log(result);
        } else {
          // Level 1+: Show confirmation and clear automatic history
          const confirmMessage = `Isso irá substituir todos os rolls automáticos com rolls manuais.\n\nDeseja continuar e rolar manualmente para ${resourceName}?`;
          if (!confirm(confirmMessage)) {
            return;
          }

          // Clear existing history and start fresh with manual rolls
          clearResourceHistoryAndStartManual(resourceName, diceType, level);
        }
      }

      // Function to clear automatic history and start manual rolling
      function clearResourceHistoryAndStartManual(
        resourceName,
        diceType,
        currentLevel
      ) {
        const config = resourceSectionsConfig.find(
          (c) => c.resourceName === resourceName
        );
        if (!config) return;

        // Start fresh history - keep only level 0 if it exists
        const existingHistory = getResourceRollHistory(resourceName);
        const level0Entry = existingHistory.find((entry) => entry.level === 0);

        let newHistory = [];
        let baseValue = 0;

        if (level0Entry) {
          // Keep level 0 initialization
          newHistory.push(level0Entry);
          baseValue = level0Entry.roll;
        } else {
          // Create level 0 entry with max dice value
          const diceSides = parseInt(diceType.substring(1));
          const maxValue = diceSides;
          newHistory.push({
            level: 0,
            roll: maxValue,
            diceType: diceType,
            description: `Nível 0: Valor máximo do ${diceType}`,
          });
          baseValue = maxValue;
        }

        // Now roll manually for each level from 1 to current level
        for (let level = 1; level <= currentLevel; level++) {
          const diceSides = parseInt(diceType.substring(1));
          const roll = Math.floor(Math.random() * diceSides) + 1;
          baseValue += roll;

          newHistory.push({
            level: level,
            roll: roll,
            diceType: diceType,
            description: `Nível ${level}: Rolou ${roll} no ${diceType} (manual)`,
          });
        }

        // Update the base input
        const baseInput = document.getElementById(config.baseId);
        if (baseInput) {
          baseInput.value = baseValue;
        }

        // Save the new manual history
        saveResourceRollHistory(resourceName, newHistory);

        // Show summary of manual rolls
        showManualRollSummary(
          resourceName,
          newHistory.filter((entry) => entry.level > 0)
        );

        // Recalculate total
        calculateResourceTotal(resourceName);
      }

      // Function to show summary of manual rolls
      function showManualRollSummary(resourceName, manualRolls) {
        if (manualRolls.length === 0) return;

        let summary = `🎲 Rolls Manuais - ${resourceName}:\n\n`;
        let totalGained = 0;

        manualRolls.forEach((roll) => {
          summary += `Nível ${roll.level}: Rolou ${roll.roll} no ${roll.diceType}\n`;
          totalGained += roll.roll;
        });

        summary += `\nTotal ganho nos rolls: +${totalGained}`;
        summary += `\nHistórico automático foi substituído pelos rolls manuais.`;

        alert(summary);
      }

      // Function to initialize base resource at level 0
      function initializeResourceBase(resourceName, baseValue, diceType) {
        const config = resourceSectionsConfig.find(
          (c) => c.resourceName === resourceName
        );
        if (!config) return;

        const baseInput = document.getElementById(config.baseId);
        if (baseInput) {
          baseInput.value = baseValue;
        }

        // Initialize roll history
        const rollHistory = [
          {
            level: 0,
            roll: baseValue,
            diceType: diceType,
            description: `Nível 0: Valor máximo do ${diceType}`,
          },
        ];

        // Save roll history to resource data
        saveResourceRollHistory(resourceName, rollHistory);

        // Recalculate total
        calculateResourceTotal(resourceName);
      }

      // Function to roll dice and add to resource base
      function rollAndAddToResource(resourceName, diceType, level) {
        const config = resourceSectionsConfig.find(
          (c) => c.resourceName === resourceName
        );
        if (!config) return;

        const baseInput = document.getElementById(config.baseId);
        if (!baseInput) return;

        const diceSides = parseInt(diceType.substring(1));
        const roll = Math.floor(Math.random() * diceSides) + 1;
        const currentBase = parseInt(baseInput.value) || 0;
        const newBase = currentBase + roll;

        baseInput.value = newBase;

        // Get existing roll history and add new roll
        const existingHistory = getResourceRollHistory(resourceName);
        existingHistory.push({
          level: level,
          roll: roll,
          diceType: diceType,
          description: `Nível ${level}: Rolou ${roll} no ${diceType}`,
        });

        saveResourceRollHistory(resourceName, existingHistory);

        const result = `🎲 ${resourceName} (Nível ${level}): Rolou ${roll} no ${diceType}. Base: ${currentBase} + ${roll} = ${newBase}`;
        alert(result);
        console.log(result);

        // Recalculate total
        calculateResourceTotal(resourceName);
      }

      // Function to save resource roll history
      function saveResourceRollHistory(resourceName, rollHistory) {
        const key = `fac_09_${resourceName.toLowerCase()}_roll_history`;
        try {
          localStorage.setItem(key, JSON.stringify(rollHistory));
        } catch (error) {
          console.error(
            `Error saving roll history for ${resourceName}:`,
            error
          );
        }
      }

      // Function to get resource roll history
      function getResourceRollHistory(resourceName) {
        const key = `fac_09_${resourceName.toLowerCase()}_roll_history`;
        try {
          const history = localStorage.getItem(key);
          return history ? JSON.parse(history) : [];
        } catch (error) {
          console.error(
            `Error loading roll history for ${resourceName}:`,
            error
          );
          return [];
        }
      }

      // Function to show resource roll history
      function showResourceRollHistory(resourceName) {
        const history = getResourceRollHistory(resourceName);

        if (history.length === 0) {
          alert(`Nenhum histórico de rolls encontrado para ${resourceName}.`);
          return;
        }

        let historyText = `Histórico de Rolls - ${resourceName}:\n\n`;
        let total = 0;

        history.forEach((entry, index) => {
          historyText += `${entry.description}\n`;
          total = index === 0 ? entry.roll : total + entry.roll;
        });

        historyText += `\nTotal Base: ${total}`;

        alert(historyText);
      }

      // Function to show summary of automatic rolls
      function showAutoRollSummary(levelsRolled) {
        if (levelsRolled.length === 0) return;

        let summary = `🎲 Rolls Automáticos - Níveis ${levelsRolled.join(
          ", "
        )}:\n\n`;

        resourceSectionsConfig.forEach((config) => {
          const history = getResourceRollHistory(config.resourceName);
          const levelRolls = history.filter((entry) =>
            levelsRolled.includes(entry.level)
          );

          if (levelRolls.length > 0) {
            summary += `${config.resourceName}:\n`;
            levelRolls.forEach((roll) => {
              summary += `  Nível ${roll.level}: ${roll.roll} no ${roll.diceType}\n`;
            });

            // Calculate total gained
            const totalGained = levelRolls.reduce(
              (sum, roll) => sum + roll.roll,
              0
            );
            summary += `  Total ganho: +${totalGained}\n\n`;
          }
        });

        summary += `Clique no botão "📋 Histórico" para ver todos os rolls detalhados.`;
        alert(summary);
      }

      // Function called when dice type changes
      function onDiceTypeChange(resourceName) {
        // Always trigger resource recalculation when dice type changes, clearing history
        updateResourceBaseValues(true); // true indicates dice type changed

        // Always trigger auto-save when dice type changes
        clearTimeout(window.saveTimeout);
        window.saveTimeout = setTimeout(() => {
          saveCharacterDataToStorage();
        }, 500);
      }

      // Single comprehensive function to handle all resource base calculations
      function updateResourceBaseValues(diceTypeChanged = false) {
        const currentLevel =
          parseInt(document.getElementById("character-level")?.textContent) ||
          0;

        console.log(
          `Updating resource base values for level ${currentLevel}${
            diceTypeChanged ? " (dice type changed)" : ""
          }`
        );

        resourceSectionsConfig.forEach((config) => {
          const diceSelect = document.getElementById(config.diceSelectId);
          const baseInput = document.getElementById(config.baseId);

          if (!diceSelect || !baseInput) return;

          const diceType = diceSelect.value;
          const diceSides = parseInt(diceType.substring(1));

          // Get existing roll history
          let rollHistory = getResourceRollHistory(config.resourceName);

          // If dice type changed, check if we need to clear history
          if (diceTypeChanged && rollHistory.length > 0) {
            // Check if the existing history has different dice types
            const existingDiceType = rollHistory[0]?.diceType;
            if (existingDiceType && existingDiceType !== diceType) {
              console.log(
                `Dice type changed from ${existingDiceType} to ${diceType} for ${config.resourceName}, clearing history`
              );
              rollHistory = []; // Clear the history
              localStorage.setItem(
                `fac_09_${config.resourceName.toLowerCase()}_roll_history`,
                JSON.stringify(rollHistory)
              );
            }
          }

          const existingLevels = new Set(
            rollHistory.map((entry) => entry.level)
          );

          // Ensure level 0 exists in history
          if (!existingLevels.has(0)) {
            const maxValue = diceSides;
            rollHistory.unshift({
              level: 0,
              roll: maxValue,
              diceType: diceType,
              description: `Nível 0: Valor máximo do ${diceType}`,
            });
            existingLevels.add(0);
            console.log(
              `Auto-initialized ${config.resourceName} level 0 with ${maxValue}`
            );
          }

          // Find and roll for missing levels from 1 to currentLevel
          const missingLevels = [];
          for (let level = 1; level <= currentLevel; level++) {
            if (!existingLevels.has(level)) {
              missingLevels.push(level);
            }
          }

          // Roll for missing levels
          missingLevels.forEach((level) => {
            const roll = Math.floor(Math.random() * diceSides) + 1;
            rollHistory.push({
              level: level,
              roll: roll,
              diceType: diceType,
              description: `Nível ${level}: Rolou ${roll} no ${diceType} (automático)`,
            });
            console.log(
              `🎲 ${config.resourceName} (Nível ${level}): Rolou ${roll} no ${diceType}`
            );
          });

          // Sort history by level
          rollHistory.sort((a, b) => a.level - b.level);

          // Calculate base value up to current level
          let calculatedBase = 0;
          rollHistory.forEach((entry) => {
            if (entry.level <= currentLevel) {
              if (entry.level === 0) {
                calculatedBase = entry.roll; // Level 0 sets the base
              } else {
                calculatedBase += entry.roll; // Subsequent levels add to base
              }
            }
          });

          // Update the base input
          baseInput.value = calculatedBase;
          console.log(
            `Updated ${config.resourceName} base to ${calculatedBase} (up to level ${currentLevel})`
          );

          // Save updated roll history (only if we added new rolls)
          if (missingLevels.length > 0) {
            saveResourceRollHistory(config.resourceName, rollHistory);
          }

          // Recalculate total after base update
          calculateResourceTotal(config.resourceName);
        });
      }

      // Level editing functions
      function editLevel(element) {
        // Store current level before editing for comparison
        element.dataset.previousLevel = element.textContent;

        element.focus();
        // Select all text when clicking to edit
        if (window.getSelection && document.createRange) {
          const range = document.createRange();
          range.selectNodeContents(element);
          const selection = window.getSelection();
          selection.removeAllRanges();
          selection.addRange(range);
        }
      }

      function saveLevel(element) {
        const previousLevel = parseInt(element.dataset.previousLevel) || 0;
        let level = parseInt(element.textContent) || 0;
        if (level < 0) level = 0;
        if (level > 20) level = 20; // Set a reasonable max level
        element.textContent = level;

        // Store the new level for next comparison
        element.dataset.previousLevel = level;

        console.log(`Level changed from ${previousLevel} to ${level}`);

        // Update available points when level changes
        updateMaxPointsOnLevelUp();

        // Update dice selector availability based on new level
        updateDiceSelectorAvailability();

        // Update all resource base values for the new level
        updateResourceBaseValues(false); // false indicates level change, not dice type change

        // Trigger auto-save
        clearTimeout(window.saveTimeout);
        window.saveTimeout = setTimeout(() => {
          saveCharacterDataToStorage();
        }, 500);
      }
      function handleLevelKeypress(event, element) {
        // Allow only numbers and enter key
        if (event.key === "Enter") {
          element.blur();
          return false;
        }

        // Allow only digits, backspace, delete, arrow keys
        if (
          !/[\d]/.test(event.key) &&
          !["Backspace", "Delete", "ArrowLeft", "ArrowRight"].includes(
            event.key
          )
        ) {
          event.preventDefault();
          return false;
        }
      }

      // Function to update available points when leveling up
      function updateMaxPointsOnLevelUp() {
        // Currently empty as requested
        // This function will be used to calculate available points based on level progression

        // For now, calculate basic available points
        calculateAvailablePoints();
      }

      // Configuration for level progression
      const levelProgressionConfig = {
        // Skill points gained at each level (cumulative) - array index = level
        skillPointsPerLevel: [
          10, 1, 2, 2, 2, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 1, 2, 2, 2, 3, 3, 3, 4,
          4, 3, 2, 2, 2, 2, 1, 2, 2, 2, 3, 3, 3, 4, 4,
        ],
        // Attribute points: base 5 + 1 for every even level
        attributePointsBase: 5,
        attributePointsPerThreeLevels: 1,
      };

      // Function to calculate available points based on character level
      function calculateAvailablePoints() {
        const level =
          parseInt(document.getElementById("character-level").textContent) || 0;

        // Calculate attribute points: base + bonus for every 3 levels (excluding level 0)
        const threeLevelBonus =
          level > 0
            ? Math.floor(level / 3) *
              levelProgressionConfig.attributePointsPerThreeLevels
            : 0;
        const availableAttributePoints =
          levelProgressionConfig.attributePointsBase + threeLevelBonus;

        // Calculate cumulative skill points
        let availableSkillPoints = 0;

        // Sum up skill points from level 0 to current level
        for (let i = 0; i <= level; i++) {
          if (i < levelProgressionConfig.skillPointsPerLevel.length) {
            availableSkillPoints +=
              levelProgressionConfig.skillPointsPerLevel[i];
          }
          // If level goes beyond array size, ignore (no additional points)
        }

        // Update the display
        document.getElementById("attribute-available").textContent =
          availableAttributePoints;
        document.getElementById("skill-available").textContent =
          availableSkillPoints;

        return {
          attributes: availableAttributePoints,
          skills: availableSkillPoints,
        };
      }

      // Event handler for section clicks
      function handleSectionClick(sectionId) {
        console.log(`Section clicked: ${sectionId}`);

        // Example: Toggle section highlight
        const section = document.querySelector(`[data-section="${sectionId}"]`);
        if (section) {
          section.classList.toggle("highlighted");
        }

        // Custom logic can be added here for each section
        switch (sectionId) {
          case "social":
            console.log("Social skills section clicked");
            break;
          case "cultura":
            console.log("Cultura skills section clicked");
            break;
          case "atletismo":
            console.log("Atletismo skills section clicked");
            break;
          case "manual":
            console.log("Manual skills section clicked");
            break;
          case "combate":
            console.log("Combate skills section clicked");
            break;
          case "sobrevivencia":
            console.log("Sobrevivência skills section clicked");
            break;
          case "sistema_faq":
            console.log("Sistema FAQ section clicked");
            break;
          case "magia":
            console.log("Magia section clicked");
            break;
          case "recursos":
            console.log("Recursos section clicked");
            break;
          default:
            console.log("Unknown section clicked");
        }
      }

      // Function to save character data to localStorage
      function saveCharacterDataToStorage() {
        const data = saveCharacterData();
        try {
          localStorage.setItem("fac_09_character_sheet", JSON.stringify(data));
          console.log("Character data saved to localStorage");
        } catch (error) {
          console.error("Error saving to localStorage:", error);
        }
      }

      // Function to load character data from localStorage
      function loadCharacterDataFromStorage() {
        try {
          const savedData = localStorage.getItem("fac_09_character_sheet");
          if (savedData) {
            const data = JSON.parse(savedData);
            loadCharacterData(data);
            // Recalculate points after loading
            calculateTotalPoints();
            console.log("Character data loaded from localStorage");
            return true;
          }
        } catch (error) {
          console.error("Error loading from localStorage:", error);
        }
        return false;
      }

      // Function to clear saved character data
      function clearSavedCharacterData() {
        try {
          localStorage.removeItem("fac_09_character_sheet");
          localStorage.removeItem("fac_09_character_magics");
          // Clear roll histories for all resources
          resourceSectionsConfig.forEach((config) => {
            localStorage.removeItem(
              `fac_09_${config.resourceName.toLowerCase()}_roll_history`
            );
          });

          // Clear magic manager
          if (magicManager) {
            magicManager.magics = [];
            magicManager.renderMagicList();
          }

          // Clear essence selection state
          clearEssenceSelectionState();

          console.log("All saved character data cleared");
          alert("Todos os dados salvos foram removidos.");
        } catch (error) {
          console.error("Error clearing localStorage:", error);
        }
      }

      // Function to save character data to JSON
      function saveCharacterData() {
        const data = {
          characterName: document.querySelector(
            'input[placeholder="Nome do personagem"]'
          ).value,
          description: document.querySelector(
            'textarea[placeholder="Descrição do personagem..."]'
          ).value,
          level:
            parseInt(document.getElementById("character-level").textContent) ||
            0,
          attributes: {
            con:
              document.querySelector('input[data-attribute="con"]')?.value || 0,
            soc:
              document.querySelector('input[data-attribute="soc"]')?.value || 0,
            mag:
              document.querySelector('input[data-attribute="mag"]')?.value || 0,
            alt:
              document.querySelector('input[data-attribute="alt"]')?.value || 0,
            man:
              document.querySelector('input[data-attribute="man"]')?.value || 0,
            com:
              document.querySelector('input[data-attribute="com"]')?.value || 0,
            sob:
              document.querySelector('input[data-attribute="sob"]')?.value || 0,
            cul:
              document.querySelector('input[data-attribute="cul"]')?.value || 0,
          },
          skills: {},
          hp: {
            base: document.getElementById("hp-base")?.value || 0,
            extra: document.getElementById("hp-extra")?.value || 0,
            total: document.getElementById("hp-total")?.value || 0,
            current: document.getElementById("hp-current")?.value || 0,
            diceType: document.getElementById("hp-dice-select")?.value || "d6",
            rollHistory: getResourceRollHistory("HP"),
          },
          mana: {
            base: document.getElementById("mana-base")?.value || 0,
            extra: document.getElementById("mana-extra")?.value || 0,
            total: document.getElementById("mana-total")?.value || 0,
            current: document.getElementById("mana-current")?.value || 0,
            diceType:
              document.getElementById("mana-dice-select")?.value || "d6",
            rollHistory: getResourceRollHistory("Mana"),
          },
        };

        // Collect skill levels (1, 2, 3) instead of just checked/unchecked
        document.querySelectorAll(".skill-levels").forEach((skillContainer) => {
          const skillName = skillContainer.dataset.skill;
          const levelCheckboxes = skillContainer.querySelectorAll(
            ".skill-level:checked"
          );

          // Find the highest checked level for this skill
          let maxLevel = 0;
          levelCheckboxes.forEach((checkbox) => {
            const level = parseInt(checkbox.dataset.level);
            if (level > maxLevel) maxLevel = level;
          });

          data.skills[skillName] = maxLevel;
        });

        // Collect resources and inventory text
        const resourcesTextarea = document.querySelector(
          '[data-section="recursos"] textarea'
        );
        if (resourcesTextarea) {
          data.resources = resourcesTextarea.value;
        }

        const inventoryTextarea = document.querySelector(
          '.resources-section:not([data-section="recursos"]) textarea'
        );
        if (inventoryTextarea) {
          data.inventory = inventoryTextarea.value;
        }

        // Collect movement value
        const movementInput = document.getElementById("movement");
        if (movementInput) {
          data.movement = movementInput.value;
        }

        // Collect magics data
        if (magicManager) {
          data.magics = magicManager.getMagicsData();
        }

        // Collect current essence selection state
        data.currentEssenceSelection = getCurrentEssenceSelectionState();

        return data;
      }

      // Function to load character data from JSON
      function loadCharacterData(data) {
        if (data.characterName) {
          document.querySelector(
            'input[placeholder="Nome do personagem"]'
          ).value = data.characterName;
        }
        if (data.description) {
          document.querySelector(
            'textarea[placeholder="Descrição do personagem..."]'
          ).value = data.description;
        }

        // Load character level
        if (data.level !== undefined) {
          const levelElement = document.getElementById("character-level");
          if (levelElement) {
            levelElement.textContent = data.level;
            // Initialize previous level for future comparisons
            levelElement.dataset.previousLevel = data.level;
          }
        }

        // Load attributes
        Object.keys(data.attributes || {}).forEach((attr) => {
          const input = document.querySelector(
            `input[data-attribute="${attr}"]`
          );
          if (input) input.value = data.attributes[attr];
        });

        // Load skills with levels
        Object.keys(data.skills || {}).forEach((skillName) => {
          const skillLevel = data.skills[skillName];
          const skillContainer = document.querySelector(
            `[data-skill="${skillName}"].skill-levels`
          );

          if (skillContainer && skillLevel > 0) {
            // Check all levels up to the saved level
            for (let level = 1; level <= skillLevel; level++) {
              const checkbox = skillContainer.querySelector(
                `input[data-level="${level}"]`
              );
              if (checkbox) checkbox.checked = true;
            }
          }
        });

        // Load resources
        if (data.resources !== undefined) {
          const resourcesTextarea = document.querySelector(
            '[data-section="recursos"] textarea'
          );
          if (resourcesTextarea) {
            resourcesTextarea.value = data.resources;
          }
        }

        // Load inventory
        if (data.inventory !== undefined) {
          const inventoryTextarea = document.querySelector(
            '.resources-section:not([data-section="recursos"]) textarea'
          );
          if (inventoryTextarea) {
            inventoryTextarea.value = data.inventory;
          }
        }

        // Load movement
        if (data.movement !== undefined) {
          const movementInput = document.getElementById("movement");
          if (movementInput) {
            movementInput.value = data.movement;
          }
        }

        // Load HP and Mana values
        if (data.hp) {
          if (data.hp.base !== undefined) {
            const hpBaseInput = document.getElementById("hp-base");
            if (hpBaseInput) hpBaseInput.value = data.hp.base;
          }
          if (data.hp.extra !== undefined) {
            const hpExtraInput = document.getElementById("hp-extra");
            if (hpExtraInput) hpExtraInput.value = data.hp.extra;
          }
          if (data.hp.total !== undefined) {
            const hpTotalInput = document.getElementById("hp-total");
            if (hpTotalInput) hpTotalInput.value = data.hp.total;
          }
          if (data.hp.current !== undefined) {
            const hpCurrentInput = document.getElementById("hp-current");
            if (hpCurrentInput) hpCurrentInput.value = data.hp.current;
          }
          if (data.hp.diceType !== undefined) {
            const hpDiceSelect = document.getElementById("hp-dice-select");
            if (hpDiceSelect) hpDiceSelect.value = data.hp.diceType;
          }
          if (data.hp.rollHistory !== undefined) {
            saveResourceRollHistory("HP", data.hp.rollHistory);
          }
        }

        if (data.mana) {
          if (data.mana.base !== undefined) {
            const manaBaseInput = document.getElementById("mana-base");
            if (manaBaseInput) manaBaseInput.value = data.mana.base;
          }
          if (data.mana.extra !== undefined) {
            const manaExtraInput = document.getElementById("mana-extra");
            if (manaExtraInput) manaExtraInput.value = data.mana.extra;
          }
          if (data.mana.total !== undefined) {
            const manaTotalInput = document.getElementById("mana-total");
            if (manaTotalInput) manaTotalInput.value = data.mana.total;
          }
          if (data.mana.current !== undefined) {
            const manaCurrentInput = document.getElementById("mana-current");
            if (manaCurrentInput) manaCurrentInput.value = data.mana.current;
          }
          if (data.mana.diceType !== undefined) {
            const manaDiceSelect = document.getElementById("mana-dice-select");
            if (manaDiceSelect) manaDiceSelect.value = data.mana.diceType;
          }
          if (data.mana.rollHistory !== undefined) {
            saveResourceRollHistory("Mana", data.mana.rollHistory);
          }
        }

        // Revalidate and recalculate after loading
        // Update skill availability for all sections based on loaded attribute values
        skillSectionsConfig.forEach((config) => {
          if (config.attribute) {
            const attributeInput = document.querySelector(
              `input[data-attribute="${config.attribute.dataAttribute}"]`
            );
            const attributeValue = attributeInput
              ? parseInt(attributeInput.value) || 0
              : 0;
            updateSkillAvailability(config.sectionId, attributeValue);
          }
        });

        // Update available points first, then calculate totals
        calculateAvailablePoints();
        validateAttributeAndSkills();
        calculateTotalPoints();

        // Recalculate resource totals after loading
        resourceSectionsConfig.forEach((config) => {
          calculateResourceTotal(config.resourceName);
        });

        // Load magics data
        if (data.magics && magicManager) {
          magicManager.loadMagicsData(data.magics);
        }

        // Load current essence selection state
        if (data.currentEssenceSelection) {
          loadEssenceSelectionState(data.currentEssenceSelection);
        }

        // Update dice selector availability based on loaded level
        updateDiceSelectorAvailability();
      }

      // Add CSS for highlighted sections
      const style = document.createElement("style");
      style.textContent = `
            .highlighted .section-title {
                background: #007bff !important;
                transform: scale(1.02);
                transition: all 0.2s ease;
            }
            .section-title:hover {
                opacity: 0.8;
                transition: opacity 0.2s ease;
            }
            .skill-level:disabled {
                opacity: 0.3 !important;
                cursor: not-allowed !important;
            }
            .skill-level:disabled + .level-label {
                color: #6c757d !important;
                opacity: 0.3 !important;
            }
            .skill-levels:not(.disabled) .skill-level:not(:disabled) {
                opacity: 1;
                cursor: pointer;
            }
            .skill-levels:not(.disabled) .skill-level:not(:disabled) + .level-label {
                color: inherit;
                opacity: 1;
            }
            input[data-attribute] {
                border: 2px solid #333;
                font-weight: bold;
            }
            input[data-attribute]:focus {
                border-color: #007bff;
                box-shadow: 0 0 0 0.2rem rgba(0,123,255,.25);
            }
            .essence-quantity:disabled {
                opacity: 0.5 !important;
                background-color: #f8f9fa !important;
                cursor: not-allowed !important;
            }
            .essence-quantity-container {
                margin-bottom: 8px;
            }
            .essence-checkbox {
                margin-right: 8px;
            }
            .essence-label {
                min-width: 120px;
                font-weight: 500;
            }
        `;
      document.head.appendChild(style);

      // Initialize the extensible components when the page loads
      document.addEventListener("DOMContentLoaded", function () {
        console.log("Character Sheet Extensible Components Initialized");

        // Initialize magic manager
        magicManager = new MagicManager();

        // Render dynamic sections using the component system
        const skillComponent = new SkillSectionComponent();
        const resourceComponent = new ResourceComponent();

        // Render resource sections (HP, Mana, etc.)
        resourceComponent.renderFromJson(
          resourceSectionsConfig,
          "resource-sections-container"
        );

        // Generate all sections HTML
        let allSectionsHtml = "";
        skillSectionsConfig.forEach((config) => {
          allSectionsHtml += skillComponent.renderSection(config);
        });

        // Render all JSON sections together in the main layout
        renderAllSectionsInLayout(skillComponent);

        // Also render all sections in the preview container if it exists
        const allSectionsContainer = document.getElementById(
          "all-sections-container"
        );
        if (allSectionsContainer) {
          allSectionsContainer.innerHTML = allSectionsHtml;
        }

        // Update the Sistema FAQ section (Conhecimento)
        const sistemaFaqSection = document.querySelector(
          '[data-section="sistema_faq"] .card-body'
        );
        if (sistemaFaqSection && skillSectionsConfig[0]) {
          // Conhecimento is index 0
          const conhecimentoConfig = skillSectionsConfig[0];
          const conhecimentoHtml = `
            <div class="checkbox-list">
              ${skillComponent.generateCheckboxes(
                conhecimentoConfig.skills,
                conhecimentoConfig.sectionId
              )}
            </div>
          `;
          sistemaFaqSection.innerHTML = conhecimentoHtml;
        }

        // Update the Magia section in the top area if it exists
        const magiaSection = document.querySelector(
          '[data-section="magia"] .card-body'
        );
        if (magiaSection && skillSectionsConfig[7]) {
          // Magia is index 7
          const magiaConfig = skillSectionsConfig[7];
          const magiaHtml = `
            <div class="checkbox-list">
              ${skillComponent.generateCheckboxes(
                magiaConfig.skills,
                magiaConfig.sectionId
              )}
            </div>
          `;
          magiaSection.innerHTML = magiaHtml;
        }

        console.log(
          "All sections have been dynamically updated with their configurations"
        );

        // Initial point calculation
        calculateTotalPoints();

        // Calculate available points
        calculateAvailablePoints();

        // Load any saved character data
        const hasLoadedData = loadCharacterDataFromStorage();

        // If no saved data was loaded, initialize skill availability with default values
        if (!hasLoadedData) {
          skillSectionsConfig.forEach((config) => {
            if (config.attribute) {
              updateSkillAvailability(config.sectionId, 0); // Start with 0 attribute values
            }
          });

          // Initialize previous level for new characters
          const levelElement = document.getElementById("character-level");
          if (levelElement) {
            levelElement.dataset.previousLevel =
              levelElement.textContent || "0";
          }
        }

        // Set up automatic saving
        setupAutoSave();

        // Update dice selector availability on initial load
        updateDiceSelectorAvailability();

        // Recalculate base resources after everything is loaded
        updateResourceBaseValues(false); // false indicates initialization, not dice type change

        // Render initial magic list
        if (magicManager) {
          magicManager.renderComponentOptions();
          magicManager.renderEssencesSelection();
          magicManager.renderMagicList();

          // Apply saved essence selection state immediately after rendering essences
          setTimeout(() => {
            // Load saved character data to get essence selection state
            try {
              const savedData = localStorage.getItem("fac_09_character_sheet");
              if (savedData) {
                const data = JSON.parse(savedData);
                if (data.currentEssenceSelection) {
                  loadEssenceSelectionState(data.currentEssenceSelection);
                }
              }
            } catch (error) {
              console.error("Error loading essence selection state:", error);
            }

            updateFinalCostDisplay();
          }, 100);
        }
      });

      function setupAutoSave() {
        // Save whenever any input changes
        document.addEventListener("input", function (e) {
          // Debounce saving to avoid too many saves
          clearTimeout(window.saveTimeout);
          window.saveTimeout = setTimeout(() => {
            saveCharacterDataToStorage();
          }, 500);
        });

        // Save whenever checkboxes change
        document.addEventListener("change", function (e) {
          if (e.target.type === "checkbox") {
            clearTimeout(window.saveTimeout);
            window.saveTimeout = setTimeout(() => {
              saveCharacterDataToStorage();
            }, 500);
          }
        });
      }

      // Function to render all sections from JSON in the main layout
      function renderAllSectionsInLayout(skillComponent) {
        const dynamicContainer = document.getElementById(
          "dynamic-skill-sections"
        );
        const additionalContainer = document.getElementById(
          "additional-skill-sections"
        );

        if (!dynamicContainer || !additionalContainer) return;

        // Clear containers
        dynamicContainer.innerHTML = "";
        additionalContainer.innerHTML = "";

        // Define which sections go where (customize as needed)
        const mainSections = [0, 1, 2, 7]; // Conhecimento, Social, Cultura, Magia (indices in skillSectionsConfig)
        const additionalSections = [3, 4, 5, 6]; // Atletismo, Manufatura, Combate, Sobrevivência

        // Render main sections (Conhecimento, Social, Cultura, Magia)
        let mainHtml = '<div class="row">';
        mainSections.forEach((configIndex) => {
          if (skillSectionsConfig[configIndex]) {
            const config = skillSectionsConfig[configIndex];
            mainHtml += `
              <div class="col-md-3">
                ${skillComponent.renderSection(config)}
              </div>
            `;
          }
        });
        mainHtml += "</div>";
        dynamicContainer.innerHTML = mainHtml;

        // Render additional sections (Atletismo, Manufatura, Combate, Sobrevivência)
        let additionalHtml = '<div class="row">';
        additionalSections.forEach((configIndex) => {
          if (skillSectionsConfig[configIndex]) {
            const config = skillSectionsConfig[configIndex];
            additionalHtml += `
              <div class="col-md-3">
                ${skillComponent.renderSection(config)}
              </div>
            `;
          }
        });
        additionalHtml += "</div>";
        additionalContainer.innerHTML = additionalHtml;

        console.log(
          "All JSON sections rendered in main layout with attributes"
        );

        // Don't initialize skill availability here - wait for data to load first
      }

      // Validation function for attribute changes
      function validateAttributeAndSkills(attributeName, sectionId) {
        const attributeInput = document.querySelector(
          `input[data-attribute="${attributeName}"]`
        );
        if (!attributeInput) return;

        // Ensure attribute value is between 0 and 3
        let value = parseInt(attributeInput.value);
        if (isNaN(value) || value < 0) {
          value = 0;
          attributeInput.value = 0;
        } else if (value > 3) {
          value = 3;
          attributeInput.value = 3;
        }

        // Update skill availability based on attribute value
        updateSkillAvailability(sectionId, value);

        // Update point calculation
        calculateTotalPoints();
      }

      // Function to toggle skill levels (1, 2, 3)
      function toggleSkillLevel(checkbox, level) {
        const sectionId = checkbox.dataset.section;
        const skillName = checkbox.dataset.skill;

        if (!sectionId) return;

        // Find the corresponding attribute for this section
        const config = skillSectionsConfig.find(
          (c) => c.sectionId === sectionId
        );
        if (!config || !config.attribute) return;

        const attributeInput = document.querySelector(
          `input[data-attribute="${config.attribute.dataAttribute}"]`
        );
        if (!attributeInput) return;

        const attributeValue = parseInt(attributeInput.value) || 0;

        // Check if the level is allowed based on attribute value
        if (level > attributeValue) {
          checkbox.checked = false;
          alert(
            `Você precisa ter pelo menos ${level} pontos em ${config.attribute.label} para selecionar o nível ${level} de ${skillName}`
          );
          return false;
        }

        // Get all level checkboxes for this skill
        const skillContainer = checkbox.closest(".skill-levels");
        const levelCheckboxes = skillContainer.querySelectorAll(".skill-level");

        if (checkbox.checked) {
          // If checking a level, also check all lower levels
          levelCheckboxes.forEach((cb) => {
            const cbLevel = parseInt(cb.dataset.level);
            if (cbLevel <= level) {
              cb.checked = true;
            }
          });
        } else {
          // If unchecking a level, also uncheck all higher levels
          levelCheckboxes.forEach((cb) => {
            const cbLevel = parseInt(cb.dataset.level);
            if (cbLevel >= level) {
              cb.checked = false;
            }
          });
        }

        // Update point calculation after skill change
        calculateTotalPoints();
        return true;
      }

      // Function to toggle Prestigio skills (costs 1 attribute point each)
      function togglePrestigioSkill(checkbox) {
        // Update point calculation after prestigio skill change
        calculateTotalPoints();
        return true;
      }

      // Function to update skill availability based on attribute value
      function updateSkillAvailability(sectionId, attributeValue) {
        const sectionElement = document.querySelector(
          `[data-section="${sectionId}"]`
        );
        if (!sectionElement) return;

        const skillContainers =
          sectionElement.querySelectorAll(".skill-levels");

        skillContainers.forEach((container) => {
          const levelCheckboxes = container.querySelectorAll(".skill-level");

          levelCheckboxes.forEach((checkbox) => {
            const level = parseInt(checkbox.dataset.level);

            if (level > attributeValue) {
              // Disable and uncheck levels higher than attribute value
              checkbox.disabled = true;
              checkbox.checked = false;
            } else if (attributeValue >= 1) {
              // Enable levels within attribute value (only if attribute is at least 1)
              checkbox.disabled = false;
            } else {
              // If attribute is 0, disable all levels
              checkbox.disabled = true;
              checkbox.checked = false;
            }
          });

          // Update visual state of the entire skill container
          console.log("attributeValue:", attributeValue);
          if (attributeValue === 0) {
            container.classList.add("disabled");
          } else {
            container.classList.remove("disabled");
          }
        });
      }

      // Function to calculate skill level cost
      function calculateSkillCost(level) {
        switch (level) {
          case 1:
            return 1;
          case 2:
            return 1 + 1;
          case 3:
            return 1 + 1 + 1;
          default:
            return 0;
        }
      }

      // Function to calculate total points
      function calculateTotalPoints() {
        let attributePoints = 0;
        let skillPoints = 0;
        let prestigioPoints = 0;

        // Calculate attribute points (1 point per level)
        document.querySelectorAll("input[data-attribute]").forEach((input) => {
          const value = parseInt(input.value) || 0;
          attributePoints += value;
        });

        // Calculate skill points (1/2/4 points for levels 1/2/3)
        // Exclude recursos section since it's now just text
        document.querySelectorAll(".skill-levels").forEach((skillContainer) => {
          const sectionId = skillContainer.dataset.section;

          // Skip recursos section
          if (sectionId === "recursos") return;

          const levelCheckboxes = skillContainer.querySelectorAll(
            ".skill-level:checked"
          );

          // Find the highest checked level for this skill
          let maxLevel = 0;
          levelCheckboxes.forEach((checkbox) => {
            const level = parseInt(checkbox.dataset.level);
            if (level > maxLevel) maxLevel = level;
          });

          skillPoints += calculateSkillCost(maxLevel);
        });

        // Calculate Prestigio points (1 attribute point each)
        document.querySelectorAll(".prestigio-level:checked").forEach(() => {
          prestigioPoints += 1;
        });

        // Get available points
        const availableAttributePoints =
          parseInt(
            document.getElementById("attribute-available").textContent
          ) || 5;
        const availableSkillPoints =
          parseInt(document.getElementById("skill-available").textContent) ||
          10;

        // Update the display
        document.getElementById("attribute-points").textContent =
          attributePoints;
        document.getElementById("skill-points").textContent = skillPoints;
        document.getElementById("prestigio-points").textContent =
          prestigioPoints;

        // Update used points display
        document.getElementById("attribute-used").textContent =
          attributePoints + prestigioPoints;
        document.getElementById("skill-used").textContent = skillPoints;
        document.getElementById("prestigio-used").textContent = prestigioPoints;

        // Apply warning colors if points are exceeded
        checkAndApplyWarningColors(
          attributePoints + prestigioPoints,
          skillPoints,
          availableAttributePoints,
          availableSkillPoints
        );

        return {
          attributes: attributePoints,
          skills: skillPoints,
          prestigio: prestigioPoints,
        };
      }

      // Function to check and apply warning colors when points are exceeded
      function checkAndApplyWarningColors(
        usedAttributePoints,
        usedSkillPoints,
        availableAttributePoints,
        availableSkillPoints
      ) {
        // Check attribute points
        const attributeExceeded =
          usedAttributePoints > availableAttributePoints;
        const skillExceeded = usedSkillPoints > availableSkillPoints;

        // Update point category colors
        const attributeCategory = document
          .querySelector("#attribute-points")
          .closest(".point-category");
        const skillCategory = document
          .querySelector("#skill-points")
          .closest(".point-category");

        if (attributeExceeded) {
          attributeCategory.classList.add("points-exceeded");
        } else {
          attributeCategory.classList.remove("points-exceeded");
        }

        if (skillExceeded) {
          skillCategory.classList.add("points-exceeded");
        } else {
          skillCategory.classList.remove("points-exceeded");
        }

        // Apply colors to individual attribute inputs
        document.querySelectorAll("input[data-attribute]").forEach((input) => {
          if (attributeExceeded) {
            input.classList.add("attribute-exceeded");
          } else {
            input.classList.remove("attribute-exceeded");
          }
        });

        // Apply colors to individual skill containers
        document.querySelectorAll(".skill-levels").forEach((skillContainer) => {
          const sectionId = skillContainer.dataset.section;

          // Skip recursos section
          if (sectionId === "recursos") return;

          if (skillExceeded) {
            skillContainer.classList.add("skill-exceeded");
          } else {
            skillContainer.classList.remove("skill-exceeded");
          }
        });
      }

      // Magic System Classes and Functions

      // MagicComponentField class to represent different component field types
      class MagicComponentField {
        constructor(id, title, description, options = [], required = false) {
          this.id = id;
          this.title = title;
          this.description = description;
          this.options = options; // Array of {id, name, costModifier}
          this.required = required;
        }

        // Create MagicComponentField from JSON
        static fromJSON(data) {
          return new MagicComponentField(
            data.id,
            data.title,
            data.description,
            data.options || [],
            data.required || false
          );
        }

        // Convert to JSON for storage
        toJSON() {
          return {
            id: this.id,
            title: this.title,
            description: this.description,
            options: this.options,
            required: this.required,
          };
        }
      }

      // Magic class to represent individual spells
      class Magic {
        constructor(
          name,
          componentSelections = {},
          essenceQuantities = {},
          baseCost = null,
          dice = null
        ) {
          this.id = Date.now() + Math.random(); // Simple unique ID
          this.name = name;
          this.componentSelections = componentSelections; // Object with fieldId: optionId
          this.essenceQuantities = essenceQuantities; // Object with essenceId: quantity
          this.baseCost = baseCost || this.calculateBaseCostFromEssences();
          this.dice = dice || this.getFinalDice(); // Final dice string
          this.createdAt = new Date();
        }

        // Calculate base cost from selected essences with hemisphere proximity modifiers
        calculateBaseCostFromEssences() {
          if (
            !this.essenceQuantities ||
            Object.keys(this.essenceQuantities).length === 0
          ) {
            return 1;
          }

          let totalCost = 0;

          // Calculate base cost from essence quantities
          Object.keys(this.essenceQuantities).forEach((essenceId) => {
            const quantity = this.essenceQuantities[essenceId];
            if (quantity > 0) {
              for (let hemisphere of essencesConfig) {
                const essence = hemisphere.essences.find(
                  (e) => e.id === essenceId
                );
                if (essence) {
                  totalCost += essence.cost * quantity;
                  break;
                }
              }
            }
          });

          // Apply hemisphere proximity modifiers
          const selectedEssenceIds = Object.keys(this.essenceQuantities).filter(
            (id) => this.essenceQuantities[id] > 0
          );
          const proximityResult =
            calculateHemisphereProximityModifier(selectedEssenceIds);
          totalCost *= proximityResult.modifier;

          return Math.max(Math.ceil(totalCost), 1); // Minimum cost of 1
        }

        // Calculate final cost based on component selections
        getFinalCost(componentFields) {
          let totalModifier = 1.0;

          // Apply modifiers from each field selection
          Object.keys(this.componentSelections).forEach((fieldId) => {
            const optionId = this.componentSelections[fieldId];
            if (!optionId) return;

            const field = componentFields.find((f) => f.id === fieldId);
            if (!field) return;

            const option = field.options.find((o) => o.id === optionId);
            if (option && option.costModifier) {
              totalModifier *= option.costModifier;
            }
          });

          return Math.ceil(this.baseCost * totalModifier);
        }

        // Calculate final dice from selected essences
        getFinalDice() {
          if (
            !this.essenceQuantities ||
            Object.keys(this.essenceQuantities).length === 0
          ) {
            return "0";
          }

          const diceMap = {};

          // Collect all dice from essence quantities
          Object.keys(this.essenceQuantities).forEach((essenceId) => {
            const quantity = this.essenceQuantities[essenceId];
            if (quantity > 0) {
              for (let hemisphere of essencesConfig) {
                const essence = hemisphere.essences.find(
                  (e) => e.id === essenceId
                );
                if (essence && essence.dice) {
                  // Parse dice (e.g., "1d4" -> {count: 1, sides: 4})
                  const diceMatch = essence.dice.match(/(\d+)d(\d+)/);
                  if (diceMatch) {
                    const count = parseInt(diceMatch[1]) * quantity; // Multiply by quantity
                    const sides = parseInt(diceMatch[2]);
                    const diceType = `d${sides}`;

                    if (diceMap[diceType]) {
                      diceMap[diceType] += count;
                    } else {
                      diceMap[diceType] = count;
                    }
                  }
                  break;
                }
              }
            }
          });

          let multiplier = 1;
          if (
            this.componentSelections &&
            this.componentSelections["dice_multiplier"]
          ) {
            const multValue = parseInt(
              this.componentSelections["dice_multiplier"]
            );
            if (!isNaN(multValue) && multValue > 0) {
              multiplier = multValue;
            }
          }

          Object.keys(diceMap).forEach((diceType) => {
            diceMap[diceType] *= multiplier;
          });

          // Format final dice string
          const diceStrings = Object.keys(diceMap)
            .sort((a, b) => {
              const aSize = parseInt(a.substring(1));
              const bSize = parseInt(b.substring(1));
              return bSize - aSize; // Sort descending by dice size
            })
            .map((diceType) => `${diceMap[diceType]}${diceType}`);

          return diceStrings.length > 0 ? diceStrings.join(" + ") : "0";
        }

        // Get final dice as display string
        getFinalDiceDisplay(finalDice) {
          return finalDice === "0" ? "Nenhum dado" : finalDice;
        }

        // Get selected essences as display string
        getEssencesDisplay() {
          if (
            !this.essenceQuantities ||
            Object.keys(this.essenceQuantities).length === 0
          ) {
            return "Nenhuma essência";
          }

          const essenceNames = [];
          Object.keys(this.essenceQuantities).forEach((essenceId) => {
            const quantity = this.essenceQuantities[essenceId];
            if (quantity > 0) {
              for (let hemisphere of essencesConfig) {
                const essence = hemisphere.essences.find(
                  (e) => e.id === essenceId
                );
                if (essence) {
                  const displayName =
                    quantity > 1
                      ? `${essence.name} (x${quantity})`
                      : essence.name;
                  essenceNames.push(displayName);
                  break;
                }
              }
            }
          });

          return essenceNames.length > 0
            ? essenceNames.join(", ")
            : "Nenhuma essência";
        }

        // Get hemisphere proximity modifier details
        getHemisphereProximityDetails() {
          if (
            !this.essenceQuantities ||
            Object.keys(this.essenceQuantities).length <= 1
          ) {
            return { modifier: 1.0, description: "" };
          }

          let rawCost = 0;

          // Calculate raw cost from essence quantities
          Object.keys(this.essenceQuantities).forEach((essenceId) => {
            const quantity = this.essenceQuantities[essenceId];
            if (quantity > 0) {
              for (let hemisphere of essencesConfig) {
                const essence = hemisphere.essences.find(
                  (e) => e.id === essenceId
                );
                if (essence) {
                  rawCost += essence.cost * quantity;
                  break;
                }
              }
            }
          });

          const selectedEssenceIds = Object.keys(this.essenceQuantities).filter(
            (id) => this.essenceQuantities[id] > 0
          );
          const proximityResult =
            calculateHemisphereProximityModifier(selectedEssenceIds);

          // Format description from details
          const description = proximityResult.details
            .map(
              (detail) =>
                `${detail.pair}: ${detail.relationship} (×${detail.modifier})`
            )
            .join(", ");

          return {
            modifier: proximityResult.modifier,
            description: description,
            rawCost: rawCost,
            finalCost: Math.ceil(rawCost * proximityResult.modifier),
          };
        }

        // Get component selections as display string
        getComponentSelectionsDisplay(componentFields) {
          const selections = [];

          Object.keys(this.componentSelections).forEach((fieldId) => {
            const optionId = this.componentSelections[fieldId];
            if (!optionId) return;

            const field = componentFields.find((f) => f.id === fieldId);
            if (!field) return;

            const option = field.options.find((o) => o.id === optionId);
            if (option) {
              selections.push(`${field.title}: ${option.name}`);
            }
          });

          return selections.length > 0 ? selections.join(" | ") : "Nenhum";
        }

        // Convert to JSON for storage
        toJSON() {
          return {
            id: this.id,
            name: this.name,
            componentSelections: this.componentSelections,
            essenceQuantities: this.essenceQuantities,
            baseCost: this.baseCost,
            dice: this.dice,
            createdAt: this.createdAt.toISOString(),
          };
        }

        // Create Magic from JSON data
        static fromJSON(data) {
          const magic = new Magic(
            data.name,
            data.componentSelections || {},
            data.essenceQuantities || data.selectedEssences || {}, // Support old format
            data.baseCost || 1,
            data.dice || null
          );
          magic.id = data.id;
          magic.createdAt = new Date(data.createdAt);
          return magic;
        }
      }

      // Essences configuration for calculating base cost
      const essencesConfig = [
        {
          id: "energetico",
          name: "Energético",
          essences: [
            {
              id: "ignis",
              name: "Ignis",
              cost: 1,
              dice: "1d4",
              info: " A essência de Ignis é a primeira essência disponível no hemisfério de energia, associada diretamente com a ideia de energia térmica, implicando no ganho de calor e até mesmo criação de plasma na forma de labaredas e chamas.<h3>Condições:</h3> <span>incendiado (3)</span> <br><h3>Efeitos:</h3> <span>Luz, brilho, aquecimento, ignição, fervura, derretimento, descongelamento.</span>",
            },
            {
              id: "fax",
              name: "Fax",
              cost: 2,
              dice: "1d6",
              info: "Fax é a segunda essência pertencente ao hemisfério de energia, ela é associada a energia de natureza eletromagnética, seja pela excitação de elétrons que geram raios, tão bem como formação de campos que podem manipular bússolas ou outros aparelhos.<h3>Condições:</h3> <span>Incendiado (1), atordoado (1), cego (1)</span> <br><h3>Efeitos:</h3> <span>Explosão, energia, raios, luz.</span>",
            },
            { id: "potentia", name: "Potentia", cost: 2, dice: "1d10" },
            { id: "kinetica", name: "Kinetica", cost: 2, dice: "1d6" },
            { id: "anarchia", name: "Anarchia", cost: 3 },
          ],
        },
        {
          id: "material",
          name: "Material",
          essences: [
            { id: "tatio", name: "Tatio", cost: 1 },
            { id: "aqua", name: "Aqua", cost: 2, dice: "1d8" },
            { id: "terra", name: "Terra", cost: 2, dice: "1d4" },
            { id: "aer", name: "Aer", cost: 2, dice: "1d4" },
            { id: "metallum", name: "Metallum", cost: 4, dice: "1d12" },
          ],
        },
        {
          id: "ilusorio",
          name: "Ilusório",
          essences: [
            { id: "ambiens", name: "Ambiens", cost: 1 },
            { id: "ego", name: "Ego", cost: 2 },
            { id: "suego", name: "Suego", cost: 5 },
            { id: "sensus", name: "Sensus", cost: 1 },
            { id: "realitas", name: "Realitas", cost: 10 },
          ],
        },
        {
          id: "conjurador",
          name: "Conjurador",
          essences: [
            { id: "for", name: "For", cost: 1 },
            { id: "dyn", name: "Dyn", cost: 2 },
            { id: "creatio", name: "Creatio", cost: 2 },
            { id: "clavis", name: "Clavis", cost: 1 },
            { id: "influentia", name: "Influentia", cost: 7 },
          ],
        },
        {
          id: "vida",
          name: "Vida",
          essences: [
            { id: "vita", name: "Vita", cost: 1, dice: "1d4" },
            { id: "roratio", name: "Roratio", cost: 2 },
            { id: "puri", name: "Puri", cost: 2, dice: "1d6" },
            { id: "bene", name: "Bene", cost: 5 },
            { id: "renatio", name: "Renatio", cost: 3 },
          ],
        },
        {
          id: "morte",
          name: "Morte",
          essences: [
            { id: "pest", name: "Pest", cost: 4 },
            { id: "infirmi", name: "Infirmi", cost: 2 },
            { id: "corruptio", name: "Corruptio", cost: 4, dice: "1d8" },
            { id: "maledictio", name: "Maledictio", cost: 2 },
            { id: "necro", name: "Necro", cost: 5, dice: "1d8" },
          ],
        },
      ];

      // Hemisphere proximity configuration for calculating modifiers
      const hemisphereProximity = {
        energetico: {
          close: ["morte", "ilusorio"],
        },
        material: {
          close: ["conjurador", "vida"],
        },
        ilusorio: {
          close: ["morte", "energetico"],
        },
        conjurador: {
          close: ["material", "vida"],
        },
        vida: {
          close: ["material", "conjurador"],
        },
        morte: {
          close: ["ilusorio", "energetico"],
        },
      };

      // Helper function to calculate hemisphere proximity modifier
      function calculateHemisphereProximityModifier(selectedEssences) {
        if (!selectedEssences || selectedEssences.length === 0) {
          return { modifier: 1.0, details: [] };
        }

        const selectedHemispheres = new Set();

        // Collect hemispheres from selected essences
        selectedEssences.forEach((essenceId) => {
          for (let hemisphere of essencesConfig) {
            const essence = hemisphere.essences.find((e) => e.id === essenceId);
            if (essence) {
              selectedHemispheres.add(hemisphere.id);
              break;
            }
          }
        });

        if (selectedHemispheres.size <= 1) {
          return { modifier: 1.0, details: [] };
        }

        const hemisphereArray = Array.from(selectedHemispheres);
        let proximityModifier = 1.0;
        const proximityDetails = [];

        // Check proximity between consecutive hemispheres only
        for (let i = 1; i < hemisphereArray.length; i++) {
          const hemisphere1 = hemisphereArray[i - 1];
          const hemisphere2 = hemisphereArray[i];

          const proximity1 = hemisphereProximity[hemisphere1];
          let pairModifier = 1.2; // Default: far modifier
          let relationship = "distante";

          if (proximity1) {
            if (proximity1.close && proximity1.close.includes(hemisphere2)) {
              pairModifier = 1.1; // Close modifier
              relationship = "próximo";
            }
          }

          proximityModifier *= pairModifier;
          proximityDetails.push({
            pair: `${hemisphere1}+${hemisphere2}`,
            relationship,
            modifier: pairModifier,
          });
        }

        return {
          modifier: proximityModifier,
          details: proximityDetails,
        };
      }

      // Magic Component class to handle magic list management and rendering
      class MagicManager {
        constructor() {
          this.magics = [];
          this.componentFields = [];
          this.essencesConfig = essencesConfig;
          this.initializeDefaultComponentFields();
          this.loadMagicsFromStorage();
        }

        // Initialize default component fields from JSON configuration
        initializeDefaultComponentFields() {
          const defaultComponentFieldsConfig = [
            {
              id: "duration",
              title: "Duração",
              description: "Tempo de duração do efeito",
              required: true,
              options: [
                { id: "instant", name: "Instantânea", costModifier: 1.0 },
                { id: "1_minute", name: "1 minuto", costModifier: 2.0 },
                { id: "5_minute", name: "5 minutos", costModifier: 2.2 },
                { id: "10_minute", name: "10 minutos", costModifier: 2.4 },
                { id: "1_hour", name: "1 hora", costModifier: 4.0 },
                { id: "3_hour", name: "3 horas", costModifier: 4.2 },
                { id: "6_hours", name: "Até 6 horas", costModifier: 4.5 },
                { id: "1_day", name: "Até 1 dia", costModifier: 6.0 },
                { id: "7_days", name: "Até 7 dias", costModifier: 7.0 },
                { id: "14_days", name: "Até 14 dias", costModifier: 9.0 },
                { id: "1_month", name: "Até 1 mês", costModifier: 10.0 },
              ],
            },
            {
              id: "target",
              title: "Alvo",
              description: "Alvos da magia",
              required: true,
              options: [
                { id: "1_target", name: "1 alvo", costModifier: 1.0 },
                { id: "3_targets", name: "Até 3 alvos", costModifier: 1.3 },
                { id: "6_targets", name: "Até 6 alvos", costModifier: 1.6 },
                { id: "9_targets", name: "Até 9 alvos", costModifier: 1.9 },
                { id: "12_targets", name: "Até 12 alvos", costModifier: 2.2 },
                { id: "15_targets", name: "Até 15 alvos", costModifier: 2.5 },
                { id: "18_targets", name: "Até 18 alvos", costModifier: 2.8 },
                { id: "24_targets", name: "Até 24 alvos", costModifier: 3.1 },
                { id: "30_targets", name: "Até 30 alvos", costModifier: 4.0 },
              ],
            },
            {
              id: "distance",
              title: "Distância",
              description: "Distância da magia",
              required: true,
              options: [
                { id: "self_touch", name: "Self/Toque", costModifier: 1.0 },
                { id: "5_meters", name: "Até 5 metros", costModifier: 1.1 },
                { id: "10_meters", name: "Até 10 metros", costModifier: 1.2 },
                { id: "30_meters", name: "Até 30 metros", costModifier: 1.5 },
                { id: "50_meters", name: "Até 50 metros", costModifier: 2.0 },
                { id: "100_meters", name: "Até 100 metros", costModifier: 2.5 },
                { id: "500_meters", name: "Até 500 metros", costModifier: 5.0 },
                { id: "10_km", name: "Até 10 Km", costModifier: 10.0 },
              ],
            },
            {
              id: "area",
              title: "Área",
              description: "Área de efeito da magia",
              required: true,
              options: [
                { id: "point", name: "Pontual", costModifier: 1.0 },
                {
                  id: "5_m2",
                  name: "5 m²",
                  costModifier: 1.3,
                  description: "Tenda",
                },
                {
                  id: "15_m2",
                  name: "15 m²",
                  costModifier: 1.4,
                  description: "Banheiro",
                },
                {
                  id: "30_m2",
                  name: "30 m²",
                  costModifier: 1.5,
                  description: "Quarto",
                },
                {
                  id: "50_m2",
                  name: "50 m²",
                  costModifier: 1.6,
                  description: "Salão",
                },
                {
                  id: "100_m2",
                  name: "100 m²",
                  costModifier: 1.7,
                  description: "Casebre",
                },
                {
                  id: "250_m2",
                  name: "250 m²",
                  costModifier: 1.8,
                  description: "Casa",
                },
                {
                  id: "500_m2",
                  name: "500 m²",
                  costModifier: 1.9,
                  description: "Casarão",
                },
                {
                  id: "1000_m2",
                  name: "1000 m²",
                  costModifier: 2.0,
                  description: "Mansão",
                },
                {
                  id: "5000_m2",
                  name: "5000 m²",
                  costModifier: 2.2,
                  description: "Catedral",
                },
                {
                  id: "10000_m2",
                  name: "10000 m²",
                  costModifier: 2.4,
                  description: "Castelo",
                },
                {
                  id: "25000_m2",
                  name: "25000 m²",
                  costModifier: 2.6,
                  description: "Palácio",
                },
                {
                  id: "50000_m2",
                  name: "50000 m²",
                  costModifier: 2.8,
                  description: "Distrito",
                },
                {
                  id: "75000_m2",
                  name: "75000 m²",
                  costModifier: 3.0,
                  description: "Vilarejo",
                },
                {
                  id: "100000_m2",
                  name: "100000 m²",
                  costModifier: 4.0,
                  description: "Cidade",
                },
              ],
            },
            {
              id: "areaType",
              title: "Tipo de Área",
              description: "Tipo de área da magia",
              required: true,
              options: [
                { id: "grupal", name: "Grupal", costModifier: 1.0 },
                { id: "seletivo", name: "Seletivo", costModifier: 4.0 },
              ],
            },
            {
              id: "concentracao",
              title: "Concentração",
              description: "Nível de concentração necessário para a magia",
              required: true,
              options: [
                { id: "moderado", name: "Moderado", costModifier: 1.0 },
                { id: "baixa", name: "Instantâneo", costModifier: 1.4 },
                { id: "pesado", name: "Pesado", costModifier: 0.8 },
              ],
            },
            {
              id: "dice_multiplier",
              title: "Multiplicador de Dados",
              description: "Multiplicador de dados para a magia",
              required: true,
              options: [
                { id: "1", name: "1", costModifier: 1.0 },
                { id: "2", name: "2", costModifier: 3 },
                { id: "3", name: "3", costModifier: 6 },
                { id: "4", name: "4", costModifier: 9 },
                { id: "5", name: "5", costModifier: 12 },
              ],
            },
          ];

          this.componentFields = defaultComponentFieldsConfig.map((config) =>
            MagicComponentField.fromJSON(config)
          );
        }

        // Add a new magic to the list
        addMagic(name, componentSelections, baseCost = 1) {
          if (!name || !name.trim()) {
            alert("Por favor, digite um nome para a magia.");
            return false;
          }

          // Check if any required fields are missing
          const missingRequired = this.componentFields
            .filter((field) => field.required && !componentSelections[field.id])
            .map((field) => field.title);

          if (missingRequired.length > 0) {
            alert(`Por favor, selecione: ${missingRequired.join(", ")}`);
            return false;
          }

          // Check if magic with same name already exists
          const existingMagic = this.magics.find(
            (magic) => magic.name.toLowerCase() === name.trim().toLowerCase()
          );

          if (existingMagic) {
            alert(`A magia "${name.trim()}" já existe na lista.`);
            return false;
          }

          const magic = new Magic(name.trim(), componentSelections, baseCost);
          this.magics.push(magic);
          this.saveMagicsToStorage();
          this.renderMagicList();
          return true;
        }

        // Add a new magic with essences to the list
        addMagicWithEssences(
          name,
          componentSelections,
          essenceQuantities,
          baseCost = 1,
          dice = null
        ) {
          if (!name || !name.trim()) {
            alert("Por favor, digite um nome para a magia.");
            return false;
          }

          // Check if any required fields are missing
          const missingRequired = this.componentFields
            .filter((field) => field.required && !componentSelections[field.id])
            .map((field) => field.title);

          if (missingRequired.length > 0) {
            alert(`Por favor, selecione: ${missingRequired.join(", ")}`);
            return false;
          }

          // Check if magic with same name already exists
          const existingMagic = this.magics.find(
            (magic) => magic.name.toLowerCase() === name.trim().toLowerCase()
          );

          if (existingMagic) {
            alert(`A magia "${name.trim()}" já existe na lista.`);
            return false;
          }

          const magic = new Magic(
            name.trim(),
            componentSelections,
            essenceQuantities,
            baseCost,
            dice
          );
          this.magics.push(magic);
          this.saveMagicsToStorage();
          this.renderMagicList();
          return true;
        }

        // Remove a magic from the list
        removeMagic(magicId) {
          const index = this.magics.findIndex((magic) => magic.id === magicId);
          if (index !== -1) {
            const magic = this.magics[index];
            if (
              confirm(`Tem certeza que deseja remover a magia "${magic.name}"?`)
            ) {
              this.magics.splice(index, 1);
              this.saveMagicsToStorage();
              this.renderMagicList();
              return true;
            }
          }
          return false;
        }

        // Render component field selects
        renderComponentOptions() {
          const container = document.getElementById(
            "magic-components-container"
          );
          if (!container) return;

          // Clear existing content
          container.innerHTML = "";

          // Add component field selects
          this.componentFields.forEach((field) => {
            const fieldDiv = document.createElement("div");
            fieldDiv.className = "mb-3";

            const selectId = `magic-field-${field.id}`;
            const requiredLabel = field.required ? " *" : "";

            fieldDiv.innerHTML = `
              <label for="${selectId}" class="form-label">
                <strong>${field.title}${requiredLabel}</strong>
              </label>
              <select class="form-control magic-component-select" 
                      id="${selectId}" 
                      data-field-id="${field.id}"
                      title="${field.description}"
                      onchange="updateFinalCostDisplay()">
                ${
                  field.required
                    ? ""
                    : '<option value="">-- Selecione ' +
                      field.title +
                      " --</option>"
                }
                ${field.options
                  .map(
                    (option, index) =>
                      `<option value="${option.id}" title="Custo: ×${
                        option.costModifier
                      }" ${field.required && index === 0 ? "selected" : ""}>
                    ${option.name} (×${option.costModifier})
                   </option>`
                  )
                  .join("")}
              </select>
              ${
                field.description
                  ? `<small class="form-text text-muted">${field.description}</small>`
                  : ""
              }
            `;

            container.appendChild(fieldDiv);
          });
        }

        // Render essences selection interface
        renderEssencesSelection() {
          const container = document.getElementById("magic-essences-container");
          if (!container) return;

          container.innerHTML = "";

          // Create header
          const headerDiv = document.createElement("div");
          headerDiv.className = "mb-3";
          headerDiv.innerHTML = `
            <h6 class="mb-2">🔮 Seleção de Essências</h6>
            <small class="text-muted">Selecione as essências para calcular o custo base da magia.</small>
            <div class="mt-2">
              <span id="calculated-base-cost" class="badge bg-info">Custo Base: 1</span>
              <span id="calculated-final-cost" class="badge bg-success ms-2">Custo Final: 1</span>
              <span id="calculated-final-dice" class="badge bg-warning ms-2">Dados: Nenhum dado</span>
            </div>
          `;
          container.appendChild(headerDiv);

          // Create essences by hemisphere
          this.essencesConfig.forEach((hemisphere) => {
            const hemisphereDiv = document.createElement("div");
            hemisphereDiv.className = "mb-3 p-2 border rounded";
            hemisphereDiv.innerHTML = `
              <h6 class="mb-2 text-primary">${hemisphere.name}</h6>
              <div class="essence-checkboxes" data-hemisphere="${
                hemisphere.id
              }">
                ${hemisphere.essences
                  .map(
                    (essence) => `
                  <div class="form-check form-check-inline essence-quantity-container d-flex align-items-center">
                    <div class="d-flex align-items-center">
                      <label class="form-check-label essence-label me-2" for="essence-${
                        essence.id
                      }">
                        ${essence.name} (${essence.cost})${
                      essence.info
                        ? `<button class="essence-info-btn" 
                                               onclick="showInfo('${essence.id}', '${essence.name}', \`${essence.info}\`)" 
                                               title="Ver informações sobre ${essence.name}">ℹ</button>`
                        : ""
                    }
                      </label>
                      <input class="form-check-input essence-checkbox me-2" 
                             type="checkbox" 
                             id="essence-checkbox-${essence.id}" 
                             data-essence-id="${essence.id}"
                             onchange="toggleEssenceQuantity('${essence.id}')"
                             title="Habilitar seleção de ${essence.name}">
                      <input class="form-control essence-quantity" 
                             type="number" 
                             id="essence-${essence.id}" 
                             value="0"
                             min="0"
                             max="10"
                             data-essence-id="${essence.id}"
                             onchange="updateBaseCostFromEssences(); updateFinalDiceDisplay()"
                             title="Quantidade de ${essence.name} (custo: ${
                      essence.cost
                    } cada)"
                             disabled>
                    </div>
                  </div>
                `
                  )
                  .join("")}
              </div>
            `;
            container.appendChild(hemisphereDiv);
          });
        }

        // Render the complete magic list
        renderMagicList() {
          const container = document.getElementById("magic-list-container");
          const countElement = document.getElementById("magic-count");
          const noMagicMessage = document.getElementById("no-magic-message");

          if (!container) return;

          // Update count
          if (countElement) {
            countElement.textContent = this.magics.length;
          }

          // Clear container
          container.innerHTML = "";

          if (this.magics.length === 0) {
            if (noMagicMessage) {
              container.appendChild(noMagicMessage);
            } else {
              container.innerHTML =
                '<p class="text-muted text-center">Nenhuma magia adicionada ainda.</p>';
            }
            return;
          }

          // Hide no magic message
          if (noMagicMessage) {
            noMagicMessage.style.display = "none";
          }

          // Render each magic
          this.magics.forEach((magic) => {
            const magicElement = this.renderMagicItem(magic);
            container.appendChild(magicElement);
          });

          // Update total cost display
          this.updateTotalCostDisplay();
        }

        // Render individual magic item
        renderMagicItem(magic) {
          const magicDiv = document.createElement("div");
          magicDiv.className = "magic-item";
          magicDiv.dataset.magicId = magic.id;

          const finalCost = magic.getFinalCost(this.componentFields);
          const componentDisplay = magic.getComponentSelectionsDisplay(
            this.componentFields
          );
          const essencesDisplay = magic.getEssencesDisplay();
          const proximityDetails = magic.getHemisphereProximityDetails();
          const finalDice = magic.getFinalDice();
          const diceDisplay =
            magic.dice || magic.getFinalDiceDisplay(finalDice);
          const hasDice =
            diceDisplay && diceDisplay !== "Nenhum dado" && diceDisplay !== "0";

          let proximityInfo = "";
          if (proximityDetails.modifier > 1.0) {
            proximityInfo = `
              <div class="magic-proximity">
                <small class="text-info">Modificador Hemisférios: ×${proximityDetails.modifier.toFixed(
                  2
                )}</small>
              </div>
            `;
          }

          // Create roll button if dice are available
          let rollButton = "";
          if (hasDice) {
            rollButton = `
              <button class="magic-roll-btn btn btn-sm btn-outline-primary" 
                      onclick="rollMagicDice(${magic.id})" 
                      title="Rolar dados da magia">
                🎲 Rolar
              </button>
            `;
          }

          magicDiv.innerHTML = `
            <button class="magic-remove-btn" onclick="magicManager.removeMagic(${
              magic.id
            })" title="Remover magia">
              ✕
            </button>
            <div class="magic-name">${this.escapeHtml(magic.name)}</div>
            <div class="magic-details">
              <div class="magic-essences">
                <small class="text-muted">Essências:</small> ${this.escapeHtml(
                  essencesDisplay
                )}
              </div>
              ${proximityInfo}
              <div class="magic-components">
                <small class="text-muted">Componentes:</small> ${this.escapeHtml(
                  componentDisplay
                )}
              </div>
              <div class="magic-cost-breakdown">
                <span class="magic-base-cost">Base: ${magic.baseCost}</span>
                <span class="magic-final-cost">Final: ${finalCost}</span>
                <span class="magic-dice">Dados: ${this.escapeHtml(
                  diceDisplay
                )}</span>
                ${rollButton}
              </div>
            </div>
          `;

          return magicDiv;
        }

        // Update total cost display
        updateTotalCostDisplay() {
          const totalCost = this.magics.reduce(
            (sum, magic) => sum + magic.getFinalCost(this.componentFields),
            0
          );

          const totalCostElement = document.getElementById("magic-total-cost");
          if (totalCostElement) {
            totalCostElement.textContent = totalCost;
          }
        }

        // Utility function to escape HTML
        escapeHtml(text) {
          const div = document.createElement("div");
          div.textContent = text;
          return div.innerHTML;
        }

        // Save magics to localStorage
        saveMagicsToStorage() {
          try {
            const data = this.magics.map((magic) => magic.toJSON());
            localStorage.setItem(
              "fac_09_character_magics",
              JSON.stringify(data)
            );
            console.log("Magics saved to localStorage");
          } catch (error) {
            console.error("Error saving magics to localStorage:", error);
          }
        }

        // Load magics from localStorage
        loadMagicsFromStorage() {
          try {
            const data = localStorage.getItem("fac_09_character_magics");
            if (data) {
              const magicsData = JSON.parse(data);
              this.magics = magicsData.map((magicData) =>
                Magic.fromJSON(magicData)
              );
              console.log("Magics loaded from localStorage");
            }
          } catch (error) {
            console.error("Error loading magics from localStorage:", error);
            this.magics = [];
          }
        }

        // Clear all magics
        clearAllMagics() {
          if (this.magics.length === 0) {
            alert("Não há magias para remover.");
            return;
          }

          if (
            confirm(
              "Tem certeza que deseja remover todas as magias? Esta ação não pode ser desfeita."
            )
          ) {
            this.magics = [];
            this.saveMagicsToStorage();
            this.renderMagicList();
          }
        }

        // Get magics data for character save
        getMagicsData() {
          return this.magics.map((magic) => magic.toJSON());
        }

        // Load magics data from character load
        loadMagicsData(magicsData) {
          if (Array.isArray(magicsData)) {
            this.magics = magicsData.map((magicData) =>
              Magic.fromJSON(magicData)
            );
            this.renderMagicList();
          }
        }
      }

      // Global magic manager instance
      let magicManager;

      // Function to toggle essence quantity input based on checkbox state
      function toggleEssenceQuantity(essenceId) {
        const checkbox = document.getElementById(
          `essence-checkbox-${essenceId}`
        );
        const quantityInput = document.getElementById(`essence-${essenceId}`);

        if (!checkbox || !quantityInput) return;

        if (checkbox.checked) {
          // Enable the quantity input and set minimum value to 1
          quantityInput.disabled = false;
          quantityInput.value = Math.max(parseInt(quantityInput.value) || 1, 1);
        } else {
          // Disable the quantity input and reset value to 0
          quantityInput.disabled = true;
          quantityInput.value = 0;
        }

        // Update calculations after toggling
        updateBaseCostFromEssences();
        updateFinalDiceDisplay();

        // Auto-save when essence selection changes
        clearTimeout(window.saveTimeout);
        window.saveTimeout = setTimeout(() => {
          saveCharacterDataToStorage();
        }, 500);
      }

      // Function to get current essence selection state
      function getCurrentEssenceSelectionState() {
        const essenceSelection = {
          checkboxStates: {},
          quantityValues: {},
        };

        const essenceQuantityInputs =
          document.querySelectorAll(".essence-quantity");
        essenceQuantityInputs.forEach((input) => {
          const essenceId = input.dataset.essenceId;
          const checkbox = document.getElementById(
            `essence-checkbox-${essenceId}`
          );

          if (checkbox) {
            essenceSelection.checkboxStates[essenceId] = checkbox.checked;
            essenceSelection.quantityValues[essenceId] =
              parseInt(input.value) || 0;
          }
        });

        return essenceSelection;
      }

      // Function to load essence selection state
      function loadEssenceSelectionState(essenceSelection) {
        if (!essenceSelection) {
          // If no saved data, leave all checkboxes unchecked and inputs disabled (default state)
          updateBaseCostFromEssences();
          updateFinalDiceDisplay();
          return;
        }

        // Load checkbox states and quantity values from saved data
        Object.keys(essenceSelection.checkboxStates || {}).forEach(
          (essenceId) => {
            const checkbox = document.getElementById(
              `essence-checkbox-${essenceId}`
            );
            const quantityInput = document.getElementById(
              `essence-${essenceId}`
            );

            if (checkbox && quantityInput) {
              const isChecked = essenceSelection.checkboxStates[essenceId];
              const quantity = essenceSelection.quantityValues[essenceId] || 0;

              checkbox.checked = isChecked;
              quantityInput.value = quantity;
              quantityInput.disabled = !isChecked;
            }
          }
        );

        // Update calculations after loading
        updateBaseCostFromEssences();
        updateFinalDiceDisplay();
      }

      // Function to clear essence selection state
      function clearEssenceSelectionState() {
        const essenceQuantityInputs =
          document.querySelectorAll(".essence-quantity");
        essenceQuantityInputs.forEach((input) => {
          const essenceId = input.dataset.essenceId;
          const checkbox = document.getElementById(
            `essence-checkbox-${essenceId}`
          );

          if (checkbox) {
            checkbox.checked = false;
            input.value = 0;
            input.disabled = true;
          }
        });

        // Update calculations after clearing
        updateBaseCostFromEssences();
        updateFinalDiceDisplay();
      }

      // Function to update base cost based on selected essences with hemisphere proximity modifiers
      // Function to update base cost based on selected essence quantities
      function updateBaseCostFromEssences() {
        const essenceQuantityInputs =
          document.querySelectorAll(".essence-quantity");
        let totalCost = 0;
        const essenceQuantities = {};

        // Calculate base cost from essence quantities
        essenceQuantityInputs.forEach((input) => {
          const essenceId = input.dataset.essenceId;
          const checkbox = document.getElementById(
            `essence-checkbox-${essenceId}`
          );
          const quantity = parseInt(input.value) || 0;

          // Only consider essences where checkbox is checked and quantity > 0
          if (checkbox && checkbox.checked && quantity > 0) {
            essenceQuantities[essenceId] = quantity;

            for (let hemisphere of essencesConfig) {
              const essence = hemisphere.essences.find(
                (e) => e.id === essenceId
              );
              if (essence) {
                totalCost += essence.cost * quantity;
                break;
              }
            }
          }
        });

        // Apply hemisphere proximity modifiers
        const selectedEssenceIds = Object.keys(essenceQuantities);
        const proximityResult =
          calculateHemisphereProximityModifier(selectedEssenceIds);
        totalCost *= proximityResult.modifier;

        // Update the display and input
        const baseCost = totalCost;
        const costInput = document.getElementById("magic-cost-input");
        const costDisplay = document.getElementById("calculated-base-cost");

        if (costInput) {
          costInput.value = Number(baseCost).toFixed(2);
        }

        if (costDisplay) {
          // Show proximity modifier info if applicable
          let displayText = `Custo Base: ${Number(baseCost).toFixed(2)}`;
          if (proximityResult.details.length > 0) {
            displayText += ` (×${proximityResult.modifier.toFixed(
              2
            )} por hemisférios diferentes)`;
          }
          costDisplay.textContent = displayText;
        }

        // Also update final cost when base cost changes
        updateFinalCostDisplay();
      }

      // Function to calculate and update final cost display
      function updateFinalCostDisplay() {
        // Get base cost
        const costInput = document.getElementById("magic-cost-input");
        const baseCost = costInput ? parseInt(costInput.value) || 1 : 1;

        // Get component selections
        const componentSelects = document.querySelectorAll(
          ".magic-component-select"
        );

        let totalModifier = 1.0;

        // Apply modifiers from each field selection
        componentSelects.forEach((select) => {
          const fieldId = select.dataset.fieldId;
          const optionId = select.value;

          if (!optionId) return;

          const field = magicManager.componentFields.find(
            (f) => f.id === fieldId
          );
          if (!field) return;

          const option = field.options.find((o) => o.id === optionId);
          if (option && option.costModifier) {
            totalModifier *= option.costModifier;
          }
        });

        const finalCost = Math.ceil(baseCost * totalModifier);
        const finalCostDisplay = document.getElementById(
          "calculated-final-cost"
        );
        const finalCostInput = document.getElementById(
          "magic-final-cost-input"
        );

        if (finalCostDisplay) {
          finalCostDisplay.textContent = `Custo Final: ${finalCost}`;
        }

        if (finalCostInput) {
          finalCostInput.textContent = `Custo Final: ${finalCost}`;
        }

        // Update dice display
        updateFinalDiceDisplay();
      }

      // Update dice display based on selected essences
      // Update dice display based on selected essence quantities
      function updateFinalDiceDisplay() {
        const essenceQuantityInputs =
          document.querySelectorAll(".essence-quantity");
        const essenceQuantities = {};

        // Collect essence quantities (only from checked essences)
        essenceQuantityInputs.forEach((input) => {
          const essenceId = input.dataset.essenceId;
          const checkbox = document.getElementById(
            `essence-checkbox-${essenceId}`
          );
          const quantity = parseInt(input.value) || 0;

          // Only include essences where checkbox is checked and quantity > 0
          if (checkbox && checkbox.checked && quantity > 0) {
            essenceQuantities[essenceId] = quantity;
          }
        });

        // Create temporary magic to calculate dice
        const componentSelects = document.querySelectorAll(
          ".magic-component-select"
        );
        const componentSelections = {};
        componentSelects.forEach((select) => {
          const fieldId = select.dataset.fieldId;
          const value = select.value;
          if (value) {
            componentSelections[fieldId] = value;
          }
        });

        const tempMagic = new Magic(
          "temp",
          componentSelections,
          essenceQuantities
        );

        const finalDice = tempMagic.getFinalDice();
        const finalDiceDisplay = tempMagic.getFinalDiceDisplay(finalDice);

        const finalDiceDisplayElement = document.getElementById(
          "calculated-final-dice"
        );
        const diceInput = document.getElementById("magic-dice-input");

        if (finalDiceDisplayElement) {
          finalDiceDisplayElement.textContent = `Dados: ${finalDiceDisplay}`;
        }

        if (diceInput) {
          diceInput.value = finalDice === "0" ? "" : finalDice;
          diceInput.placeholder = finalDice === "0" ? "Nenhum dado" : finalDice;
        }
      }

      // Functions for UI interaction
      function addMagicSpell() {
        const nameInput = document.getElementById("magic-name-input");
        const costInput = document.getElementById("magic-cost-input");
        const diceInput = document.getElementById("magic-dice-input");
        const componentSelects = document.querySelectorAll(
          ".magic-component-select"
        );
        const essenceQuantityInputs =
          document.querySelectorAll(".essence-quantity");

        if (!nameInput || !costInput || !diceInput) {
          alert("Erro: Elementos de entrada não encontrados.");
          return;
        }

        const name = nameInput.value;
        const baseCost = parseInt(costInput.value) || 1;
        const dice = diceInput.value.trim() || null;

        // Collect essence quantities (only from checked essences)
        const essenceQuantities = {};
        essenceQuantityInputs.forEach((input) => {
          const essenceId = input.dataset.essenceId;
          const checkbox = document.getElementById(
            `essence-checkbox-${essenceId}`
          );
          const quantity = parseInt(input.value) || 0;

          // Only include essences where checkbox is checked and quantity > 0
          if (checkbox && checkbox.checked && quantity > 0) {
            essenceQuantities[essenceId] = quantity;
          }
        });

        // Collect component selections
        const componentSelections = {};
        componentSelects.forEach((select) => {
          const fieldId = select.dataset.fieldId;
          const value = select.value;
          if (value) {
            componentSelections[fieldId] = value;
          }
        });

        if (
          magicManager.addMagicWithEssences(
            name,
            componentSelections,
            essenceQuantities,
            baseCost,
            dice
          )
        ) {
          // Clear inputs on success
          nameInput.value = "";
          costInput.value = "1";
          diceInput.value = "";
          diceInput.placeholder = "Nenhum dado";

          // Reset all component selects to default values
          componentSelects.forEach((select) => {
            const fieldId = select.dataset.fieldId;
            const field = magicManager.componentFields.find(
              (f) => f.id === fieldId
            );

            if (field && field.required && field.options.length > 0) {
              // Set required fields to their first option
              select.value = field.options[0].id;
            } else {
              // Set optional fields to empty
              select.value = "";
            }
          });

          // Reset essence quantity inputs to 0 but keep checkboxes checked
          essenceQuantityInputs.forEach((input) => {
            const essenceId = input.dataset.essenceId;
            const checkbox = document.getElementById(
              `essence-checkbox-${essenceId}`
            );

            // Only reset quantity to 0, keep checkboxes and enabled state as they are
            input.value = "0";

            // If checkbox is unchecked, keep input disabled; if checked, keep it enabled
            if (checkbox && !checkbox.checked) {
              input.disabled = true;
            }
          });

          // Update base cost display
          updateBaseCostFromEssences();

          // Trigger auto-save
          clearTimeout(window.saveTimeout);
          window.saveTimeout = setTimeout(() => {
            saveCharacterDataToStorage();
          }, 500);
        }
      }

      // Handle keyboard input for magic creation
      function handleMagicInputKeypress(event) {
        if (event.key === "Enter") {
          event.preventDefault();
          addMagicSpell();
        }
      }

      // Function to roll magic dice
      function rollMagicDice(magicId) {
        if (!magicManager) return;

        const magic = magicManager.magics.find((m) => m.id === magicId);
        if (!magic) return;

        const diceString = magic.dice || magic.getFinalDice();
        if (!diceString || diceString === "0") {
          alert("Esta magia não possui dados para rolar.");
          return;
        }

        // Parse and roll the dice
        const rollResult = parseDiceStringAndRoll(diceString);

        if (rollResult.error) {
          alert(`Erro ao rolar dados: ${rollResult.error}`);
          return;
        }

        // Show roll result
        const resultMessage = `🎲 ${
          magic.name
        }\n\nDados: ${diceString}\nResultado: ${
          rollResult.total
        }\n\nDetalhes: ${rollResult.details.join(", ")}`;
        alert(resultMessage);
      }

      // Function to parse dice string and roll dice
      function parseDiceStringAndRoll(diceString) {
        try {
          // Split by + to handle multiple dice types (e.g., "2d4 + 1d6")
          const diceParts = diceString.split("+").map((part) => part.trim());
          let total = 0;
          const details = [];

          for (const part of diceParts) {
            // Parse each dice part (e.g., "2d4")
            const diceMatch = part.match(/(\d+)d(\d+)/);
            if (!diceMatch) {
              return { error: `Formato de dado inválido: ${part}` };
            }

            const count = parseInt(diceMatch[1]);
            const sides = parseInt(diceMatch[2]);

            if (count <= 0 || sides <= 0) {
              return { error: `Valores inválidos: ${count}d${sides}` };
            }

            // Roll the dice
            const rolls = [];
            let partTotal = 0;
            for (let i = 0; i < count; i++) {
              const roll = Math.floor(Math.random() * sides) + 1;
              rolls.push(roll);
              partTotal += roll;
            }

            total += partTotal;
            details.push(
              `${count}d${sides}: [${rolls.join(", ")}] = ${partTotal}`
            );
          }

          return {
            total: total,
            details: details,
            error: null,
          };
        } catch (error) {
          return { error: `Erro ao processar dados: ${error.message}` };
        }
      }

      // Function to clear all magics (can be called from UI)
      function clearAllMagics() {
        if (magicManager) {
          magicManager.clearAllMagics();

          // Trigger auto-save
          clearTimeout(window.saveTimeout);
          window.saveTimeout = setTimeout(() => {
            saveCharacterDataToStorage();
          }, 500);
        }
      }
      function toggleAllSectionsPreview() {
        const previewDiv = document.getElementById("all-sections-preview");
        if (previewDiv) {
          if (previewDiv.style.display === "none") {
            previewDiv.style.display = "block";
          } else {
            previewDiv.style.display = "none";
          }
        }
      }

      // Generic info popup functions that can be reused for any type of content
      function showInfo(type, title, content, customClasses = "") {
        const overlayId = `${type}-info-overlay`;
        const popupId = `${type}-info-popup`;

        // Create overlay if it doesn't exist
        let overlay = document.getElementById(overlayId);
        if (!overlay) {
          overlay = document.createElement("div");
          overlay.id = overlayId;
          overlay.className = `essence-info-popup-overlay ${customClasses}`;
          overlay.onclick = () => hideInfo(type);
          document.body.appendChild(overlay);
        }

        // Create popup if it doesn't exist
        let popup = document.getElementById(popupId);
        if (!popup) {
          popup = document.createElement("div");
          popup.id = popupId;
          popup.className = `essence-info-popup ${customClasses}`;
          document.body.appendChild(popup);
        }

        // Set popup content
        popup.innerHTML = `
          <div class="essence-info-popup-header">
            <h3 class="essence-info-popup-title">${title}</h3>
            <button class="essence-info-popup-close" onclick="hideInfo('${type}')" title="Fechar">×</button>
          </div>
          <div class="essence-info-popup-content">
            ${content}
          </div>
        `;

        // Show overlay and popup
        overlay.classList.add("show");
        popup.classList.add("show");

        // Store current popup type for escape key handling
        document.body.dataset.currentPopupType = type;

        // Prevent body scroll
        document.body.style.overflow = "hidden";
      }

      function hideInfo(type) {
        const overlayId = `${type}-info-overlay`;
        const popupId = `${type}-info-popup`;

        const overlay = document.getElementById(overlayId);
        const popup = document.getElementById(popupId);

        if (overlay) {
          overlay.classList.remove("show");
        }
        if (popup) {
          popup.classList.remove("show");
        }

        // Clear current popup type
        delete document.body.dataset.currentPopupType;

        // Restore body scroll
        document.body.style.overflow = "";
      }

      // Hide any currently visible popup
      function hideCurrentPopup() {
        const currentType = document.body.dataset.currentPopupType;
        if (currentType) {
          hideInfo(currentType);
        }
      }

      // Close popup with Escape key - now works with any popup type
      document.addEventListener("keydown", function (event) {
        if (event.key === "Escape") {
          hideCurrentPopup();
        }
      });
    </script>
  </body>
</html>
