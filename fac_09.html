<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ficha de Personagem - Sistema FAC</title>
    <!-- Bootstrap 5 CSS -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <style>
      .hexagon-container {
        display: flex;
        justify-content: center;
        margin: 10px 0;
      }
      .hexagon {
        width: 40px;
        height: 35px;
        border: 2px solid #333;
        margin: 2px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        clip-path: polygon(
          25% 0%,
          75% 0%,
          100% 50%,
          75% 100%,
          25% 100%,
          0% 50%
        );
        background: white;
      }
      .attribute-circle {
        width: 80px;
        height: 80px;
        border: 3px solid #333;
        border-radius: 50%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        background: white;
        margin: 10px auto;
      }
      .attribute-label {
        font-size: 12px;
        font-weight: bold;
      }
      .attribute-value {
        font-size: 20px;
        font-weight: bold;
      }
      .skill-section {
        border: 2px solid #333;
        padding: 10px;
        margin: 5px 0;
        background: #f8f9fa;
      }
      .section-title {
        background: #333;
        color: white;
        padding: 5px 10px;
        margin: -10px -10px 10px -10px;
        font-weight: bold;
        text-align: center;
      }
      .checkbox-list {
        columns: 1;
        column-gap: 20px;
      }
      .form-check {
        margin-bottom: 8px;
        break-inside: avoid;
      }
      .skill-levels {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
        padding: 4px;
        border: 1px solid #e0e0e0;
        border-radius: 4px;
        background: white;
      }
      .skill-name {
        font-weight: 500;
        min-width: 120px;
        margin-bottom: 0;
      }
      .skill-level-boxes {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .skill-level {
        margin: 0 2px;
        width: 16px;
        height: 16px;
      }
      .level-label {
        font-size: 11px;
        font-weight: bold;
        margin: 0 4px 0 0;
        min-width: 8px;
        text-align: center;
      }
      .skill-levels.disabled {
        opacity: 0.4;
        background: #f8f9fa;
      }
      .skill-levels.disabled .skill-level {
        cursor: not-allowed;
      }
      .skill-level:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .skill-level:disabled + .level-label {
        color: #6c757d;
        opacity: 0.5;
      }
      .hp-mana-section {
        border: 2px solid #333;
        padding: 10px;
        text-align: center;
      }
      .large-input {
        font-size: 18px;
        text-align: center;
        font-weight: bold;
      }
      .attack-table th,
      .attack-table td {
        text-align: center;
        vertical-align: middle;
      }
      .resources-section,
      .inventory-section {
        border: 2px solid #333;
        background: white;
        min-height: 200px;
      }
      .section-header {
        background: #333;
        color: white;
        padding: 10px;
        text-align: center;
        font-weight: bold;
        margin: 0;
      }
      .point-category {
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 5px;
        margin: 2px;
        background: #f8f9fa;
      }
      .point-category.total-points {
        background: #fff3cd;
        border-color: #ffeaa7;
      }
      .point-label {
        font-size: 12px;
        font-weight: bold;
        color: #666;
        margin-bottom: 5px;
      }
      .point-value {
        font-size: 24px;
        font-weight: bold;
        color: #333;
        margin-bottom: 5px;
      }
      .total-points .point-value {
        color: #856404;
      }
      .point-cost {
        font-size: 10px;
        color: #999;
      }
      .points-exceeded {
        background-color: #f8d7da !important;
        border-color: #dc3545 !important;
        color: #721c24 !important;
      }
      .attribute-exceeded {
        background-color: #f8d7da !important;
        border-color: #dc3545 !important;
      }
      .skill-exceeded {
        background-color: #fff3cd !important;
        border-color: #ffc107 !important;
      }

      /* Magic Creation Section Styles */
      .magic-item {
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 10px;
        margin-bottom: 8px;
        background: #fff;
        transition: all 0.2s ease;
      }

      .magic-item:hover {
        border-color: #007bff;
        box-shadow: 0 2px 4px rgba(0, 123, 255, 0.1);
      }

      .magic-name {
        font-weight: bold;
        color: #333;
        font-size: 14px;
        margin-bottom: 4px;
      }

      .magic-component {
        font-size: 12px;
        color: #666;
        background: #f8f9fa;
        padding: 2px 6px;
        border-radius: 4px;
        display: inline-block;
        margin-right: 8px;
      }

      .magic-cost {
        font-size: 12px;
        color: #007bff;
        font-weight: bold;
      }

      .magic-details {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 4px;
      }

      .magic-remove-btn {
        float: right;
        background: none;
        border: none;
        color: #dc3545;
        font-size: 16px;
        cursor: pointer;
        padding: 0;
        line-height: 1;
      }

      .magic-remove-btn:hover {
        color: #c82333;
      }

      .magic-roll-btn {
        margin-left: 10px;
        font-size: 0.75rem;
        padding: 2px 6px;
        border-radius: 4px;
      }

      .magic-roll-btn:hover {
        background-color: #007bff;
        border-color: #007bff;
        color: white;
      }

      .magic-cost-breakdown {
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 8px;
      }

      #magic-list-container {
        background: #f8f9fa;
        flex: 1;
        overflow-y: auto;
      }

      /* Ensure both magic columns have equal height */
      .magic-creation-row {
        display: flex;
      }

      .magic-creation-row .col-md-6 {
        display: flex;
        flex-direction: column;
      }

      .magic-creation-form,
      .magic-list-section {
        flex: 1;
        display: flex;
        flex-direction: column;
      }

      #magic-list-container {
        background: #f8f9fa;
        flex: 1;
        overflow-y: auto;
      }

      #magic-list-container:empty::before {
        content: "Nenhuma magia adicionada ainda.";
        color: #6c757d;
        font-style: italic;
        display: block;
        text-align: center;
        padding: 20px;
      }

      /* Magic Components Selection Styles */
      #magic-components-container {
        background: #f8f9fa;
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 15px;
      }

      .magic-component-select {
        margin-bottom: 10px;
      }

      .form-label {
        font-weight: 600;
        margin-bottom: 5px;
      }

      .form-text {
        font-size: 12px;
        margin-top: 3px;
      }

      /* Essences Selection Styles */
      .essence-checkboxes {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
      }

      .essence-quantity-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        min-width: 120px;
        margin-bottom: 8px;
      }

      .essence-label {
        font-size: 0.875rem;
        text-align: center;
        margin-bottom: 4px;
        cursor: default;
      }

      .essence-quantity {
        width: 60px;
        height: 32px;
        text-align: center;
        font-size: 0.875rem;
        border: 1px solid #ced4da;
        border-radius: 4px;
      }

      .essence-quantity:focus {
        border-color: #007bff;
        box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
      }

      .essence-checkboxes .form-check {
        margin-bottom: 5px;
      }

      /* Essence Info Popup Styles */
      .essence-info-btn {
        background: none;
        border: none;
        color: #007bff;
        font-size: 10px;
        padding: 0;
        margin-left: 2px;
        vertical-align: super;
        cursor: pointer;
        transition: all 0.2s ease;
        line-height: 1;
        font-weight: bold;
      }

      .essence-info-btn:hover {
        color: #0056b3;
        text-decoration: underline;
      }

      .essence-info-popup {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        border: 2px solid #007bff;
        border-radius: 8px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        z-index: 1000;
        max-width: 400px;
        min-width: 300px;
        padding: 20px;
        display: none;
      }

      .essence-info-popup.show {
        display: block;
        animation: fadeIn 0.3s ease;
      }

      .essence-info-popup-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 1px solid #e0e0e0;
      }

      .essence-info-popup-title {
        font-size: 18px;
        font-weight: bold;
        color: #333;
        margin: 0;
      }

      .essence-info-popup-close {
        background: none;
        border: none;
        font-size: 20px;
        color: #999;
        cursor: pointer;
        padding: 0;
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 4px;
      }

      .essence-info-popup-close:hover {
        background-color: #f0f0f0;
        color: #333;
      }

      .essence-info-popup-content {
        color: #555;
        line-height: 1.5;
        font-size: 14px;
      }

      .essence-info-popup-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 999;
        display: none;
      }

      .essence-info-popup-overlay.show {
        display: block;
        animation: fadeIn 0.3s ease;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      .magic-essences {
        font-size: 12px;
        color: #6c757d;
        margin-bottom: 5px;
      }

      .magic-components {
        font-size: 12px;
        color: #6c757d;
        margin-bottom: 5px;
      }

      .magic-cost-breakdown {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .magic-base-cost {
        font-size: 12px;
        color: #28a745;
      }

      .magic-final-cost {
        font-weight: bold;
        color: #007bff;
      }

      .magic-proximity {
        font-size: 11px;
        margin-bottom: 3px;
      }

      .magic-proximity small {
        background-color: #e3f2fd;
        padding: 2px 6px;
        border-radius: 3px;
        border: 1px solid #90caf9;
      }

      .form-check-label strong {
        color: #495057;
      }
    </style>
  </head>
  <body class="bg-light">
    <div class="container-fluid py-3">
      <!-- Header Section - Character Name and Description -->
      <div class="row mb-3">
        <div class="col-md-4">
          <div class="card">
            <div class="card-header bg-dark text-white text-center">
              <strong>Nome do Personagem</strong>
            </div>
            <div class="card-body">
              <input
                type="text"
                class="form-control form-control-lg text-center"
                placeholder="Nome do personagem"
              />
            </div>
          </div>
        </div>
        <div class="col-md-8">
          <div class="card">
            <div class="card-header bg-dark text-white text-center">
              <strong>Descri√ß√£o:</strong>
            </div>
            <div class="card-body">
              <textarea
                class="form-control"
                rows="4"
                placeholder="Descri√ß√£o do personagem..."
              ></textarea>
            </div>
          </div>
        </div>
      </div>

      <!-- Main Attributes Section -->
      <div class="row mb-3">
        <!-- Dynamic Skill Sections Container -->
        <div class="col-md-12" id="dynamic-skill-sections">
          <!-- All skill sections will be rendered here from JSON -->
        </div>
      </div>

      <!-- HP and Mana Section -->
      <div id="resource-sections-container">
        <!-- HP and Mana sections will be rendered here from JSON -->
      </div>

      <!-- Bottom Section - Movimento and Point Calculator -->
      <div class="row mb-3 justify-content-center">
        <!-- Movimento -->
        <div class="col-md-3">
          <div class="card">
            <div class="card-header bg-secondary text-white text-center">
              <strong>Movimento</strong>
            </div>
            <div class="card-body text-center">
              <input
                type="number"
                class="form-control large-input mb-2"
                placeholder="Valor"
                id="movement"
              />
            </div>
          </div>
        </div>

        <!-- Point Calculator -->
        <div class="col-md-6">
          <div class="card">
            <div class="card-header bg-warning text-dark text-center">
              <strong>Calculadora de Pontos</strong>
            </div>
            <div class="card-body">
              <div class="row text-center">
                <div class="col-md-4">
                  <div class="point-category">
                    <div class="point-label">N√≠vel Atual</div>
                    <div
                      class="point-value"
                      id="character-level"
                      contenteditable="true"
                      style="cursor: text"
                      onclick="editLevel(this)"
                      onblur="saveLevel(this)"
                      onkeypress="handleLevelKeypress(event, this)"
                    >
                      0
                    </div>
                    <div class="point-cost">n√≠vel</div>
                  </div>
                </div>
                <div class="col-md-4">
                  <div class="point-category">
                    <div class="point-label">Per√≠cias Prim√°rias</div>
                    <div class="point-value" id="attribute-points">0</div>
                    <div class="point-cost">
                      <span id="attribute-used">0</span> /
                      <span id="attribute-available">5</span> dispon√≠veis
                    </div>
                  </div>
                </div>
                <div class="col-md-4">
                  <div class="point-category">
                    <div class="point-label">Per√≠cias Secund√°rias</div>
                    <div class="point-value" id="skill-points">0</div>
                    <div class="point-cost">
                      <span id="skill-used">0</span> /
                      <span id="skill-available">10</span> dispon√≠veis
                    </div>
                  </div>
                </div>
              </div>
              <div class="row mb-3">
                <div class="col-md-4">
                  <div class="point-category">
                    <div class="point-label">Prest√≠gio</div>
                    <div class="point-value" id="prestigio-points">0</div>
                    <div class="point-cost">
                      <span id="prestigio-used">0</span> pontos de atributo
                    </div>
                  </div>
                </div>
              </div>
              <!-- Clear data button -->
              <div class="text-center mt-2">
                <button
                  type="button"
                  class="btn btn-sm btn-outline-secondary"
                  onclick="clearSavedCharacterData()"
                  title="Limpar dados salvos automaticamente"
                >
                  üóëÔ∏è Limpar Dados Salvos
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Additional Dynamic Skill Sections Container -->
      <div class="row mb-3" id="additional-skill-sections">
        <!-- Additional skill sections will be rendered here from JSON -->
      </div>

      <!-- Resources, Inventory and Attacks Section -->
      <div class="row">
        <!-- Resources -->
        <div class="col-md-4">
          <div class="resources-section" data-section="recursos">
            <div
              class="section-header"
              onclick="handleSectionClick('recursos')"
              style="cursor: pointer"
            >
              Recursos
            </div>
            <div class="p-3">
              <textarea
                class="form-control"
                rows="8"
                placeholder="Liste seus recursos aqui..."
              ></textarea>
            </div>
          </div>
        </div>

        <!-- Inventory -->
        <div class="col-md-4">
          <div class="resources-section">
            <div class="section-header">Invent√°rio</div>
            <div class="p-3">
              <textarea
                class="form-control"
                rows="8"
                placeholder="Lista de itens do invent√°rio..."
              ></textarea>
            </div>
          </div>
        </div>

        <!-- Attacks -->
        <div class="col-md-4">
          <div class="resources-section">
            <div class="section-header">Ataques</div>
            <div class="p-3">
              <table class="table table-sm attack-table">
                <thead>
                  <tr>
                    <th>Nome</th>
                    <th>Dano</th>
                    <th>Alcance</th>
                    <th>Tipo</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                  </tr>
                  <tr>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                    <td>
                      <input type="text" class="form-control form-control-sm" />
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </div>

      <!-- Magic Creation Section -->
      <div class="row mt-4">
        <div class="col-12">
          <div class="resources-section" id="magic-creation-section">
            <div class="section-header">‚ú® Cria√ß√£o de Magias</div>
            <div class="p-3">
              <div class="row magic-creation-row">
                <!-- Magic Creation Form -->
                <div class="col-md-6">
                  <div class="magic-creation-form">
                    <h6 class="mb-3">Adicionar Nova Magia</h6>
                    <div class="mb-3">
                      <label for="magic-name-input" class="form-label"
                        >Nome da Magia</label
                      >
                      <input
                        type="text"
                        class="form-control"
                        id="magic-name-input"
                        placeholder="Digite o nome da magia..."
                        onkeypress="handleMagicInputKeypress(event)"
                      />
                    </div>
                    <div class="mb-3">
                      <div
                        id="magic-essences-container"
                        class="p-2 bg-light border rounded"
                      >
                        <!-- Essences selection will be populated by JavaScript -->
                      </div>
                    </div>
                    <div class="mb-3">
                      <label class="form-label">Componentes da Magia</label>
                      <div id="magic-components-container" class="p-2">
                        <!-- Component select fields will be populated by JavaScript -->
                      </div>
                      <small class="text-muted"
                        >Configure os componentes para a magia. Campos marcados
                        com * s√£o obrigat√≥rios.</small
                      >
                    </div>
                    <div class="mb-3">
                      <label for="magic-cost-input" class="form-label"
                        >Custo Base (Calculado)</label
                      >
                      <div class="d-flex gap-2 align-items-center">
                        <input
                          type="number"
                          class="form-control"
                          id="magic-cost-input"
                          placeholder="1"
                          value="1"
                          min="1"
                          readonly
                          title="O custo base √© calculado automaticamente pelas ess√™ncias selecionadas"
                        />
                        <span
                          id="magic-final-cost-input"
                          class="badge bg-success fs-6"
                        >
                          Custo Final: 1
                        </span>
                      </div>
                    </div>
                    <div class="mb-3">
                      <label for="magic-dice-input" class="form-label"
                        >Dados Finais</label
                      >
                      <div class="d-flex gap-2 align-items-center">
                        <input
                          type="text"
                          class="form-control"
                          id="magic-dice-input"
                          placeholder="Nenhum dado"
                          title="Dados calculados automaticamente pelas ess√™ncias. Voc√™ pode editar se necess√°rio."
                        />
                        <small class="text-muted"
                          >Calculado automaticamente, edit√°vel</small
                        >
                      </div>
                    </div>
                    <button
                      type="button"
                      class="btn btn-primary"
                      onclick="addMagicSpell()"
                    >
                      ‚ûï Adicionar Magia
                    </button>
                  </div>
                </div>

                <!-- Magic List Display -->
                <div class="col-md-6">
                  <div class="magic-list-section">
                    <h6 class="mb-3">Magias Conhecidas</h6>
                    <div id="magic-list-container" class="border rounded p-2">
                      <p class="text-muted text-center" id="no-magic-message">
                        Nenhuma magia adicionada ainda.
                      </p>
                    </div>
                    <div
                      class="mt-2 d-flex justify-content-between align-items-center"
                    >
                      <small class="text-muted"
                        >Total de magias: <span id="magic-count">0</span></small
                      >
                      <small class="text-info"
                        ><strong
                          >Custo Total:
                          <span id="magic-total-cost">0</span></strong
                        ></small
                      >
                      <button
                        type="button"
                        class="btn btn-sm btn-outline-danger"
                        onclick="clearAllMagics()"
                        title="Remover todas as magias"
                      >
                        üóëÔ∏è Limpar Todas
                      </button>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Bootstrap 5 JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>

    <script>
      // Extensible Component System for Character Sheet
      class SkillSectionComponent {
        constructor(containerId) {
          this.container = document.getElementById(containerId);
        }

        // Render a skill section from JSON configuration
        renderSection(config) {
          const attributeHtml = config.attribute
            ? `
            <div class="text-center mb-3">
              <div class="attribute-circle">
                <div class="attribute-label">${config.attribute.label}</div>
                <input
                  type="number"
                  class="form-control form-control-sm"
                  style="width: 50px; text-align: center"
                  value="0"
                  min="0"
                  max="3"
                  data-attribute="${config.attribute.dataAttribute}"
                  onchange="validateAttributeAndSkills('${config.attribute.dataAttribute}', '${config.sectionId}')"
                />
              </div>
              <button class="btn btn-sm btn-outline-primary mt-1" onclick="rollAttribute('${config.attribute.dataAttribute}', '${config.attribute.label}')" title="Rolar ${config.attribute.label}">
                üé≤ Rolar
              </button>
            </div>
          `
            : "";

          console.log("---config");
          console.log(config);

          const sectionHtml = `
                    <div class="skill-${config.sectionId}-section">
                        ${attributeHtml}
                        <div class="section-title" onclick="${
                          config.onClick || "void(0)"
                        }" style="cursor: ${
            config.onClick ? "pointer" : "default"
          }">
                            ${config.label}
                        </div>
                        <div class="checkbox-list">
                            ${this.generateCheckboxes(
                              config.skills,
                              config.sectionId
                            )}
                            ${
                              config.prestigios && config.prestigios.length > 0
                                ? `
                            <div class="prestigio-divider" style="margin: 15px 0; border-top: 2px solid #007bff; position: relative;">
                                <span style="background: #f8f9fa; padding: 0 10px; position: absolute; top: -10px; left: 50%; transform: translateX(-50%); font-weight: bold; color: #007bff;">Prest√≠gio</span>
                            </div>
                            ${this.generatePrestigioCheckboxes(
                              config.prestigios,
                              config.sectionId
                            )}
                            `
                                : ""
                            }
                        </div>
                    </div>
                `;
          return sectionHtml;
        }

        // Generate checkboxes based on skills array - now with 3 levels
        generateCheckboxes(skills, sectionId) {
          return skills
            .map(
              (skill, index) => `
                    <div class="form-check skill-levels" data-skill="${
                      skill.name
                    }" data-section="${sectionId}">
                        <label class="form-check-label skill-name">${
                          skill.name
                        }${
                skill.info
                  ? `<button class="essence-info-btn" onclick="showInfo('skill-${skill.name
                      .replace(/\s+/g, "-")
                      .toLowerCase()}', '${skill.name}', \`${
                      skill.info
                    }\`)" title="Informa√ß√µes sobre ${skill.name}">‚Ñπ</button>`
                  : ""
              }</label>
                        <div class="skill-level-boxes">
                            <input class="form-check-input skill-level" type="checkbox" id="${sectionId}_${index}_1" data-skill="${
                skill.name
              }" data-section="${sectionId}" data-level="1" onclick="toggleSkillLevel(this, 1)">
                            <label class="level-label" for="${sectionId}_${index}_1">1</label>
                            <input class="form-check-input skill-level" type="checkbox" id="${sectionId}_${index}_2" data-skill="${
                skill.name
              }" data-section="${sectionId}" data-level="2" onclick="toggleSkillLevel(this, 2)">
                            <label class="level-label" for="${sectionId}_${index}_2">2</label>
                            <input class="form-check-input skill-level" type="checkbox" id="${sectionId}_${index}_3" data-skill="${
                skill.name
              }" data-section="${sectionId}" data-level="3" onclick="toggleSkillLevel(this, 3)">
                            <label class="level-label" for="${sectionId}_${index}_3">3</label>
                            <button class="btn btn-xs btn-outline-success ms-2" onclick="rollSkill('${sectionId}', '${
                skill.name
              }')" title="Rolar ${
                skill.name
              }" style="font-size: 10px; padding: 2px 6px;">
                              üé≤
                            </button>
                        </div>
                    </div>
                `
            )
            .join("");
        }

        // Generate special Prest√≠gio checkboxes (1 attribute point each)
        generatePrestigioCheckboxes(prestigios, sectionId) {
          console.log("----Generationg prestio checkbox----");
          return prestigios
            .map((prestigio, index) => {
              const infoButton = prestigio.info
                ? `<button class="essence-info-btn" onclick="showInfo('prestigio-${prestigio.name
                    .replace(/\s+/g, "-")
                    .toLowerCase()}', '${
                    prestigio.name
                  }', '${prestigio.info.replace(
                    /'/g,
                    "&#39;"
                  )}', '')" title="Informa√ß√µes sobre ${
                    prestigio.name
                  }">‚Ñπ</button>`
                : "";

              return `
                    <div class="form-check skill-levels prestigio-skill" data-skill="${prestigio.name}" data-section="${sectionId}">
                        <label class="form-check-label skill-name" style="color: #007bff; font-weight: bold;">${prestigio.name}${infoButton}</label>
                        <div class="skill-level-boxes">
                            <input class="form-check-input prestigio-level" type="checkbox" id="${sectionId}_prestigio_${index}" data-skill="${prestigio.name}" data-section="${sectionId}" data-prestigio="true" onclick="togglePrestigioSkill(this)">
                            <label class="level-label" for="${sectionId}_prestigio_${index}" style="color: #007bff;">‚úì</label>
                            <span class="prestigio-cost" style="font-size: 10px; color: #666; margin-left: 5px;">(1 pt. atributo)</span>
                        </div>
                    </div>
                `;
            })
            .join("");
        }

        // Render multiple sections from JSON array
        renderFromJson(sectionsConfig) {
          let html = "";
          sectionsConfig.forEach((config) => {
            html += this.renderSection(config);
          });
          if (this.container) {
            this.container.innerHTML = html;
          }
          return html;
        }
      }

      // Resource/Stat Component for HP, Mana, etc.
      class ResourceComponent {
        constructor() {}

        // Render a resource section from JSON configuration
        renderResourceSection(config) {
          const diceSelector = config.diceType
            ? `
            <div class="col-12 mb-2">
              <div class="d-flex align-items-center justify-content-center">
                <label class="form-label me-2 mb-0"><strong>Dado:</strong></label>
                <select class="form-select form-select-sm dice-selector" style="width: auto;" id="${
                  config.diceSelectId
                }" onchange="onDiceTypeChange('${config.resourceName}')">
                  <option value="d4" ${
                    config.diceType === "d4" ? "selected" : ""
                  }>d4</option>
                  <option value="d6" ${
                    config.diceType === "d6" ? "selected" : ""
                  }>d6</option>
                  <option value="d8" ${
                    config.diceType === "d8" ? "selected" : ""
                  }>d8</option>
                  <option value="d10" ${
                    config.diceType === "d10" ? "selected" : ""
                  }>d10</option>
                  <option value="d12" ${
                    config.diceType === "d12" ? "selected" : ""
                  }>d12</option>
                </select>
                <button class="btn btn-sm btn-outline-warning ms-2" onclick="rollResourceDice('${
                  config.resourceName
                }', '${
                config.diceSelectId
              }')" title="Substituir rolls autom√°ticos por rolls manuais">
                  üé≤ Manual
                </button>
              </div>
            </div>
          `
            : "";

          const resourceHtml = `
            <div class="col-md-${config.columnSize || 6}">
              <div class="hp-mana-section">
                <div class="row">
                  ${diceSelector}
                  <div class="col-4">
                    <label class="form-label"><strong>Base ${
                      config.resourceName
                    }</strong></label>
                    <input
                      type="number"
                      class="form-control large-input"
                      id="${config.baseId}"
                      placeholder="${config.basePlaceholder || "0"}"
                      readonly
                      style="background-color: #f8f9fa; cursor: not-allowed;"
                    />
                    <button class="btn btn-xs btn-outline-info mt-1" style="font-size: 10px; padding: 2px 6px;" onclick="showResourceRollHistory('${
                      config.resourceName
                    }')" title="Ver hist√≥rico de rolls">
                      üìã Hist√≥rico
                    </button>
                  </div>
                  <div class="col-4">
                    <label class="form-label"><strong>Extra ${
                      config.resourceName
                    }</strong></label>
                    <input
                      type="number"
                      class="form-control large-input"
                      id="${config.extraId}"
                      placeholder="${config.extraPlaceholder || "0"}"
                      onchange="calculateResourceTotal('${
                        config.resourceName
                      }')"
                    />
                  </div>
                  <div class="col-4">
                    <label class="form-label"><strong>${
                      config.totalLabel
                    }</strong></label>
                    <input
                      type="number"
                      class="form-control large-input"
                      id="${config.totalId}"
                      placeholder="${config.totalPlaceholder || "0"}"
                      readonly
                      style="background-color: #f8f9fa; cursor: not-allowed;"
                    />
                  </div>
                  <div class="col-12 mt-2">
                    <label class="form-label"><strong>${
                      config.currentLabel
                    }</strong></label>
                    <input
                      type="number"
                      class="form-control large-input"
                      id="${config.currentId}"
                      placeholder="${config.currentPlaceholder || "0"}"
                    />
                  </div>
                </div>
              </div>
            </div>
          `;
          return resourceHtml;
        }

        // Render multiple resource sections from JSON array
        renderFromJson(resourcesConfig, containerId) {
          const container = document.getElementById(containerId);
          if (!container) return "";

          let html = '<div class="row mb-3">';
          resourcesConfig.forEach((config) => {
            html += this.renderResourceSection(config);
          });
          html += "</div>";

          container.innerHTML = html;
          return html;
        }
      }

      // Function to update dice selector availability based on character level
      function updateDiceSelectorAvailability() {
        const level =
          parseInt(document.getElementById("character-level")?.textContent) ||
          0;
        const diceSelectors = document.querySelectorAll(".dice-selector");

        diceSelectors.forEach((selector) => {
          if (level > 0) {
            // Disable selector and gray it out for levels above 0
            selector.disabled = true;
            selector.style.opacity = "0.5";
            selector.style.cursor = "not-allowed";
          } else {
            // Enable selector for level 0 (character creation)
            selector.disabled = false;
            selector.style.opacity = "1";
            selector.style.cursor = "pointer";
          }
        });
      }

      // Function to calculate resource total (Base + Extra = Total)
      function calculateResourceTotal(resourceName) {
        const config = resourceSectionsConfig.find(
          (c) => c.resourceName === resourceName
        );
        if (!config) return;

        const baseInput = document.getElementById(config.baseId);
        const extraInput = document.getElementById(config.extraId);
        const totalInput = document.getElementById(config.totalId);

        if (baseInput && extraInput && totalInput) {
          const baseValue = parseInt(baseInput.value) || 0;
          const extraValue = parseInt(extraInput.value) || 0;
          const total = baseValue + extraValue;

          totalInput.value = total;

          // Trigger auto-save after calculation
          clearTimeout(window.saveTimeout);
          window.saveTimeout = setTimeout(() => {
            saveCharacterDataToStorage();
          }, 500);
        }
      }

      // Configuration JSON for resource sections
      const resourceSectionsConfig = [
        {
          resourceName: "HP",
          totalLabel: "HP Total",
          currentLabel: "HP Atual",
          baseId: "hp-base",
          extraId: "hp-extra",
          totalId: "hp-total",
          currentId: "hp-current",
          columnSize: 6,
          diceType: "d6",
          diceSelectId: "hp-dice-select",
        },
        {
          resourceName: "Mana",
          totalLabel: "Mana Total",
          currentLabel: "Mana Atual",
          baseId: "mana-base",
          extraId: "mana-extra",
          totalId: "mana-total",
          currentId: "mana-current",
          columnSize: 6,
          diceType: "d6",
          diceSelectId: "mana-dice-select",
        },
        // You can easily add more resource types here:
        // {
        //   resourceName: "Stamina",
        //   totalLabel: "Stamina Total",
        //   currentLabel: "Stamina Atual",
        //   baseId: "stamina-base",
        //   extraId: "stamina-extra",
        //   totalId: "stamina-total",
        //   currentId: "stamina-current",
        //   columnSize: 6,
        //   diceType: "d8",
        //   diceSelectId: "stamina-dice-select"
        // }
      ];

      // Configuration JSON for skill sections
      const skillSectionsConfig = [
        // Conhecimento
        {
          label: "Conhecimento",
          sectionId: "conhecimento",
          onClick: "handleSectionClick('conhecimento')",
          attribute: { label: "CON", dataAttribute: "con" },
          skills: [
            {
              name: "Cartografia",
              info: " Descri√ß√£o: Implica na capacidade do jogador elaborarmapas e/ou compreender-los. <br><br><b>N√≠vel 1:</b> Permite ao jogador ler qualquer tipo de mapasimples e se guiar por ele sem dificuldade. <br><br><b>N√≠vel 2:</b> O segundo n√≠vel agracia o jogador com acapacidade de, dado um pouco de conhecimento deambiente, elaborar mapas ou preencher mapasincompletos. <br><br><b>N√≠vel 3:</b> Ao terceiro n√≠vel, qualquer mapa pode ser lidopelo jogador (comuns e m√°gicos), al√©m disso, o jogador √©capaz de otimizar rotas e encontrar atalhos comfacilidade, dobrando a velocidade de viagem de qualquerum que o acompanhe. Por fim, o jogador podeconfeccionar mapas de alt√≠ssima qualidade.",
            },
            {
              name: "Ci√™ncias",
              info: "Mede a capacidade intelectual geral da personagem.<br><br><b>N√≠vel 1:</b>Flat b√¥nus de +1 para todas as rolagens de conhecimento. <br><br><b>N√≠vel 2:</b>Aumento do flat b√¥nus para +2. <br><br><b>N√≠vel 3:</b>Aumento do flat b√¥nus para +3.",
            },
            {
              name: "Demoli√ß√£o",
              info: "Mede a capacidade do personagem de elaborar explosivos improvisados.<br><br><b>N√≠vel 1:</b>O jogador pode fazer uma bomba de fuma√ßa (dura um turno e aplica o efeito de cego em uma √°rea de 5m de raio) ou uma bomba de p√≥lvora negra que faz muito barulho. O pre√ßo delas sendo:<br>Bomba de Fuma√ßa: 10 de gold, necessita de 30 minutos para confec√ß√£o;<br>Bomba de P√≥lvora: 20 de gold, necessita de 1 hora para confec√ß√£o; <br><br><b>N√≠vel 2:</b>O personagem poder√° agora fazer uma amalgama de mana em suas bombas. Caso a bomba de fuma√ßa seja melhorada durar√° 3 turnos. J√° para a p√≥lvora negra causar√° 4d4 de dano para qualquer unidade dentro de um raio de 5 metros. <br><br><b>N√≠vel 3:</b>O jogador pode confeccionar uma bomba de alta pot√™ncia. Esta bomba causa 20d10 de dano em um raio de 50 metros, ela requer: 1000 pe√ßas de ouro e 2 dias de confec√ß√£o. Essa bomba pode causar efeitos extras a depender do mestre.",
            },
            {
              name: "Investiga√ß√£o",
              info: "Refere a capacidade do jogador de realizar uma busca de forma ativa de algo ou algu√©m.<br><br><b>N√≠vel 1:</b>Flat b√¥nus de +3 para rolagens desta per√≠cia. <br><br><b>N√≠vel 2:</b>Aumenta o flat b√¥nus para +5 em rolagens desta per√≠cia. <br><br><b>N√≠vel 3:</b>A personagem pode encontrar o mercado negro de uma regi√£o.",
            },
            {
              name: "Matem√°tica",
              info: "Mede o conhecimento do personagem em matem√°tica para fazer uma an√°lise r√°pida de trajet√≥rias e afins.<br><br><b>N√≠vel 1:</b>Proj√©teis f√≠sicos ou m√°gicos tem um aumento de 5 metros de alcance (vale para ataques de no m√≠nimo 20 metros). <br><br><b>N√≠vel 2:</b>Proj√©teis f√≠sicos ou m√°gicos tem um aumento de 15 metros de alcance (vale para ataques de no m√≠nimo 20 metros). <br><br><b>N√≠vel 3:</b>Proj√©teis f√≠sicos ou m√°gicos tem um aumento de 25 metros de alcance (vale para ataques de no m√≠nimo 20 metros).",
            },
            {
              name: "Medicina",
              info: "Per√≠cia utilizada para medir o conhecimento de um personagem em medicina, para poder efetuar testes de primeiro socorros em aliados ou NPCs.<br><br><b>N√≠vel 1:</b> <br><br>Recebe um flat b√¥nus de +3 para rolagens de medicina a cerca de conhecimentos te√≥ricos, tais como sobre anatomia, uso de rem√©dios, etc. O jogador pode usar uma a√ß√£o para estabilizar um aliado ca√≠do ao ch√£o sem ter de realizar qualquer teste de dificuldade ou ent√£o gastar recursos.<br><br><b>N√≠vel 2:</b>Aumento do b√¥nus para +5. O personagem recebe duas habilidades ao atingir este n√≠vel:<br> Primeiros Socorros: O personagem pode curar ferimentos de um jogador, dando a ele uma quantidade de pontos de vida igual a metade dos pontos de mana gastos para realizar a habilidade.<br>Interven√ß√£o: O jogador poder√° utilizar uma a√ß√£o e 20 pontos de mana para remover todos os pontos de um dentre os seguintes efeitos: envenenamento, sangramento, incendiado, congelado ou fraco. <br><br><b>N√≠vel 3:</b>O personagem torna-se proficiente em realizar cirurgias, um teste deve ser realizado e um kit cir√∫rgico ser√° consumido no processo, no entanto, o personagem pode remover qualquer les√£o aplicada ao jogador. O processo cir√∫rgico demora at√© 12 horas (a crit√©rio do mestre) e aplica 2 pontos de exaust√£o (o procedimento pode devolver at√© membros amputados ou vis√£o).",
            },
            {
              name: "Natureza",
              info: "Per√≠cia sobre os conhecimentos do personagem com o mundo natural e fen√¥menos que possam ser correlacionados a ele ou ao mundo m√°gico.<br><br><b>N√≠vel 1:</b>Flat b√¥nus de +3 para rolagens desta per√≠cia. <br><br><b>N√≠vel 2:</b>Aumenta o flat b√¥nus para +5 em rolagens desta per√≠cia. <br><br><b>N√≠vel 3:</b>A personagem recebe um desconto de 15 de gold na produ√ß√£o de venenos e po√ß√µes.",
            },
            {
              name: "Psicologia",
              info: "Dita a habilidade do personagem em ler outros seres sapientes, discernir inten√ß√µes e auxiliar em tratamento de personagens e NPCs.<br><br><b>N√≠vel 1:</b>O personagem pode gastar 15 pontos de mana para determinar se algu√©m esta mentindo para ele, sem necessidade de roll. <br><br><b>N√≠vel 2:</b>As t√©cnicas terap√™uticas do personagem se ampliam, permitindo com que ele possa uma vez por dia tratar um ponto de insanidade de um aliado. <br><br><b>N√≠vel 3:</b>O conhecimento do personagem em psicologia √© tamanho que ele pode, uma vez por dia, conversar com o grupo e remover 1 ponto de insanidade do grupo inteiro.",
            },
            {
              name: "Veterin√°ria",
              info: "Dita o conhecimento do personagem sobre como tratar animais e fazer primeiros socorros neles.<br><br><b>N√≠vel 1:</b>Recebe um flat b√¥nus de +3 para rolagens de medicina a cerca de conhecimentos te√≥ricos, tais como sobre anatomia, uso de rem√©dios, etc, em animais. O jogador pode gastar uma a√ß√£o para estabilizar um animal ca√≠do sem ser necess√°rio fazer qualquer teste de dificuldade ou ent√£o gastar recursos. <br><br><b>N√≠vel 2:</b>Aumento do b√¥nus para +5. O personagem recebe duas habilidades ao atingir este n√≠vel:<br>Primeiros Socorros: O personagem pode curar ferimentos de um animal, dando a ele uma quantidade de pontos de vida igual a metade dos pontos de mana gastos para realizar a habilidade.<br>Interven√ß√£o: O jogador poder√° utilizar uma a√ß√£o e 20 pontos de mana para, em um animal, remover todos os pontos dos seguintes efeitos: envenenamento, sangramento, incendiado, congelado ou fraco. <br><br><b>N√≠vel 3:</b>O personagem torna-se proficiente em realizar cirurgias em animais, um teste deve ser realizado e um kit cir√∫rgico ser√° consumido no processo, no entanto, o personagem pode remover qualquer les√£o ou 1 ponto de Morte aplicada ao animal, a menos de 1 semana. O processo cir√∫rgico demora at√© 12 horas (a crit√©rio do mestre) e aplica 2 pontos de exaust√£o (o procedimento pode devolver at√© membros amputados ou vis√£o).",
            },
          ],
          prestigios: [
            {
              name: "Acad√™mico",
              info: "Requisito: Voc√™ estuda com o professor Gabriel Ikawa.",
            },
            {
              name: "Mestre de Venenos",
              info: "Requisito: Conhecimento. O personagem √© um especialista em criar e utilizar venenos.",
            },
          ],
        },
        {
          label: "Social",
          sectionId: "social",
          onClick: "handleSectionClick('social')",
          attribute: { label: "SOC", dataAttribute: "soc" },
          skills: [
            {
              name: "Contar Hist√≥rias",
              info: "Uma per√≠cia que mede o qu√£o bem seu personagem pode contar hist√≥rias. <br><br><b>N√≠vel 1:</b>O personagem poder√° contar hist√≥rias simples que s√£o capazes de prender um pequeno grupo de NPC's na sua narrativa, podendo ser utilizado como forma de obter informa√ß√µes ou distra√ß√£o. <br><br><b>N√≠vel 2:</b> Gasta uma a√ß√£o e 7 de mana para que, a todos que ou√ßam uma hist√≥ria calma e pac√≠fica, percam 1 ponto de medo, encantado e frenesi. <br><br><b>N√≠vel 3:</b> A capacidade de contar hist√≥rias do seu personagem √© tamanha que ele √© capaz de prender completamente a aten√ß√£o de um alvo. O alvo ficar√° t√£o entretido dentro da narrativa que ficar√° sob o efeito de encantado. Sendo ent√£o capaz de se obter um grande favor deste. O n√∫mero de pontos de encantado aplicado ser√° igual a duas vezes o n√∫mero de horas contando a hist√≥ria e gastar√° 5 de mana por hora de hist√≥ria.",
            },
            {
              name: "Discursar",
              info: "Dita a capacidade do personagem em fazer discursos, podendo enganar, incentivar, repreender ou alegrar plateias. O discurso pode ser feito duas vezes por sess√£o independente de n√≠vel. <br><br><b>N√≠vel 1:</b> O jogador consegue fazer um pequeno discurso que cativar√° at√© 3 pessoas a sua escolha. O discurso da 1 ponto de moral. Realizar o discurso consome uma a√ß√£o e 5 de mana. <br><br><b>N√≠vel 2:</b> A orat√≥ria do jogador √© melhorada, garantindo que possa discursar para at√© 6 pessoas. <br><br><b>N√≠vel 3:</b> Ao terceiro n√≠vel, o jogador pode fazer seu discurso inflamador, podendo aplicar o efeito de frenesi.",
            },
            {
              name: "Embroma√ß√£o",
              info: "Mede a capacidade do personagem em desviar a aten√ß√£o de um NPC ou outro jogador, usando de direcionamento e prolixidade. <br><br><b>N√≠vel 1:</b>O personagem pode tentar distrair a um NPC ou jogador, sendo necess√°rio a realiza√ß√£o de um teste para que, durante 1 minuto mantenha o alvo da embroma√ß√£o sob o efeito de 1 de Paralisado. Caso seja um combate, ser√° gasto 12 de mana e feito um teste de social todo turno para conceder este ponto. <br><br><b>N√≠vel 2:</b> O personagem pode tentar distrair a um NPC ou jogador, sendo necess√°rio a realiza√ß√£o de um teste para que, durante 2 minutos mantenha o alvo da embroma√ß√£o sob o efeito de 1 de Paralisado. Caso seja um combate, ser√° gasto 10 de mana e feito um teste de social todo turno para conceder este ponto. <br><br><b>N√≠vel 3:</b> O personagem pode tentar distrair a um NPC ou jogador, sendo necess√°rio a realiza√ß√£o de um teste para que, durante 4 minutos mantenha o alvo da embroma√ß√£o sob o efeito de 1 de Paralisado. Caso seja um combate, ser√° gasto 8 de mana e feito um teste de social todo turno para conceder este ponto.",
            },
            {
              name: "Intimida√ß√£o",
              info: "Utilizada para que um jogador tente dissuadir um NPC ou outro jogador, pode tamb√©m ser usada em combates para gerar efeitos de medo ao alvo. <br><br><b>N√≠vel 1:</b> Recebe um flat b√¥nus de +3 para rolagens no dado. <br><br><b>N√≠vel 2:</b> Aumento do flat b√¥nus para +5. O jogador pode queimar uma a√ß√£o e 4 de mana para intimidar o seu advers√°rio. Aplicando 1 ponto de medo. <br><br><b>N√≠vel 3:</b> O jogador pode gastar sua a√ß√£o e 8 de mana para intimidar uma √°rea ao seu redor cujo raio √© de 5 metros. Todos os alvos dentro desta √°rea receber√£o 1 ponto de medo.",
            },
            {
              name: "Mentira",
              info: "Implica na capacidade do personagem em elaborar mentiras ou ent√£o hist√≥rias ou argumentos falaciosos que sejam concisos. <br><br><b>N√≠vel 1:</b> Recebe um flat b√¥nus de +3 para rolagens no dado. <br><br><b>N√≠vel 2:</b> Aumento do flat b√¥nus para +5 para rolagens. <br><br><b>N√≠vel 3:</b> Aumento do flat b√¥nus para +7 para rolagens.",
            },
            {
              name: "Negocia√ß√£o",
              info: "Per√≠cia para medir o qu√£o bem seu personagem √© capaz de negociar por novos pre√ßos e/ou trocas entre personagens. <br><br><b>N√≠vel 1:</b> Recebe um flat b√¥nus de +3 para rolagens no dado.<br><br><b>N√≠vel 2:</b> Aumento do flat b√¥nus para +5 para rolagens. O jogador √© garantido de ter um desconto de 10% no valor do item de compra independente de rolagem. <br><br><b>N√≠vel 3:</b> Acesso aos mercados negros, locais onde itens mais raros e mais poderosos podem ser encontrados, t√£o bem como qualquer outro objeto de contrabando ou ent√£o ilegal.",
            },
            {
              name: "Persuas√£o",
              info: "Dita o qu√£o bem o jogador consegue alterar o posicionamento de outro personagem, ou NPC, para que ele consiga influencia-lo. <br><br><b>N√≠vel 1:</b> Recebe um flat b√¥nus de +3 para rolagens no dado. <br><br><b>N√≠vel 2:</b> Aumento do flat b√¥nus para +5 para rolagens. <br><br><b>N√≠vel 3:</b> Aumento do flat b√¥nus para +7 para rolagens.",
            },
            {
              name: "Sedu√ß√£o",
              info: "Mede a capacidade do personagem flertar com algum NPC. <br><br><b>N√≠vel 1:</b> Flat b√¥nus de +3 para rolagens desta per√≠cia. <br><br><b>N√≠vel 2:</b> Aumenta o flat b√¥nus para +5 em rolagens desta per√≠cia. A personagem pode usar uma a√ß√£o e 5 de mana para aplicar 1 ponto de encantado. <br><br><b>N√≠vel 3:</b> A personagem pode usar uma a√ß√£o e 7 de mana para aplicar 1 ponto de hipnotizado.",
            },
          ],
          prestigios: [
            {
              name: "Folclore",
              info: "Requisito: Cultura ou Social. O personagem tem conhecimento profundo sobre tradi√ß√µes e lendas populares.",
            },
            {
              name: "Pol√≠tica",
              info: "Requisito: Cultura ou Social. O personagem entende os complexos sistemas pol√≠ticos e √© h√°bil em negocia√ß√µes diplom√°ticas.",
            },
          ],
        },
        {
          label: "Cultura",
          sectionId: "cultura",
          onClick: "handleSectionClick('cultura')",
          attribute: { label: "CUL", dataAttribute: "cul" },
          skills: [
            {
              name: "Belas Artes",
              info: "Utilizada para quando h√° a tentativa de expressar por meio da arte, com pinturas, m√∫sicas, literatura, etc. <br><br><b>N√≠vel 1:</b> O jogador pode gastar 7 pontos de mana para aplicar dois pontos de confus√£o ou um ponto de encantado a um alvo. Ap√≥s o termino do efeito, o mesmo alvo n√£o pode sofrer efeitos dessa habilidade por 5 minutos.<br><br><b>N√≠vel 2:</b> A personagem pode gastar uma a√ß√£o para, dentro de um raio de 10m, revelar uma grande obra. Podendo assim, aumentar ou diminuir 1 ponto de moral de todos aqueles dentro da √°rea at√© o seu pr√≥ximo turno. Caso o jogador escolha diminuir um ponto todos os aliados e inimigos estar√£o sob esse mesmo efeito. <br><br><b>N√≠vel 3:</b> Fazendo uma grande demonstra√ß√£o art√≠stica o jogador pode enaltecer os feitos e conquistas de outro personagem. Concedendo-lhe 1 ponto de Honrado, sendo preciso no m√≠nimo 1 hora de tempo e 20 pontos de mana (a crit√©rio do mestre pode ser cobrado algum recurso a ser aplicado na forma de ouro, como tintas que custem 20 de gold).",
            },
            {
              name: "Art√≠fice",
              info: "Permite ao jogador identificar artefatos, aprender sua origem, obter b√¥nus a partir deles e, finalmente, ascender um item ao estado de Artefato. <br><br><b>N√≠vel 1:</b>O jogador pode gastar 1 dia analisando um artefato desconhecido para determinar qual √© o seu efeito de artefato. <br><br><b>N√≠vel 2:</b>Toda vez que o jogador identificar um artefato ele poder√° escolher um dentre os seguintes b√¥nus: <br>    +4 de HP permanente;<br>    +2 de MP permanente;<br>    +1 em rolagem de Cultura;<br>    +30 de Fervor; <br>    +500 de Gold.<br><br><b>N√≠vel 3:</b>O jogador pode, uma vez em sua vida, ascender um item n√≠vel 3, com pr√≠stino 3,uma propriedade e 1 encantamento para um artefato. Para isso, este precisa gastar:<br>14 dias;<br>1000 de Gold;<br>Toda a sua mana;<br>Ecolhendo um efeito de artefato e atrelando-o ao item. O item deve ent√£o ser nomeado. Al√©m disso, o jogador recebe:<br>2 pontos de exaust√£o;<br>2 pontos de insanidade. ",
            },

            {
              name: "Hist√≥ria",
              info: "Implica nos conhecimentos hist√≥ricos do personagem a cerca de algum local, ambiente ou cultura. <br><br><b>N√≠vel 1:</b> Para qualquer teste de hist√≥ria que vise obter informa√ß√£o sobre um povo, ambiente, local, pessoas h√° um b√¥nus de +3 na rolagem. <br><br><b>N√≠vel 2:</b> H√° o aumento do b√¥nus de rolagem para +5. A personagem melhora seu entendimento de ru√≠nas, aumentando o b√¥nus de ``An√°lise de Ru√≠nas'' da per√≠cia Folclore n√≠vel 3 de +5 para +7 pontos de folclore. <br><br><b>N√≠vel 3:</b> O jogador pode gastar 1 dia estudando um artefato ou objeto m√°gico para entender a origem dele, tal como que povo a fez, de onde ela vem, caracter√≠sticas dela, etc. Caso o jogador possua Folclore n√≠vel 1, ele tamb√©m recebe 4 pontos de folclore.",
            },
            {
              name: "Morfologia",
              info: "Seu personagem √© capaz de entender l√≠nguas e fundamentos lingu√≠sticos, isso permite com que ele possa interpretar mensagens, escrita, etc. <br><br><b>N√≠vel 1:</b> Seu personagem tem total profici√™ncia na em um segundo idioma a escolha dele. <br><br><b>N√≠vel 2:</b> Com mais conhecimento morfol√≥gico, o personagem conhece mais de l√≠nguas esquecidas ou perdidas, permitindo entender algumas palavras em cavernas, ru√≠nas antigas, etc. O jogador tamb√©m pode conhecer mais um idioma. <br><br><b>N√≠vel 3:</b> O conhecimento em lingu√≠stica do personagem √© imenso, ele se torna capaz de compreender e identificar qualquer idioma desconhecido a crit√©rio do mestre.",
            },
            {
              name: "Performance",
              info: "Mede a habilidade do personagem em efetuar uma performance para poder fazer um show ou encantar uma plateia. <br><br><b>N√≠vel 1:</b> Recebe um flat b√¥nus de +3 para rolagens de performance. O personagem pode fazer uma performance para um pequeno p√∫blico, deixando a maior parte dos ouvintes apenas desatentos por alguns minutos.<br><br><b>N√≠vel 2:</b> Aumento do flat b√¥nus de +5 em rolagens de performance. O conhecimento de palco do personagem aumenta, ele pode utilizar 10 pontos de mana para realizar uma grande performance de sua escolha que resultar√° no ganho de algumas moedas de ouro (a quantia de ouro adv√©m de um teste de performance). Recebe 1 ponto de exaust√£o ao realizar a performance. <br><br><b>N√≠vel 3:</b> Ao terceiro n√≠vel, o personagem al√©m de receber mais ouro (a quantia de ouro adv√©m de um teste de performance) no seu grande show, ele tamb√©m pode receber itens da plateia (a crit√©rio do mestre) como forma de pagamento.",
            },
            {
              name: "Religi√£o",
              info: "Mede o conhecimento do personagem sobre teologia e conhecimentos religiosos no geral. <br><br><b>N√≠vel 1:</b> Recebe um flat b√¥nus de +3 para conhecimento a cerca de religi√£o. <br><br><b>N√≠vel 2:</b> Aumento do flat b√¥nus para +5. <br><br><b>N√≠vel 3:</b> Desbloqueia t√©cnicas avan√ßadas de exerc√≠cio da f√© (Verificar per√≠cia de F√©).",
            },
          ],
          prestigios: [
            {
              name: "Folclore",
              info: "Requisito: Cultura ou Social. O personagem tem conhecimento profundo sobre tradi√ß√µes e lendas populares.",
            },
            {
              name: "F√©",
              info: "Requisito: Cultura ou Magia. O personagem possui uma f√© profunda que lhe concede poderes divinos.",
            },
          ],
        },
        {
          label: "Atletismo",
          sectionId: "atletismo",
          onClick: "handleSectionClick('atletismo')",
          attribute: { label: "ALT", dataAttribute: "alt" },
          skills: [
            {
              name: "Acrobacia",
              info: "Per√≠cia para descrever as capacidades acrob√°ticas de um personagem para se deslocar no espa√ßo. <br><br><b>N√≠vel 1:</b> Flat b√¥nus de +3 para rolagens desta per√≠cia. <br><br><b>N√≠vel 2:</b> Aumenta o flat b√¥nus para +5 em rolagens desta per√≠cia. A personagem ganha a capacidade de escalar superf√≠cies verticais (a crit√©rio do mestre). <br><br><b>N√≠vel 3:</b> Imunidade a dano de queda.",
            },
            {
              name: "Atl√©tica",
              info: "Mede o condicionamento f√≠sico do personagem, indicando o qu√£o bom ele sabe correr, nadar, etc. <br><br><b>N√≠vel 1:</b> Aumento da velocidade de movimento em +2 m. <br><br><b>N√≠vel 2:</b> Aumento da velocidade de movimento em +3 m. Totalizando (com o primeiro n√≠vel) 5 m de movimenta√ß√£o extra. <br><br><b>N√≠vel 3:</b> Aumento da velocidade de movimento em +4 m. Totalizando (com o segundo n√≠vel) 9 m de movimenta√ß√£o extra.",
            },
            {
              name: "Carga",
              info: "Adiciona mais slots para que o jogador possa carregar seus itens de f√°cil acesso. <br><br><b>N√≠vel 1:</b> O personagem ganha +1 slot. <br><br><b>N√≠vel 2:</b> O personagem ganha +2 slots, totalizando 3 slots extras. <br><br><b>N√≠vel 3:</b> O personagem ganha +3 slots, totalizando 6 slots extras.",
            },
            {
              name: "Constitui√ß√£o",
              info: "Apresenta a resist√™ncia f√≠sica do jogador a certos efeitos. <br><br><b>N√≠vel 1:</b> Caso a personagem fique inconsciente receba 1 ponto de inconsciente extra. A primeira vez que o jogador receber dano o suficiente para que sua vida chegue √† 0 ou abaixo, sua vida ser√° definida para 1 (esse efeito s√≥ pode ocorrer a cada 3 dias). <br><br><b>N√≠vel 2:</b> O jogador pode gastar uma a√ß√£o de refor√ßo e 5 pontos de mana para remover 1d4 de pontos de alguma das seguintes condi√ß√µes: envenenado, congelado, decompondo, fraco, imobilizado, incendiado, lento, paralisado, sangramento. <br><br><b>N√≠vel 3:</b> O jogador poder√° escolher um efeito de dano para que possua resist√™ncia a ele, al√©m de que o primeiro ponto de exaust√£o n√£o possui efeito.",
            },
            {
              name: "Equil√≠brio",
              info: "Define o qu√£o bom o seu personagem √© para movimentar seu corpo mantendo o equil√≠brio, implicando na sua capacidade de se manter de p√© mesmo frente adversidades. <br><br><b>N√≠vel 1:</b> Flat b√¥nus de +3 para rolagens desta per√≠cia. <br><br><b>N√≠vel 2:</b> Aumenta o flat b√¥nus para +5 em rolagens desta per√≠cia. Se o jogador n√£o usar a sua a√ß√£o de movimento, sua AD aumenta em +1 at√© o pr√≥ximo turno. <br><br><b>N√≠vel 3:</b> N√£o recebe ponto da condi√ß√£o Ca√≠do.",
            },
            {
              name: "Evas√£o",
              info: "Explicita a habilidade do personagem usar sua a√ß√£o de rea√ß√£o para desviar de proj√©teis e √°reas de efeito. <br><br><b>N√≠vel 1:</b> Permite com que a personagem, ao receber dano por um ataque √† dist√¢ncia de alvo √∫nico, use sua rea√ß√£o e 10 de MP para reduzir o dano pela metade.<br><br><b>N√≠vel 2:</b> Mesma descri√ß√£o do primeiro n√≠vel, no entanto, o dano √© levado √† zero. <br><br><b>N√≠vel 3:</b> A personagem, caso receba dano por uma √°rea de efeito, use sua rea√ß√£o e 10 de MP para reduzir o dano pela metade.",
            },
            {
              name: "For√ßa",
              info: "Per√≠cia utilizada para desbloquear armas do tipo PS, PDM e  auxilia no desbloqueio de ArcP. Os b√¥nus aqui presente s√£o v√°lidos apenas para esses tipo de arma. <br><br><b>N√≠vel 1:</b> O jogador pode usar 4 de mana e sua rea√ß√£o para, ap√≥s realizar um ataque bem sucedido, aplicar 1 ponto de ca√≠do no alvo. <br><br><b>N√≠vel 2:</b> O jogador recebe +4 de dano f√≠sico com armas pesadas. <br><br><b>N√≠vel 3:</b> Utilizando sua a√ß√£o de prepara√ß√£o e 10 de mana o jogador poder√° realizar um ataque contundente, caso o ataque seja bem sucedido, o alvo sofrer√° 1 ponto de Atordoado.",
            },
            {
              name: "Reflexos",
              info: "Per√≠cia relativa aos reflexos do seu personagem, aprimorando suas capacidades de esquiva com ou sem armaduras. <br><br><b>N√≠vel 1:</b>Ganho de +2 de AD para caso o jogador esteja ou sem armadura ou com uma armadura leve. <br><br><b>N√≠vel 2:</b> O b√¥nus de AD torna-se +3 e o efeito se aplica tamb√©m para armaduras m√©dias. <br><br><b>N√≠vel 3:</b> O jogador pode utilizar 4 de mana para que em uma rea√ß√£o possa reduzir o dano de um ataque corpo a corpo em 2d8.",
            },
          ],
          prestigios: [
            {
              name: "Furioso",
              info: "Requisito: Atletismo. O personagem pode entrar em f√∫ria de batalha, aumentando significativamente suas habilidades f√≠sicas.",
            },
            {
              name: "Marcial",
              info: "Requisito: Combate. O personagem √© um mestre em artes marciais e t√©cnicas de combate avan√ßadas.",
            },
          ],
        },
        {
          label: "Manufatura",
          sectionId: "manufatura",
          onClick: "handleSectionClick('manufatura')",
          attribute: { label: "MAN", dataAttribute: "man" },
          skills: [
            {
              name: "Alfaiate",
              info: "Permite com que o jogador possa fazer armaduras leves, roupas e tecidos, mediante uma rolagem de manufatura com dificuldade definida pelo mestre, se houver uma falha os recursos s√£o destru√≠dos. Materiais, custo e tempo de produ√ß√£o ficam a crit√©rio do mestre. <br><br><b>N√≠vel 1:</b>Permite com que o personagem fa√ßa armaduras leves at√© n√≠vel 1 e com Pr√≠stino n√≠vel 1. <br><br><b>N√≠vel 2:</b> Ao segundo n√≠vel, armaduras leves at√© o n√≠vel 2 podem ser feitas e com Pr√≠stino n√≠vel 2. <br><br><b>N√≠vel 3:</b> No terceiro n√≠vel, armaduras leves podem ser feitas at√© o n√≠vel 3 e com Pr√≠stino n√≠vel 3 e, toda armadura leve feita pelo personagem, pode receber uma propriedade a escolha, caso possua os materiais necess√°rios.",
            },
            {
              name: "Armeiro",
              info: "Permite com que o jogador fa√ßa armas (corpo a corpo) de qualquer classe. Materiais, custo e tempo de produ√ß√£o ficam a crit√©rio do mestre. <br><br><b>N√≠vel 1:</b> Permite com que o personagem fa√ßa qualquer classe de arma em n√≠vel 1 (corpo a corpo) e com Pr√≠stino n√≠vel 1. <br><br><b>N√≠vel 2:</b> Permite com que o personagem fa√ßa qualquer classe de arma em n√≠vel 2 (corpo a corpo) e com Pr√≠stino n√≠vel 2. <br><br><b>N√≠vel 3:</b> Permite com que o personagem fa√ßa qualquer classe de arma em n√≠vel 3 (corpo a corpo) e com Pr√≠stino n√≠vel 3. E toda armadura moderada feita pelo personagem, pode receber uma propriedade a escolha, caso tenha os materiais necess√°rios.",
            },
            {
              name: "Armoreiro",
              info: "Permite com que o jogador fa√ßa  armaduras pesadas. Materiais, custo e tempo de produ√ß√£o ficam a crit√©rio do mestre. <br><br><b>N√≠vel 1:</b> Permite com que o personagem fa√ßa armaduras pesadas at√© n√≠vel 1 e com Pr√≠stino n√≠vel 1.<br><br><b>N√≠vel 2:</b> Permite com que o personagem fa√ßa armaduras pesadas at√© n√≠vel 2 e com Pr√≠stino n√≠vel 2. O jogador pode fazer qualquer tipo de escudo. <br><br><b>N√≠vel 3:</b> Permite com que o personagem fa√ßa armaduras pesadas at√© n√≠vel 3 e com Pr√≠stino n√≠vel 3 e, toda armadura moderada feita pelo personagem, pode receber uma propriedade a escolha, caso tenha os materiais necess√°rios.",
            },
            {
              name: "Carpintaria",
              info: "Permite com que o jogador possa fazer arcos, bestas e bord√µes. Materiais, custo e tempo de produ√ß√£o ficam a crit√©rio do mestre. <br><br><b>N√≠vel 1:</b> Permite com que o personagem fa√ßa qualquer arco, arco pesado, bestas ou bord√µes em n√≠vel 1 e com Pr√≠stino n√≠vel 1. O jogador pode fazer qualquer tipo de escudo.  <br><br><b>N√≠vel 2:</b> Permite com que o personagem fa√ßa qualquer arco, arco pesado, bestas ou bord√µes em n√≠vel 2 e com Pr√≠stino n√≠vel 2. <br><br><b>N√≠vel 3:</b> Permite com que o personagem fa√ßa qualquer arco, arco pesado, bestas ou bord√µes em n√≠vel 3 e com Pr√≠stino n√≠vel 3 e, elas podem receber uma propriedade a escolha, caso possua os materiais necess√°rios.",
            },
            {
              name: "Disfarce",
              info: "Mede a capacidade do personagem em alterar a apar√™ncia e enganar aos NPCs pr√≥ximos. Mediante uma rolagem de manufatura com dificuldade definida pelo mestre, se houver uma falha os recursos s√£o destru√≠dos. Materiais, custo e tempo de produ√ß√£o ficam a crit√©rio do mestre. <br><br><b>N√≠vel 1:</b> Utilizando de algumas tintas e plantas, o personagem pode fazer uma camuflagem b√°sica. Recebe um b√¥nus de +1d6 de furtividade para a pessoa camuflada. S√£o necess√°rios 5 de mana para isso.<br><br><b>N√≠vel 2:</b> A personagem pode melhorar a apar√™ncia natural de um jogador, dando um b√¥nus de +1d6 em rolagens de performance ou sedu√ß√£o. O custo de mana ser√° de 7. <br><br><b>N√≠vel 3:</b> O jogador consegue fazer uma maquiagem capaz de modificar a apar√™ncia geral da pessoa de maneira que esta receba +1d6 em rolagens de mentira para se passar por outra pessoa. S√£o necess√°rios 2 de mana para isso.",
            },
            {
              name: "Coureiro",
              info: "Permite com que o jogador fa√ßa  armaduras moderadas. Materiais, custo e tempo de produ√ß√£o ficam a crit√©rio do mestre. <br><br><b>N√≠vel 1:</b> Permite com que o personagem fa√ßa armaduras moderadas at√© n√≠vel 1 e com Pr√≠stino n√≠vel 1. <br><br><b>N√≠vel 2:</b> Permite com que o personagem fa√ßa armaduras moderadas at√© n√≠vel 2 e com Pr√≠stino n√≠vel 2. <br><br><b>N√≠vel 3:</b> Permite com que o personagem fa√ßa armaduras moderadas at√© n√≠vel 3 e com Pr√≠stino n√≠vel 3 e, toda armadura moderada feita pelo personagem, pode receber uma propriedade a escolha, caso tenha os materiais necess√°rios.",
            },
            {
              name: "Encantamento",
              info: "Permite com que um item possa ser encantado pelo jogador, mediante uma rolagem de manufatura com dificuldade definida pelo mestre, se houver uma falha o item √© destru√≠do. Materiais, custo e tempo de produ√ß√£o ficam a crit√©rio do mestre. <br><br><b>N√≠vel 1:</b> No primeiro n√≠vel, o jogador pode aplicar uma magia de uma ess√™ncia no item de escolha. <br><br><b>N√≠vel 2:</b> As magias podem ter at√© tr√™s ess√™ncias no encantamento. <br><br><b>N√≠vel 3:</b> O encantista pode agora encantar um item at√© 2 vezes.",
            },
            {
              name: "Escriba",
              info: "Permite com que o jogador fabrique e sele uma magia em um pergaminho de um uso. Mediante uma rolagem de manufatura com dificuldade definida pelo mestre, se houver uma falha o item √© destru√≠do. Materiais, custo e tempo de produ√ß√£o ficam a crit√©rio do mestre. Um pergaminho demanda muito mais tempo para sua fabrica√ß√£o. <br><br><b>N√≠vel 1:</b> Permite o selamento de uma magia com 1 ess√™ncia. <br><br><b>N√≠vel 2:</b> Permite o selamento de uma magia com at√© 2 ess√™ncias. <br><br><b>N√≠vel 3:</b> Permite o selamento de uma magia com at√© 3 ess√™ncias. O tempo de fabrica√ß√£o de um pergaminho √© reduzido.",
            },
            {
              name: "Falsifica√ß√£o",
              info: "Permite com que o jogador fabrique documentos e/ou assinaturas falsificados. Mediante uma rolagem de manufatura com dificuldade definida pelo mestre, se houver uma falha o item √© destru√≠do. Materiais, custo e tempo de produ√ß√£o ficam a crit√©rio do mestre. <br><br><b>N√≠vel 1:</b> Ao primeiro n√≠vel, o personagem pode efetuar uma rolagem para elaborar documentos simples que, ao serem apresentados a um personagem ou NPC. <br><br><b>N√≠vel 2:</b> Ao segundo n√≠vel, o personagem pode elaborar assinaturas falsas e documentos mais robustos para apresentar. A personagem pode criar um documento falso de uso √∫nico que lhe garante +50 de Favor. <br><br><b>N√≠vel 3:</b> No √∫ltimo n√≠vel, documentos utilizados em aristocracia, identidades, assinaturas e carimbos podem ser feitos pelo personagem de forma bem profissional. A personagem pode criar um notas promiss√≥rias falsas de uso √∫nico que lhe garantem 2d100 de gold.",
            },
            {
              name: "Ourives",
              info: "Permite com que o jogador possa fazer joias de diferentes n√≠veis. Estas, s√£o objetos que possuem encantamentos ou propriedades que podem ser usadas pela personagem. A confec√ß√£o de uma joia exige materiais de alto padr√£o e alto grau de raridade, sendo, deixado a crit√©rio do mestre, o pre√ßo e m√©todo de obten√ß√£o. Recomendamos algo em torno de 10 vezes o pre√ßo de uma boa arma. Toda joia ocupa 1 slot. <br><br><b>N√≠vel 1:</b> Permite o jogador fazer uma joia n√≠vel 1. Ela pode ter 1 encantamento (ver regras de Encantamento); <br><br><b>N√≠vel 2:</b> O jogador pode fazer uma joia n√≠vel 2. Essa pode ter 1 propriedade (ver regras de Propriedade de Joias); <br><br><b>N√≠vel 3:</b> No terceiro n√≠vel, o jogador pode criar joias n√≠vel 3. Essas podem ter uma encantamento e uma propriedade, simultaneamente.",
            },
          ],
          prestigios: [
            {
              name: "Art√≠ficer",
              info: "Requisito: Manufatura. O personagem √© um mestre artes√£o capaz de criar itens m√°gicos e artefatos complexos.",
            },
            {
              name: "Alquimia",
              info: "Requisito: Conhecimento ou Magia. O personagem √© versado na arte da alquimia e cria√ß√£o de po√ß√µes.",
            },
          ],
        },
        {
          label: "Combate",
          sectionId: "combate",
          onClick: "handleSectionClick('combate')",
          attribute: { label: "COM", dataAttribute: "com" },
          skills: [
            {
              name: "Acur√°cia",
              info: "Per√≠cia respons√°vel para desbloquear a capacidade de armas √† dist√¢ncia. <br><br><b>N√≠vel 1:</b>Permite o arremesso de armas leves de arremesso (ALA) com dist√¢ncia de at√© 15 metros. <br><br><b>N√≠vel 2:</b>Bestas podem ser recarregadas com a a√ß√£o de preparo, arcos pesados podem come√ßar a acertar alvos a partir de 15 metros.  <br><br><b>N√≠vel 3:</b>Permite com que o personagem possa atingir advers√°rios at√© duas vezes a dist√¢ncia m√°xima de armas do tipo Arc ao custo de 5 de mana.",
            },
            {
              name: "Ambidestria",
              info: "Dita a capacidade do personagem no dom√≠nio do uso das duas m√£os, permitindo com que ele possa utilizar duas armas, uma em cada uma de suas m√£os. Tamb√©m auxilia no desbloqueio das armas de tipo Arc e ArcP. <br><br><b>N√≠vel 1:</b>Permite o uso de duas armas leves distintas simultaneamente pelo personagem. Para o combate, √© poss√≠vel utilizar a a√ß√£o de refor√ßo para desferir um golpe com a arma que esteja na segunda m√£o (sendo necess√°rio um segundo teste de combate). Esse b√¥nus n√£o √© v√°lido para armas Arc. <br><br><b>N√≠vel 2:</b>O personagem pode utilizar armas longas ou cortante/perfurante simples na m√£o dominante. Esse b√¥nus n√£o √© v√°lido para armas Arc.  <br><br><b>N√≠vel 3:</b>O personagem pode usar sua rea√ß√£o e 1 ponto de mana para rolar o dado de dano de sua arma secund√°ria, reduzindo o dano de um ataque corpo a corpo, n√£o m√°gico, neste valor. Esse b√¥nus n√£o √© v√°lido para armas Arc. ",
            },
            {
              name: "Combate Improvisado",
              info: "Habilidade referente √† capacidade de criar armas improvisadas ou ent√£o entrar em combate desarmado. <br><br><b>N√≠vel 1:</b>O jogador usar√° 1d4 de dano para ataques desarmados. Al√©m disso, o jogador pode utilizar objetos ao seu redor, como galhos, garrafas, pedras como armas improvisadas, essas armas d√£o 1d6 de dano e tem 1 uso <br><br><b>N√≠vel 2:</b>O dano do jogador, para ataques desarmados, √© aumentado para 2d4. O jogador ganha uma maior profici√™ncia com armas improvisadas, fazendo com que essas causem 1d10 de dano e tenham 6 usos.  <br><br><b>N√≠vel 3:</b>O dano para ataques desarmados torna-se 3d4. O jogador, ao realizar um ataque com arma improvisada, pode usar sua a√ß√£o de refor√ßo para realizar um novo ataque. ",
            },
            {
              name: "Esgrima",
              info: "Per√≠cia que dita a capacidade de usar armas corpo a corpo leves do tipo CPS e CPP. Os b√¥nus aqui presente s√£o v√°lidos apenas para esses tipo de arma. <br><br><b>N√≠vel 1:</b>.Ataques com armas CPS e CPP aplicam, passivamente, 1 ponto de sangramento se houver sucesso (s√≥ pode ocorrer 1 vez por turno). <br><br><b>N√≠vel 2:</b>Remove a restri√ß√£o de turno do n√≠vel anterior.  <br><br><b>N√≠vel 3:</b>O personagem pode realizar um ataque lesionante ao custo de 10 pontos de mana. Caso o ataque seja bem sucedido, o jogador dever√° rolar 1d100 e averiguar a les√£o. ",
            },
            {
              name: "Longa Vista",
              info: "Utilizada para desbloquear armas dos tipos AL e LP. Os b√¥nus aqui presente s√£o v√°lidos apenas para esses tipo de arma. <br><br><b>N√≠vel 1:</b>Recebe +1.5 metro de √°rea de amea√ßa. <br><br><b>N√≠vel 2:</b>O jogador pode utilizar da sua a√ß√£o de refor√ßo para realizar um ataque de pomo em outro alvo que causa 1d6 de dano.  <br><br><b>N√≠vel 3:</b>Ataques com armas AL e LP queimam a rea√ß√£o do alvo. ",
            },
            {
              name: "Oportunista",
              info: "Per√≠cia que √© usada para garantir ataques de oportunidade ao jogador uma vez que um monstro/advers√°rio fuja/entre do seu raio de ataque. <br><br><b>N√≠vel 1:</b>Desbloqueia a rea√ß√£o do ataque de oportunidade para ataques corpo a corpo. <br><br><b>N√≠vel 2:</b>Desbloqueia a rea√ß√£o do ataque de oportunidade para armas ranged, este n√£o pode acontecer caso voc√™ esteja no raio de amea√ßa de uma criatura inimiga.  <br><br><b>N√≠vel 3:</b>Desbloqueia a rea√ß√£o do ataque de oportunidade para magias individuais e touch, essa rea√ß√£o n√£o pode ser usada caso voc√™ esteja no raio de amea√ßa de uma criatura inimiga.",
            },
            {
              name: "Bimanual",
              info: "Implica na capacidade do jogador de desbloquear armas do tipo CDM, PDM, CPP, LP e auxilia no desbloqueio da Best. Os b√¥nus aqui presente s√£o v√°lidos apenas para esses tipo de arma. <br><br><b>N√≠vel 1:</b>O raio de amea√ßa do jogador aumenta em 1.5 metro, exceto para Best e CDM. <br><br><b>N√≠vel 2:</b>Reduz o slot das armas citadas em 1.  <br><br><b>N√≠vel 3:</b>Permite gastar a a√ß√£o de movimento e 4 de mana para aumentar o dano da arma em 1 dado de dano do n√≠vel 1 da sua arma at√© o seu pr√≥ximo turno. ",
            },
          ],
          prestigios: [
            {
              name: "Marcial",
              info: "Requisito: Combate. O personagem √© um mestre em artes marciais e t√©cnicas de combate avan√ßadas.",
            },
            {
              name: "Furioso",
              info: "Requisito: Atletismo. O personagem pode entrar em f√∫ria de batalha, aumentando significativamente suas habilidades f√≠sicas.",
            },
          ],
        },
        {
          label: "Sobreviv√™ncia",
          sectionId: "sobrevivencia",
          onClick: "handleSectionClick('sobrevivencia')",
          attribute: { label: "SOB", dataAttribute: "sob" },
          skills: [
            {
              name: "Acampamento",
              info: "Mede o conhecimento do personagem em montar estruturas para um acampamento. <br><br><b>N√≠vel 1:</b> O personagem √© capaz de montar pequenas armadilhas para captura de animais pequenos, gastando 40 minutos para tal. Garante 1 ra√ß√£o. <br><br><b>N√≠vel 2:</b> A personagem pode montar um acampamento de alto n√≠vel, gastando 2 horas para poder escolher uma condi√ß√£o e remover 1 ponto dela. As condi√ß√µes incluem: Exaust√£o, Insanidade ou Envenenado. <br><br><b>N√≠vel 3:</b> Um acampamento de alto padr√£o pode ser realizado, mantendo o efeito do n√≠vel 2 e adicionando o ganho de 1 ponto de Honrado pelo remanescente do dia, ao custo de 2 horas de preparo e 1000 de gold em materiais.",
            },
            {
              name: "Adestramento",
              info: "Dita a capacidade do personagem de discernir as inten√ß√µes ou maneirismos de um animal. <br><br><b>N√≠vel 1:</b> Flat b√¥nus de +3 para entender o comportamento ou se comunicar com animais. Animais dom√©sticos gostam muito do seu personagem. <br><br><b>N√≠vel 2:</b> Aumenta o flat b√¥nus para +5 em rolagens desta per√≠cia. A personagem pode chamar sua montaria em um raio de 3 km. <br><br><b>N√≠vel 3:</b> Criaturas convencionais n√£o s√£o agressivas contra o jogador (averiguar com o mestre quais se enquadram nesse crit√©rio).",
            },
            {
              name: "Arrombamento",
              info: "Mede a capacidade do personagem em destravar trancas, cadeados ou mecanismos. A aus√™ncia de qualquer ponto nessa per√≠cia garante que, qualquer ganzua usada, e o teste seja uma falha, ser√° consumido. <br><br><b>N√≠vel 1:</b> Para qualquer rolagem de natureza de ganzua recebe um b√¥nus de +3 na rolagem. <br><br><b>N√≠vel 2:</b> O b√¥nus √© aumentado para +5 e √© poss√≠vel tentar abrir ba√∫s com fechaduras m√°gicas (a crit√©rio do mestre). <br><br><b>N√≠vel 3:</b> O jogador pode abrir qualquer ba√∫ de fechadura n√£o m√°gica sem realizar um teste. Fora isso, o jogador tamb√©m n√£o ativa mecanismos de alarme ou armadilhas (isso inclu√≠ ba√∫s m√≠micos, que s√£o considerados m√°gicos).",
            },
            {
              name: "Bater Carteira",
              info: "Per√≠cia utilizada para que um personagem possa roubar um NPC ou outro personagem de maneira furtiva. <br><br><b>N√≠vel 1:</b> Para qualquer rolagem de natureza de bater carteira recebe um b√¥nus de +3 na rolagem. <br><br><b>N√≠vel 2:</b> Aumento do b√¥nus de rolagem para +5. Fora isso voc√™ tamb√©m pode andar pelas ruas e, sem realizar rolagens, roubar ouro das pessoas que ficam andando (a quantia de ouro √© definida pelo mestre). <br><br><b>N√≠vel 3:</b> Libera a possibilidade de fazer testes de bater carteira para implantar objetos nos outros ao inv√©s de rouba-los.",
            },
            {
              name: "Cozinhar",
              info: "Dita a capacidade gastron√¥mica do personagem. <br><br><b>N√≠vel 1:</b> O personagem ser√° capaz de, sem um kit de cozinha, produzir ra√ß√µes que possuem 2 usos. Para tal, ser√° necess√°rio algum tipo de mat√©ria prima, tal como carne, farinha, etc. As ra√ß√µes duplicadas n√£o podem ser duplicadas novamente. <br><br><b>N√≠vel 2:</b>A personagem pode converter uma ra√ß√£o para que ela seja ou uma ra√ß√£o de vida ou uma ra√ß√£o de mana, permitindo que ela recupere pontos de vida ou mana. Gastando 5 de mana para realizar a convers√£o;<br>Ra√ß√£o de Vida: Permite com que quem a coma ganhe at√© 1d10 de vida.<br>Ra√ß√£o de Mana: Permite com que quem a coma ganhe at√© 1d6 de mana.  <br><br><b>N√≠vel 3:</b>A sua personagem √© um grande mestre cuca, podendo cozinhar um banquete que revigora os aliados que o consomem. O banquete consome 5 de mana.<br>Banquete: O banquete recupera 6d6 pontos de vida de todos que o consomem, o tempo de preparo √© de 1 hora e exige uma ra√ß√£o por participante. ",
            },
            {
              name: "Furtividade",
              info: "Per√≠cia que mede o qu√£o bem o seu personagem √© capaz de se manter oculto e/ou omisso em um dado ambiente. <br><br><b>N√≠vel 1:</b> Para cada rolagem que enfoque em ficar furtivo, se esconder, recebe um b√¥nus de +3 na rolagem. <br><br><b>N√≠vel 2:</b> O b√¥nus √© aumentado para +5 e em √°reas com alta densidade populacional o b√¥nus torna-se +7.  <br><br><b>N√≠vel 3:</b> Todos os aliados que estejam fazendo um teste de furtividade com o jogador e n√£o possuam nenhum ponto na per√≠cia recebem o b√¥nus de +3 na rolagem.",
            },
            {
              name: "Improviso",
              info: "Habilidade para que o personagem seja capaz de gerar um leve improviso em uma situa√ß√£o, gerando-lhe algum tipo de vantagem menor. <br><br><b>N√≠vel 1:</b> Uma vez por dia pode-se adicionar 1d6 para qualquer rolagem sua. <br><br><b>N√≠vel 2:</b> Duas vezes por dia pode-se adicionar 1d6 para qualquer rolagem sua. <br><br><b>N√≠vel 3:</b> Tr√™s vezes por dia pode-se adicionar 1d6 para qualquer rolagem sua.",
            },
            {
              name: "Montar Armadilhas",
              info: "Dita a capacidade do personagem em montar armadilhas para capturar pessoas ou animais. <br><br><b>N√≠vel 1:</b> Com os conhecimentos de montagem de armadilha, a personagem pode montar um sistema de alarme ao redor de uma √°rea. Custando 1 de gold por 15 metros quadrados. Uma criatura que adentrar essa √°rea soar√° um alarme sonoro. <br><br><b>N√≠vel 2:</b> Uma personagem pode gastar 1 dia para realizar fortifica√ß√µes ao redor de uma √°rea. A personagem e seus aliados ter√£o +2 de AD em combates dentro da √°rea fortificada. A personagem gasta 5 de gold por 10 metros quadrados. <br><br><b>N√≠vel 3:</b> Uma personagem pode gastar mais um dia para que suas fortifica√ß√µes sejam ainda mais poderosas. A personagem e seus aliados ter√£o +1d6 em rolagens de combate dentro da √°rea. A √°rea afetada deve ser a mesma da √°rea fortificada e custar√° 50 de gold por 10 metros quadrados.",
            },
            {
              name: "Montaria",
              info: "Uma per√≠cia utilizada para poder averiguar o qu√£o bem o personagem consegue se conectar com sua montaria. <br><br><b>N√≠vel 1:</b> Ao primeiro n√≠vel, o personagem cria facilidade em ter animais n√£o m√°gicos de m√©dio porte de maior velocidade, permitindo com que ele possa ter animais de at√© 30 m em velocidade de corrida (ex: cavalo).<br><br><b>N√≠vel 2:</b> A capacidade de criar v√≠nculos se torna mais intensa, isso permite com que se possa ter animais de grande porte (como elefantes), ou ent√£o animais ainda mais r√°pidos de movimenta√ß√£o at√© 60 m. <br><br><b>N√≠vel 3:</b> Por fim, o personagem consegue se conectar t√£o bem com os animais que pode ter uma montaria m√°gica ou alada. Isso permite tamb√©m que ele possa ter montarias que cheguem a velocidades muito altas de 90 m.",
            },
            {
              name: "Rastreio",
              info: "Per√≠cia para medir como o personagem consegue rastrear outras criaturas ou pessoas, obtendo informa√ß√µes sobre seus rastros. <br><br><b>N√≠vel 1:</b> Para qualquer rolagem de natureza de rastreio recebe um b√¥nus de +3 na rolagem. <br><br><b>N√≠vel 2:</b> Aumento do b√¥nus de rolagem para +5, junto a isso voc√™ pode escolher uma dentre as seguintes classes: animais, humanoide ou seres m√°gicos e o seu b√¥nus ser√° de +7. <br><br><b>N√≠vel 3:</b> Seu personagem marca um alvo e √© capaz de saber com clareza para onde ele foi dentro de uma dist√¢ncia de 10 km.",
            },
            {
              name: "Percep√ß√£o",
              info: "Mede a capacidade do jogador em perceber seus arredores e mudan√ßas no ambiente ao qual ele se encontra. <br><br><b>N√≠vel 1:</b> Para qualquer rolagem de natureza de percep√ß√£o recebe um b√¥nus de +3 na rolagem. <br><br><b>N√≠vel 2:</b> Aumento do b√¥nus de rolagem para +5. <br><br><b>N√≠vel 3:</b> Aumento do b√¥nus de rolagem para +7 e o b√¥nus aumenta para +10 se for percep√ß√£o de armadilha.",
            },
            {
              name: "Vontade",
              info: "A vontade √© uma per√≠cia que implica na capacidade psicol√≥gica do personagem em suportar situa√ß√µes de estresse t√£o bem como efeitos que sejam da psique. <br><br><b>N√≠vel 1:</b> O primeiro ponto de insanidade obtido no dia √© negado. <br><br><b>N√≠vel 2:</b> O jogador poder√° gastar uma a√ß√£o de refor√ßo e 5 pontos de mana para remover 1d4 dentre as seguintes condi√ß√µes: confus√£o, encantado, medo, paralisado, triste ou moral. <br><br><b>N√≠vel 3:</b> O personagem pode escolher um dentre as seguintes condi√ß√µes para ter imunidade: atordoado, confus√£o, encantado, hipnotizado, medo ou triste. Fora isso, o primeiro ponto de insanidade n√£o possu√≠ efeito.",
            },
          ],
          prestigios: [
            {
              name: "Companheiro Animal",
              info: "Requisito: Sobreviv√™ncia. O personagem possui um companheiro animal leal que o auxilia em aventuras.",
            },
            {
              name: "Mestre de Venenos",
              info: "Requisito: Conhecimento. O personagem √© um especialista em criar e utilizar venenos.",
            },
          ],
        },

        {
          label: "Magia",
          sectionId: "magia",
          onClick: "handleSectionClick('magia')",
          attribute: { label: "MAG", dataAttribute: "mag" },
          skills: [
            {
              name: "B√™n√ß√£os",
              info: "Explicita a habilidade inata do personagem em ess√™ncias do hemisf√©rio de Vida. <br><br><b>N√≠vel 1:</b>Desbloqueia a ess√™ncia de Vita. <br><br><b>N√≠vel 2:</b>Magias feitas apenas com a ess√™ncia de Vita recebem um modificador de 0.75 no custo final de mana.  <br><br><b>N√≠vel 3:</b>Aumenta o dado natural de cura da ess√™ncia de Vita para 1d6. ",
            },
            {
              name: "Conjura√ß√£o",
              info: "Explicita a habilidade inata do personagem em ess√™ncias do hemisf√©rio de Conjura√ß√£o. <br><br><b>N√≠vel 1:</b>Desbloqueia a ess√™ncia de Forma. <br><br><b>N√≠vel 2:</b>O jogador recebe uma dimens√£o de bolso que o segue a todo lugar, garantindo 5 slots extras em seu interior.  <br><br><b>N√≠vel 3:</b>A personagem pode analisar um item, cujo valor m√°ximo seja de 1000 de gold, e estuda-lo por 30 minutos. Ap√≥s isso, ela cria uma replica do item estudado. O valor de mana gasto ser√° o pre√ßo do item divido por 10. O item dura por 1 dia. ",
            },
            {
              name: "Contra-Feiti√ßo",
              info: "Explicita a habilidade do personagem usar sua a√ß√£o de rea√ß√£o para bloquear a execu√ß√£o de uma magia ou um outro contra-feiti√ßo. <br><br><b>N√≠vel 1:</b>A personagem pode, ao ver a execu√ß√£o de uma magia, utilizar sua rea√ß√£o e 15 de MP para negar essa ativa√ß√£o. Essa habilidade s√≥ pode ser utilizada 1 vez por dia. <br><br><b>N√≠vel 2:</b>Reduz o pre√ßo de mana para 5 MP.  <br><br><b>N√≠vel 3:</b>A personagem pode utilizar um contra-feiti√ßo at√© 2 vezes por dia. ",
            },

            {
              name: "Energia",
              info: "Explicita a habilidade inata do personagem em ess√™ncias do hemisf√©rio de Energia. <br><br><b>N√≠vel 1:</b>Desbloqueia a ess√™ncia de Ignis. <br><br><b>N√≠vel 2:</b>Magias feitas apenas com a ess√™ncia de Ignis recebem um modificador de 0.75 no custo final de mana.  <br><br><b>N√≠vel 3:</b>Desbloqueia a ess√™ncia de Fax. ",
            },
            {
              name: "Feiti√ßaria",
              info: "Melhora a produ√ß√£o de magias pelo personagem, barateando as magias por ele produzidas. <br><br><b>N√≠vel 1:</b>Adiciona um modificador de 0.95 de pre√ßo de mana. <br><br><b>N√≠vel 2:</b>Amplifica o modificador para 0.9 de pre√ßo de mana.  <br><br><b>N√≠vel 3:</b>Intensifica ainda mais o modificador para 0.85 de pre√ßo de mana. ",
            },
            {
              name: "Ilusionismo",
              info: "Explicita a habilidade inata do personagem em ess√™ncias do hemisf√©rio de Ilus√£o. <br><br><b>N√≠vel 1:</b>Desbloqueia a ess√™ncia de Ambiens. <br><br><b>N√≠vel 2:</b>Magias feitas apenas com a ess√™ncia de Ambiens recebem um modificador de 0.75 no custo final de mana.  <br><br><b>N√≠vel 3:</b>Desbloqueia a ess√™ncia de Ego. ",
            },
            {
              name: "Invocador",
              info: "Permite com que o personagem tenha uma familiar e possa dar efeitos para ele. <br><br><b>N√≠vel 1:</b>Invoca o familiar com aspecto da escolha do jogador e escolhe 1 habilidade da tabela. <br><br><b>N√≠vel 2:</b>Pode escolher mais uma habilidade.  <br><br><b>N√≠vel 3:</b>Permite escolher a terceira habilidade, o jogador substituir uma das habilidade escolhidas anteriormente. ",
            },
            {
              name: "Ocultismo",
              info: "Explicita a habilidade inata do personagem em ess√™ncias do hemisf√©rio de Morte. <br><br><b>N√≠vel 1:</b>Desbloqueia a ess√™ncia de Corruptio. <br><br><b>N√≠vel 2:</b>O jogador pode realizar um ritual que leva 10 minutos, usando o corpo de um alvo e 7 pontos de mana para que este possa realizar 3 perguntas a um alvo que esteja morto. O alvo deve responder as perguntas verdadeiramente.  <br><br><b>N√≠vel 3:</b>O jogador pode escolher um alvo a at√© 60 metros e definir uma quantia de at√© 50 MP a queimar, a quantia escolhida ser√° aplicada na forma de dano necr√≥tico contra o alvo. ",
            },
            {
              name: "Shamanismo",
              info: "Explicita a habilidade inata do personagem em ess√™ncias do hemisf√©rio Material. <br><br><b>N√≠vel 1:</b>O jogador pode escolher uma dentre as seguintes ess√™ncias para desbloquear: Aqua, Terra ou Aer. <br><br><b>N√≠vel 2:</b>Magias feitas apenas com a ess√™ncia escolhida recebem um modificador de 0.75 no custo final de mana.  <br><br><b>N√≠vel 3:</b> O jogador pode transmutar metal em ouro. Ser√£o gastos 1 de mana para converter 10 gramas de um metal em uma moeda de ouro.",
            },
          ],
          prestigios: [
            {
              name: "Acad√™mico",
              info: "Requisito: Magia. O personagem tem conhecimento acad√™mico avan√ßado em √°reas m√°gicas e te√≥ricas.",
            },
            {
              name: "Alquimia",
              info: "Requisito: Conhecimento ou Magia. O personagem √© versado na arte da alquimia e cria√ß√£o de po√ß√µes.",
            },
          ],
        },
      ];

      // Roll functions for attributes and skills
      function rollAttribute(attributeKey, attributeName) {
        const attributeInput = document.querySelector(
          `input[data-attribute="${attributeKey}"]`
        );
        if (!attributeInput) {
          alert(`Atributo ${attributeName} n√£o encontrado!`);
          return;
        }

        const attributeLevel = parseInt(attributeInput.value) || 0;

        // Roll dice based on attribute level
        const diceCount = attributeLevel + 2; // +2 for base dice
        const rolls = [];

        for (let i = 0; i < diceCount; i++) {
          rolls.push(Math.floor(Math.random() * 6) + 1);
        }

        const total = rolls.reduce((sum, roll) => sum + roll, 0);
        const result = `üé≤ ${attributeName} (${diceCount}d6): [${rolls.join(
          ", "
        )}] = ${total}`;

        // Display result (you can customize this)
        alert(result);
        console.log(result);
      }

      function rollSkill(sectionId, skillName) {
        // Find the skill configuration
        const config = skillSectionsConfig.find(
          (c) => c.sectionId === sectionId
        );
        if (!config || !config.attribute) {
          alert(`Configura√ß√£o n√£o encontrada para ${skillName}!`);
          return;
        }

        // Get attribute level
        const attributeInput = document.querySelector(
          `input[data-attribute="${config.attribute.dataAttribute}"]`
        );
        if (!attributeInput) {
          alert(`Atributo ${config.attribute.label} n√£o encontrado!`);
          return;
        }
        const attributeLevel = parseInt(attributeInput.value) || 0;

        // Get skill level
        const skillContainer = document.querySelector(
          `[data-skill="${skillName}"][data-section="${sectionId}"]`
        );
        if (!skillContainer) {
          alert(`Habilidade ${skillName} n√£o encontrada!`);
          return;
        }

        const levelCheckboxes = skillContainer.querySelectorAll(
          ".skill-level:checked"
        );
        let skillLevel = 0;
        levelCheckboxes.forEach((checkbox) => {
          const level = parseInt(checkbox.dataset.level);
          if (level > skillLevel) skillLevel = level;
        });

        // TODO Implement skill adapter
        const flatBonus = 0; // Placeholder for flat bonus logic

        const diceCount = attributeLevel + 2; // +2 for base dice
        const rolls = [];

        for (let i = 0; i < diceCount; i++) {
          rolls.push(Math.floor(Math.random() * 6) + 1);
        }

        const flatBonusString = flatBonus > 0 ? ` + ${flatBonus}` : "";

        // Calculate total dice (attribute + skill)
        const total = rolls.reduce((sum, roll) => sum + roll, 0) + flatBonus;
        const result = `üé≤ ${skillName} (${diceCount}d6): [${rolls.join(
          ", "
        )}] ${flatBonusString} = ${total}`;

        // Display result (you can customize this)
        alert(result);
        console.log(result);
      }

      // Roll function for resource dice (HP, Mana, etc.)
      function rollResourceDice(resourceName, diceSelectId) {
        const diceSelect = document.getElementById(diceSelectId);
        if (!diceSelect) {
          alert(`Seletor de dado para ${resourceName} n√£o encontrado!`);
          return;
        }

        const level =
          parseInt(document.getElementById("character-level")?.textContent) ||
          0;
        const diceType = diceSelect.value;
        const diceSides = parseInt(diceType.substring(1)); // Remove 'd' and get number

        if (level === 0) {
          // Level 0: Set base to maximum dice value
          const maxValue = diceSides;
          initializeResourceBase(resourceName, maxValue, diceType);

          const result = `üé≤ ${resourceName} (N√≠vel 0): Base inicializada com valor m√°ximo ${maxValue}`;
          alert(result);
          console.log(result);
        } else {
          // Level 1+: Show confirmation and clear automatic history
          const confirmMessage = `Isso ir√° substituir todos os rolls autom√°ticos com rolls manuais.\n\nDeseja continuar e rolar manualmente para ${resourceName}?`;
          if (!confirm(confirmMessage)) {
            return;
          }

          // Clear existing history and start fresh with manual rolls
          clearResourceHistoryAndStartManual(resourceName, diceType, level);
        }
      }

      // Function to clear automatic history and start manual rolling
      function clearResourceHistoryAndStartManual(
        resourceName,
        diceType,
        currentLevel
      ) {
        const config = resourceSectionsConfig.find(
          (c) => c.resourceName === resourceName
        );
        if (!config) return;

        // Start fresh history - keep only level 0 if it exists
        const existingHistory = getResourceRollHistory(resourceName);
        const level0Entry = existingHistory.find((entry) => entry.level === 0);

        let newHistory = [];
        let baseValue = 0;

        if (level0Entry) {
          // Keep level 0 initialization
          newHistory.push(level0Entry);
          baseValue = level0Entry.roll;
        } else {
          // Create level 0 entry with max dice value
          const diceSides = parseInt(diceType.substring(1));
          const maxValue = diceSides;
          newHistory.push({
            level: 0,
            roll: maxValue,
            diceType: diceType,
            description: `N√≠vel 0: Valor m√°ximo do ${diceType}`,
          });
          baseValue = maxValue;
        }

        // Now roll manually for each level from 1 to current level
        for (let level = 1; level <= currentLevel; level++) {
          const diceSides = parseInt(diceType.substring(1));
          const roll = Math.floor(Math.random() * diceSides) + 1;
          baseValue += roll;

          newHistory.push({
            level: level,
            roll: roll,
            diceType: diceType,
            description: `N√≠vel ${level}: Rolou ${roll} no ${diceType} (manual)`,
          });
        }

        // Update the base input
        const baseInput = document.getElementById(config.baseId);
        if (baseInput) {
          baseInput.value = baseValue;
        }

        // Save the new manual history
        saveResourceRollHistory(resourceName, newHistory);

        // Show summary of manual rolls
        showManualRollSummary(
          resourceName,
          newHistory.filter((entry) => entry.level > 0)
        );

        // Recalculate total
        calculateResourceTotal(resourceName);
      }

      // Function to show summary of manual rolls
      function showManualRollSummary(resourceName, manualRolls) {
        if (manualRolls.length === 0) return;

        let summary = `üé≤ Rolls Manuais - ${resourceName}:\n\n`;
        let totalGained = 0;

        manualRolls.forEach((roll) => {
          summary += `N√≠vel ${roll.level}: Rolou ${roll.roll} no ${roll.diceType}\n`;
          totalGained += roll.roll;
        });

        summary += `\nTotal ganho nos rolls: +${totalGained}`;
        summary += `\nHist√≥rico autom√°tico foi substitu√≠do pelos rolls manuais.`;

        alert(summary);
      }

      // Function to initialize base resource at level 0
      function initializeResourceBase(resourceName, baseValue, diceType) {
        const config = resourceSectionsConfig.find(
          (c) => c.resourceName === resourceName
        );
        if (!config) return;

        const baseInput = document.getElementById(config.baseId);
        if (baseInput) {
          baseInput.value = baseValue;
        }

        // Initialize roll history
        const rollHistory = [
          {
            level: 0,
            roll: baseValue,
            diceType: diceType,
            description: `N√≠vel 0: Valor m√°ximo do ${diceType}`,
          },
        ];

        // Save roll history to resource data
        saveResourceRollHistory(resourceName, rollHistory);

        // Recalculate total
        calculateResourceTotal(resourceName);
      }

      // Function to roll dice and add to resource base
      function rollAndAddToResource(resourceName, diceType, level) {
        const config = resourceSectionsConfig.find(
          (c) => c.resourceName === resourceName
        );
        if (!config) return;

        const baseInput = document.getElementById(config.baseId);
        if (!baseInput) return;

        const diceSides = parseInt(diceType.substring(1));
        const roll = Math.floor(Math.random() * diceSides) + 1;
        const currentBase = parseInt(baseInput.value) || 0;
        const newBase = currentBase + roll;

        baseInput.value = newBase;

        // Get existing roll history and add new roll
        const existingHistory = getResourceRollHistory(resourceName);
        existingHistory.push({
          level: level,
          roll: roll,
          diceType: diceType,
          description: `N√≠vel ${level}: Rolou ${roll} no ${diceType}`,
        });

        saveResourceRollHistory(resourceName, existingHistory);

        const result = `üé≤ ${resourceName} (N√≠vel ${level}): Rolou ${roll} no ${diceType}. Base: ${currentBase} + ${roll} = ${newBase}`;
        alert(result);
        console.log(result);

        // Recalculate total
        calculateResourceTotal(resourceName);
      }

      // Function to save resource roll history
      function saveResourceRollHistory(resourceName, rollHistory) {
        const key = `fac_09_${resourceName.toLowerCase()}_roll_history`;
        try {
          localStorage.setItem(key, JSON.stringify(rollHistory));
        } catch (error) {
          console.error(
            `Error saving roll history for ${resourceName}:`,
            error
          );
        }
      }

      // Function to get resource roll history
      function getResourceRollHistory(resourceName) {
        const key = `fac_09_${resourceName.toLowerCase()}_roll_history`;
        try {
          const history = localStorage.getItem(key);
          return history ? JSON.parse(history) : [];
        } catch (error) {
          console.error(
            `Error loading roll history for ${resourceName}:`,
            error
          );
          return [];
        }
      }

      // Function to show resource roll history
      function showResourceRollHistory(resourceName) {
        const history = getResourceRollHistory(resourceName);

        if (history.length === 0) {
          alert(`Nenhum hist√≥rico de rolls encontrado para ${resourceName}.`);
          return;
        }

        let historyText = `Hist√≥rico de Rolls - ${resourceName}:\n\n`;
        let total = 0;

        history.forEach((entry, index) => {
          historyText += `${entry.description}\n`;
          total = index === 0 ? entry.roll : total + entry.roll;
        });

        historyText += `\nTotal Base: ${total}`;

        alert(historyText);
      }

      // Function to show summary of automatic rolls
      function showAutoRollSummary(levelsRolled) {
        if (levelsRolled.length === 0) return;

        let summary = `üé≤ Rolls Autom√°ticos - N√≠veis ${levelsRolled.join(
          ", "
        )}:\n\n`;

        resourceSectionsConfig.forEach((config) => {
          const history = getResourceRollHistory(config.resourceName);
          const levelRolls = history.filter((entry) =>
            levelsRolled.includes(entry.level)
          );

          if (levelRolls.length > 0) {
            summary += `${config.resourceName}:\n`;
            levelRolls.forEach((roll) => {
              summary += `  N√≠vel ${roll.level}: ${roll.roll} no ${roll.diceType}\n`;
            });

            // Calculate total gained
            const totalGained = levelRolls.reduce(
              (sum, roll) => sum + roll.roll,
              0
            );
            summary += `  Total ganho: +${totalGained}\n\n`;
          }
        });

        summary += `Clique no bot√£o "üìã Hist√≥rico" para ver todos os rolls detalhados.`;
        alert(summary);
      }

      // Function called when dice type changes
      function onDiceTypeChange(resourceName) {
        // Always trigger resource recalculation when dice type changes, clearing history
        updateResourceBaseValues(true); // true indicates dice type changed

        // Always trigger auto-save when dice type changes
        clearTimeout(window.saveTimeout);
        window.saveTimeout = setTimeout(() => {
          saveCharacterDataToStorage();
        }, 500);
      }

      // Single comprehensive function to handle all resource base calculations
      function updateResourceBaseValues(diceTypeChanged = false) {
        const currentLevel =
          parseInt(document.getElementById("character-level")?.textContent) ||
          0;

        console.log(
          `Updating resource base values for level ${currentLevel}${
            diceTypeChanged ? " (dice type changed)" : ""
          }`
        );

        resourceSectionsConfig.forEach((config) => {
          const diceSelect = document.getElementById(config.diceSelectId);
          const baseInput = document.getElementById(config.baseId);

          if (!diceSelect || !baseInput) return;

          const diceType = diceSelect.value;
          const diceSides = parseInt(diceType.substring(1));

          // Get existing roll history
          let rollHistory = getResourceRollHistory(config.resourceName);

          // If dice type changed, check if we need to clear history
          if (diceTypeChanged && rollHistory.length > 0) {
            // Check if the existing history has different dice types
            const existingDiceType = rollHistory[0]?.diceType;
            if (existingDiceType && existingDiceType !== diceType) {
              console.log(
                `Dice type changed from ${existingDiceType} to ${diceType} for ${config.resourceName}, clearing history`
              );
              rollHistory = []; // Clear the history
              localStorage.setItem(
                `fac_09_${config.resourceName.toLowerCase()}_roll_history`,
                JSON.stringify(rollHistory)
              );
            }
          }

          const existingLevels = new Set(
            rollHistory.map((entry) => entry.level)
          );

          // Ensure level 0 exists in history
          if (!existingLevels.has(0)) {
            const maxValue = diceSides;
            rollHistory.unshift({
              level: 0,
              roll: maxValue,
              diceType: diceType,
              description: `N√≠vel 0: Valor m√°ximo do ${diceType}`,
            });
            existingLevels.add(0);
            console.log(
              `Auto-initialized ${config.resourceName} level 0 with ${maxValue}`
            );
          }

          // Find and roll for missing levels from 1 to currentLevel
          const missingLevels = [];
          for (let level = 1; level <= currentLevel; level++) {
            if (!existingLevels.has(level)) {
              missingLevels.push(level);
            }
          }

          // Roll for missing levels
          missingLevels.forEach((level) => {
            const roll = Math.floor(Math.random() * diceSides) + 1;
            rollHistory.push({
              level: level,
              roll: roll,
              diceType: diceType,
              description: `N√≠vel ${level}: Rolou ${roll} no ${diceType} (autom√°tico)`,
            });
            console.log(
              `üé≤ ${config.resourceName} (N√≠vel ${level}): Rolou ${roll} no ${diceType}`
            );
          });

          // Sort history by level
          rollHistory.sort((a, b) => a.level - b.level);

          // Calculate base value up to current level
          let calculatedBase = 0;
          rollHistory.forEach((entry) => {
            if (entry.level <= currentLevel) {
              if (entry.level === 0) {
                calculatedBase = entry.roll; // Level 0 sets the base
              } else {
                calculatedBase += entry.roll; // Subsequent levels add to base
              }
            }
          });

          // Update the base input
          baseInput.value = calculatedBase;
          console.log(
            `Updated ${config.resourceName} base to ${calculatedBase} (up to level ${currentLevel})`
          );

          // Save updated roll history (only if we added new rolls)
          if (missingLevels.length > 0) {
            saveResourceRollHistory(config.resourceName, rollHistory);
          }

          // Recalculate total after base update
          calculateResourceTotal(config.resourceName);
        });
      }

      // Level editing functions
      function editLevel(element) {
        // Store current level before editing for comparison
        element.dataset.previousLevel = element.textContent;

        element.focus();
        // Select all text when clicking to edit
        if (window.getSelection && document.createRange) {
          const range = document.createRange();
          range.selectNodeContents(element);
          const selection = window.getSelection();
          selection.removeAllRanges();
          selection.addRange(range);
        }
      }

      function saveLevel(element) {
        const previousLevel = parseInt(element.dataset.previousLevel) || 0;
        let level = parseInt(element.textContent) || 0;
        if (level < 0) level = 0;
        if (level > 20) level = 20; // Set a reasonable max level
        element.textContent = level;

        // Store the new level for next comparison
        element.dataset.previousLevel = level;

        console.log(`Level changed from ${previousLevel} to ${level}`);

        // Update available points when level changes
        updateMaxPointsOnLevelUp();

        // Update dice selector availability based on new level
        updateDiceSelectorAvailability();

        // Update all resource base values for the new level
        updateResourceBaseValues(false); // false indicates level change, not dice type change

        // Trigger auto-save
        clearTimeout(window.saveTimeout);
        window.saveTimeout = setTimeout(() => {
          saveCharacterDataToStorage();
        }, 500);
      }
      function handleLevelKeypress(event, element) {
        // Allow only numbers and enter key
        if (event.key === "Enter") {
          element.blur();
          return false;
        }

        // Allow only digits, backspace, delete, arrow keys
        if (
          !/[\d]/.test(event.key) &&
          !["Backspace", "Delete", "ArrowLeft", "ArrowRight"].includes(
            event.key
          )
        ) {
          event.preventDefault();
          return false;
        }
      }

      // Function to update available points when leveling up
      function updateMaxPointsOnLevelUp() {
        // Currently empty as requested
        // This function will be used to calculate available points based on level progression

        // For now, calculate basic available points
        calculateAvailablePoints();
      }

      // Configuration for level progression
      const levelProgressionConfig = {
        // Skill points gained at each level (cumulative) - array index = level
        skillPointsPerLevel: [
          10, 1, 2, 2, 2, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 1, 2, 2, 2, 3, 3, 3, 4,
          4, 3, 2, 2, 2, 2, 1, 2, 2, 2, 3, 3, 3, 4, 4,
        ],
        // Attribute points: base 5 + 1 for every even level
        attributePointsBase: 5,
        attributePointsPerThreeLevels: 1,
      };

      // Function to calculate available points based on character level
      function calculateAvailablePoints() {
        const level =
          parseInt(document.getElementById("character-level").textContent) || 0;

        // Calculate attribute points: base + bonus for every 3 levels (excluding level 0)
        const threeLevelBonus =
          level > 0
            ? Math.floor(level / 3) *
              levelProgressionConfig.attributePointsPerThreeLevels
            : 0;
        const availableAttributePoints =
          levelProgressionConfig.attributePointsBase + threeLevelBonus;

        // Calculate cumulative skill points
        let availableSkillPoints = 0;

        // Sum up skill points from level 0 to current level
        for (let i = 0; i <= level; i++) {
          if (i < levelProgressionConfig.skillPointsPerLevel.length) {
            availableSkillPoints +=
              levelProgressionConfig.skillPointsPerLevel[i];
          }
          // If level goes beyond array size, ignore (no additional points)
        }

        // Update the display
        document.getElementById("attribute-available").textContent =
          availableAttributePoints;
        document.getElementById("skill-available").textContent =
          availableSkillPoints;

        return {
          attributes: availableAttributePoints,
          skills: availableSkillPoints,
        };
      }

      // Event handler for section clicks
      function handleSectionClick(sectionId) {
        console.log(`Section clicked: ${sectionId}`);

        // Example: Toggle section highlight
        const section = document.querySelector(`[data-section="${sectionId}"]`);
        if (section) {
          section.classList.toggle("highlighted");
        }

        // Custom logic can be added here for each section
        switch (sectionId) {
          case "social":
            console.log("Social skills section clicked");
            break;
          case "cultura":
            console.log("Cultura skills section clicked");
            break;
          case "atletismo":
            console.log("Atletismo skills section clicked");
            break;
          case "manual":
            console.log("Manual skills section clicked");
            break;
          case "combate":
            console.log("Combate skills section clicked");
            break;
          case "sobrevivencia":
            console.log("Sobreviv√™ncia skills section clicked");
            break;
          case "sistema_faq":
            console.log("Sistema FAQ section clicked");
            break;
          case "magia":
            console.log("Magia section clicked");
            break;
          case "recursos":
            console.log("Recursos section clicked");
            break;
          default:
            console.log("Unknown section clicked");
        }
      }

      // Function to save character data to localStorage
      function saveCharacterDataToStorage() {
        const data = saveCharacterData();
        try {
          localStorage.setItem("fac_09_character_sheet", JSON.stringify(data));
          console.log("Character data saved to localStorage");
        } catch (error) {
          console.error("Error saving to localStorage:", error);
        }
      }

      // Function to load character data from localStorage
      function loadCharacterDataFromStorage() {
        try {
          const savedData = localStorage.getItem("fac_09_character_sheet");
          if (savedData) {
            const data = JSON.parse(savedData);
            loadCharacterData(data);
            // Recalculate points after loading
            calculateTotalPoints();
            console.log("Character data loaded from localStorage");
            return true;
          }
        } catch (error) {
          console.error("Error loading from localStorage:", error);
        }
        return false;
      }

      // Function to clear saved character data
      function clearSavedCharacterData() {
        try {
          localStorage.removeItem("fac_09_character_sheet");
          localStorage.removeItem("fac_09_character_magics");
          // Clear roll histories for all resources
          resourceSectionsConfig.forEach((config) => {
            localStorage.removeItem(
              `fac_09_${config.resourceName.toLowerCase()}_roll_history`
            );
          });

          // Clear magic manager
          if (magicManager) {
            magicManager.magics = [];
            magicManager.renderMagicList();
          }

          // Clear essence selection state
          clearEssenceSelectionState();

          console.log("All saved character data cleared");
          alert("Todos os dados salvos foram removidos.");
        } catch (error) {
          console.error("Error clearing localStorage:", error);
        }
      }

      // Function to save character data to JSON
      function saveCharacterData() {
        const data = {
          characterName: document.querySelector(
            'input[placeholder="Nome do personagem"]'
          ).value,
          description: document.querySelector(
            'textarea[placeholder="Descri√ß√£o do personagem..."]'
          ).value,
          level:
            parseInt(document.getElementById("character-level").textContent) ||
            0,
          attributes: {
            con:
              document.querySelector('input[data-attribute="con"]')?.value || 0,
            soc:
              document.querySelector('input[data-attribute="soc"]')?.value || 0,
            mag:
              document.querySelector('input[data-attribute="mag"]')?.value || 0,
            alt:
              document.querySelector('input[data-attribute="alt"]')?.value || 0,
            man:
              document.querySelector('input[data-attribute="man"]')?.value || 0,
            com:
              document.querySelector('input[data-attribute="com"]')?.value || 0,
            sob:
              document.querySelector('input[data-attribute="sob"]')?.value || 0,
            cul:
              document.querySelector('input[data-attribute="cul"]')?.value || 0,
          },
          skills: {},
          hp: {
            base: document.getElementById("hp-base")?.value || 0,
            extra: document.getElementById("hp-extra")?.value || 0,
            total: document.getElementById("hp-total")?.value || 0,
            current: document.getElementById("hp-current")?.value || 0,
            diceType: document.getElementById("hp-dice-select")?.value || "d6",
            rollHistory: getResourceRollHistory("HP"),
          },
          mana: {
            base: document.getElementById("mana-base")?.value || 0,
            extra: document.getElementById("mana-extra")?.value || 0,
            total: document.getElementById("mana-total")?.value || 0,
            current: document.getElementById("mana-current")?.value || 0,
            diceType:
              document.getElementById("mana-dice-select")?.value || "d6",
            rollHistory: getResourceRollHistory("Mana"),
          },
        };

        // Collect skill levels (1, 2, 3) instead of just checked/unchecked
        document.querySelectorAll(".skill-levels").forEach((skillContainer) => {
          const skillName = skillContainer.dataset.skill;
          const levelCheckboxes = skillContainer.querySelectorAll(
            ".skill-level:checked"
          );

          // Find the highest checked level for this skill
          let maxLevel = 0;
          levelCheckboxes.forEach((checkbox) => {
            const level = parseInt(checkbox.dataset.level);
            if (level > maxLevel) maxLevel = level;
          });

          data.skills[skillName] = maxLevel;
        });

        // Collect resources and inventory text
        const resourcesTextarea = document.querySelector(
          '[data-section="recursos"] textarea'
        );
        if (resourcesTextarea) {
          data.resources = resourcesTextarea.value;
        }

        const inventoryTextarea = document.querySelector(
          '.resources-section:not([data-section="recursos"]) textarea'
        );
        if (inventoryTextarea) {
          data.inventory = inventoryTextarea.value;
        }

        // Collect movement value
        const movementInput = document.getElementById("movement");
        if (movementInput) {
          data.movement = movementInput.value;
        }

        // Collect magics data
        if (magicManager) {
          data.magics = magicManager.getMagicsData();
        }

        // Collect current essence selection state
        data.currentEssenceSelection = getCurrentEssenceSelectionState();

        return data;
      }

      // Function to load character data from JSON
      function loadCharacterData(data) {
        if (data.characterName) {
          document.querySelector(
            'input[placeholder="Nome do personagem"]'
          ).value = data.characterName;
        }
        if (data.description) {
          document.querySelector(
            'textarea[placeholder="Descri√ß√£o do personagem..."]'
          ).value = data.description;
        }

        // Load character level
        if (data.level !== undefined) {
          const levelElement = document.getElementById("character-level");
          if (levelElement) {
            levelElement.textContent = data.level;
            // Initialize previous level for future comparisons
            levelElement.dataset.previousLevel = data.level;
          }
        }

        // Load attributes
        Object.keys(data.attributes || {}).forEach((attr) => {
          const input = document.querySelector(
            `input[data-attribute="${attr}"]`
          );
          if (input) input.value = data.attributes[attr];
        });

        // Load skills with levels
        Object.keys(data.skills || {}).forEach((skillName) => {
          const skillLevel = data.skills[skillName];
          const skillContainer = document.querySelector(
            `[data-skill="${skillName}"].skill-levels`
          );

          if (skillContainer && skillLevel > 0) {
            // Check all levels up to the saved level
            for (let level = 1; level <= skillLevel; level++) {
              const checkbox = skillContainer.querySelector(
                `input[data-level="${level}"]`
              );
              if (checkbox) checkbox.checked = true;
            }
          }
        });

        // Load resources
        if (data.resources !== undefined) {
          const resourcesTextarea = document.querySelector(
            '[data-section="recursos"] textarea'
          );
          if (resourcesTextarea) {
            resourcesTextarea.value = data.resources;
          }
        }

        // Load inventory
        if (data.inventory !== undefined) {
          const inventoryTextarea = document.querySelector(
            '.resources-section:not([data-section="recursos"]) textarea'
          );
          if (inventoryTextarea) {
            inventoryTextarea.value = data.inventory;
          }
        }

        // Load movement
        if (data.movement !== undefined) {
          const movementInput = document.getElementById("movement");
          if (movementInput) {
            movementInput.value = data.movement;
          }
        }

        // Load HP and Mana values
        if (data.hp) {
          if (data.hp.base !== undefined) {
            const hpBaseInput = document.getElementById("hp-base");
            if (hpBaseInput) hpBaseInput.value = data.hp.base;
          }
          if (data.hp.extra !== undefined) {
            const hpExtraInput = document.getElementById("hp-extra");
            if (hpExtraInput) hpExtraInput.value = data.hp.extra;
          }
          if (data.hp.total !== undefined) {
            const hpTotalInput = document.getElementById("hp-total");
            if (hpTotalInput) hpTotalInput.value = data.hp.total;
          }
          if (data.hp.current !== undefined) {
            const hpCurrentInput = document.getElementById("hp-current");
            if (hpCurrentInput) hpCurrentInput.value = data.hp.current;
          }
          if (data.hp.diceType !== undefined) {
            const hpDiceSelect = document.getElementById("hp-dice-select");
            if (hpDiceSelect) hpDiceSelect.value = data.hp.diceType;
          }
          if (data.hp.rollHistory !== undefined) {
            saveResourceRollHistory("HP", data.hp.rollHistory);
          }
        }

        if (data.mana) {
          if (data.mana.base !== undefined) {
            const manaBaseInput = document.getElementById("mana-base");
            if (manaBaseInput) manaBaseInput.value = data.mana.base;
          }
          if (data.mana.extra !== undefined) {
            const manaExtraInput = document.getElementById("mana-extra");
            if (manaExtraInput) manaExtraInput.value = data.mana.extra;
          }
          if (data.mana.total !== undefined) {
            const manaTotalInput = document.getElementById("mana-total");
            if (manaTotalInput) manaTotalInput.value = data.mana.total;
          }
          if (data.mana.current !== undefined) {
            const manaCurrentInput = document.getElementById("mana-current");
            if (manaCurrentInput) manaCurrentInput.value = data.mana.current;
          }
          if (data.mana.diceType !== undefined) {
            const manaDiceSelect = document.getElementById("mana-dice-select");
            if (manaDiceSelect) manaDiceSelect.value = data.mana.diceType;
          }
          if (data.mana.rollHistory !== undefined) {
            saveResourceRollHistory("Mana", data.mana.rollHistory);
          }
        }

        // Revalidate and recalculate after loading
        // Update skill availability for all sections based on loaded attribute values
        skillSectionsConfig.forEach((config) => {
          if (config.attribute) {
            const attributeInput = document.querySelector(
              `input[data-attribute="${config.attribute.dataAttribute}"]`
            );
            const attributeValue = attributeInput
              ? parseInt(attributeInput.value) || 0
              : 0;
            updateSkillAvailability(config.sectionId, attributeValue);
          }
        });

        // Update available points first, then calculate totals
        calculateAvailablePoints();
        validateAttributeAndSkills();
        calculateTotalPoints();

        // Recalculate resource totals after loading
        resourceSectionsConfig.forEach((config) => {
          calculateResourceTotal(config.resourceName);
        });

        // Load magics data
        if (data.magics && magicManager) {
          magicManager.loadMagicsData(data.magics);
        }

        // Load current essence selection state
        if (data.currentEssenceSelection) {
          loadEssenceSelectionState(data.currentEssenceSelection);
        }

        // Update dice selector availability based on loaded level
        updateDiceSelectorAvailability();
      }

      // Add CSS for highlighted sections
      const style = document.createElement("style");
      style.textContent = `
            .highlighted .section-title {
                background: #007bff !important;
                transform: scale(1.02);
                transition: all 0.2s ease;
            }
            .section-title:hover {
                opacity: 0.8;
                transition: opacity 0.2s ease;
            }
            .skill-level:disabled {
                opacity: 0.3 !important;
                cursor: not-allowed !important;
            }
            .skill-level:disabled + .level-label {
                color: #6c757d !important;
                opacity: 0.3 !important;
            }
            .skill-levels:not(.disabled) .skill-level:not(:disabled) {
                opacity: 1;
                cursor: pointer;
            }
            .skill-levels:not(.disabled) .skill-level:not(:disabled) + .level-label {
                color: inherit;
                opacity: 1;
            }
            input[data-attribute] {
                border: 2px solid #333;
                font-weight: bold;
            }
            input[data-attribute]:focus {
                border-color: #007bff;
                box-shadow: 0 0 0 0.2rem rgba(0,123,255,.25);
            }
            .essence-quantity:disabled {
                opacity: 0.5 !important;
                background-color: #f8f9fa !important;
                cursor: not-allowed !important;
            }
            .essence-quantity-container {
                margin-bottom: 8px;
            }
            .essence-checkbox {
                margin-right: 8px;
            }
            .essence-label {
                min-width: 120px;
                font-weight: 500;
            }
        `;
      document.head.appendChild(style);

      // Initialize the extensible components when the page loads
      document.addEventListener("DOMContentLoaded", function () {
        console.log("Character Sheet Extensible Components Initialized");

        // Initialize magic manager
        magicManager = new MagicManager();

        // Render dynamic sections using the component system
        const skillComponent = new SkillSectionComponent();
        const resourceComponent = new ResourceComponent();

        // Render resource sections (HP, Mana, etc.)
        resourceComponent.renderFromJson(
          resourceSectionsConfig,
          "resource-sections-container"
        );

        // Generate all sections HTML
        let allSectionsHtml = "";
        skillSectionsConfig.forEach((config) => {
          allSectionsHtml += skillComponent.renderSection(config);
        });

        // Render all JSON sections together in the main layout
        renderAllSectionsInLayout(skillComponent);

        // Also render all sections in the preview container if it exists
        const allSectionsContainer = document.getElementById(
          "all-sections-container"
        );
        if (allSectionsContainer) {
          allSectionsContainer.innerHTML = allSectionsHtml;
        }

        // Update the Sistema FAQ section (Conhecimento)
        const sistemaFaqSection = document.querySelector(
          '[data-section="sistema_faq"] .card-body'
        );
        if (sistemaFaqSection && skillSectionsConfig[0]) {
          // Conhecimento is index 0
          const conhecimentoConfig = skillSectionsConfig[0];
          const conhecimentoHtml = `
            <div class="checkbox-list">
              ${skillComponent.generateCheckboxes(
                conhecimentoConfig.skills,
                conhecimentoConfig.sectionId
              )}
            </div>
          `;
          sistemaFaqSection.innerHTML = conhecimentoHtml;
        }

        // Update the Magia section in the top area if it exists
        const magiaSection = document.querySelector(
          '[data-section="magia"] .card-body'
        );
        if (magiaSection && skillSectionsConfig[7]) {
          // Magia is index 7
          const magiaConfig = skillSectionsConfig[7];
          const magiaHtml = `
            <div class="checkbox-list">
              ${skillComponent.generateCheckboxes(
                magiaConfig.skills,
                magiaConfig.sectionId
              )}
            </div>
          `;
          magiaSection.innerHTML = magiaHtml;
        }

        console.log(
          "All sections have been dynamically updated with their configurations"
        );

        // Initial point calculation
        calculateTotalPoints();

        // Calculate available points
        calculateAvailablePoints();

        // Load any saved character data
        const hasLoadedData = loadCharacterDataFromStorage();

        // If no saved data was loaded, initialize skill availability with default values
        if (!hasLoadedData) {
          skillSectionsConfig.forEach((config) => {
            if (config.attribute) {
              updateSkillAvailability(config.sectionId, 0); // Start with 0 attribute values
            }
          });

          // Initialize previous level for new characters
          const levelElement = document.getElementById("character-level");
          if (levelElement) {
            levelElement.dataset.previousLevel =
              levelElement.textContent || "0";
          }
        }

        // Set up automatic saving
        setupAutoSave();

        // Update dice selector availability on initial load
        updateDiceSelectorAvailability();

        // Recalculate base resources after everything is loaded
        updateResourceBaseValues(false); // false indicates initialization, not dice type change

        // Render initial magic list
        if (magicManager) {
          magicManager.renderComponentOptions();
          magicManager.renderEssencesSelection();
          magicManager.renderMagicList();

          // Apply saved essence selection state immediately after rendering essences
          setTimeout(() => {
            // Load saved character data to get essence selection state
            try {
              const savedData = localStorage.getItem("fac_09_character_sheet");
              if (savedData) {
                const data = JSON.parse(savedData);
                if (data.currentEssenceSelection) {
                  loadEssenceSelectionState(data.currentEssenceSelection);
                }
              }
            } catch (error) {
              console.error("Error loading essence selection state:", error);
            }

            updateFinalCostDisplay();
          }, 100);
        }
      });

      function setupAutoSave() {
        // Save whenever any input changes
        document.addEventListener("input", function (e) {
          // Debounce saving to avoid too many saves
          clearTimeout(window.saveTimeout);
          window.saveTimeout = setTimeout(() => {
            saveCharacterDataToStorage();
          }, 500);
        });

        // Save whenever checkboxes change
        document.addEventListener("change", function (e) {
          if (e.target.type === "checkbox") {
            clearTimeout(window.saveTimeout);
            window.saveTimeout = setTimeout(() => {
              saveCharacterDataToStorage();
            }, 500);
          }
        });
      }

      // Function to render all sections from JSON in the main layout
      function renderAllSectionsInLayout(skillComponent) {
        const dynamicContainer = document.getElementById(
          "dynamic-skill-sections"
        );
        const additionalContainer = document.getElementById(
          "additional-skill-sections"
        );

        if (!dynamicContainer || !additionalContainer) return;

        // Clear containers
        dynamicContainer.innerHTML = "";
        additionalContainer.innerHTML = "";

        // Define which sections go where (customize as needed)
        const mainSections = [0, 1, 2, 7]; // Conhecimento, Social, Cultura, Magia (indices in skillSectionsConfig)
        const additionalSections = [3, 4, 5, 6]; // Atletismo, Manufatura, Combate, Sobreviv√™ncia

        // Render main sections (Conhecimento, Social, Cultura, Magia)
        let mainHtml = '<div class="row">';
        mainSections.forEach((configIndex) => {
          if (skillSectionsConfig[configIndex]) {
            const config = skillSectionsConfig[configIndex];
            mainHtml += `
              <div class="col-md-3">
                ${skillComponent.renderSection(config)}
              </div>
            `;
          }
        });
        mainHtml += "</div>";
        dynamicContainer.innerHTML = mainHtml;

        // Render additional sections (Atletismo, Manufatura, Combate, Sobreviv√™ncia)
        let additionalHtml = '<div class="row">';
        additionalSections.forEach((configIndex) => {
          if (skillSectionsConfig[configIndex]) {
            const config = skillSectionsConfig[configIndex];
            additionalHtml += `
              <div class="col-md-3">
                ${skillComponent.renderSection(config)}
              </div>
            `;
          }
        });
        additionalHtml += "</div>";
        additionalContainer.innerHTML = additionalHtml;

        console.log(
          "All JSON sections rendered in main layout with attributes"
        );

        // Don't initialize skill availability here - wait for data to load first
      }

      // Validation function for attribute changes
      function validateAttributeAndSkills(attributeName, sectionId) {
        const attributeInput = document.querySelector(
          `input[data-attribute="${attributeName}"]`
        );
        if (!attributeInput) return;

        // Ensure attribute value is between 0 and 3
        let value = parseInt(attributeInput.value);
        if (isNaN(value) || value < 0) {
          value = 0;
          attributeInput.value = 0;
        } else if (value > 3) {
          value = 3;
          attributeInput.value = 3;
        }

        // Update skill availability based on attribute value
        updateSkillAvailability(sectionId, value);

        // Update point calculation
        calculateTotalPoints();
      }

      // Function to toggle skill levels (1, 2, 3)
      function toggleSkillLevel(checkbox, level) {
        const sectionId = checkbox.dataset.section;
        const skillName = checkbox.dataset.skill;

        if (!sectionId) return;

        // Find the corresponding attribute for this section
        const config = skillSectionsConfig.find(
          (c) => c.sectionId === sectionId
        );
        if (!config || !config.attribute) return;

        const attributeInput = document.querySelector(
          `input[data-attribute="${config.attribute.dataAttribute}"]`
        );
        if (!attributeInput) return;

        const attributeValue = parseInt(attributeInput.value) || 0;

        // Check if the level is allowed based on attribute value
        if (level > attributeValue) {
          checkbox.checked = false;
          alert(
            `Voc√™ precisa ter pelo menos ${level} pontos em ${config.attribute.label} para selecionar o n√≠vel ${level} de ${skillName}`
          );
          return false;
        }

        // Get all level checkboxes for this skill
        const skillContainer = checkbox.closest(".skill-levels");
        const levelCheckboxes = skillContainer.querySelectorAll(".skill-level");

        if (checkbox.checked) {
          // If checking a level, also check all lower levels
          levelCheckboxes.forEach((cb) => {
            const cbLevel = parseInt(cb.dataset.level);
            if (cbLevel <= level) {
              cb.checked = true;
            }
          });
        } else {
          // If unchecking a level, also uncheck all higher levels
          levelCheckboxes.forEach((cb) => {
            const cbLevel = parseInt(cb.dataset.level);
            if (cbLevel >= level) {
              cb.checked = false;
            }
          });
        }

        // Update point calculation after skill change
        calculateTotalPoints();
        return true;
      }

      // Function to toggle Prestigio skills (costs 1 attribute point each)
      function togglePrestigioSkill(checkbox) {
        // Update point calculation after prestigio skill change
        calculateTotalPoints();
        return true;
      }

      // Function to update skill availability based on attribute value
      function updateSkillAvailability(sectionId, attributeValue) {
        const sectionElement = document.querySelector(
          `[data-section="${sectionId}"]`
        );
        if (!sectionElement) return;

        const skillContainers =
          sectionElement.querySelectorAll(".skill-levels");

        skillContainers.forEach((container) => {
          const levelCheckboxes = container.querySelectorAll(".skill-level");

          levelCheckboxes.forEach((checkbox) => {
            const level = parseInt(checkbox.dataset.level);

            if (level > attributeValue) {
              // Disable and uncheck levels higher than attribute value
              checkbox.disabled = true;
              checkbox.checked = false;
            } else if (attributeValue >= 1) {
              // Enable levels within attribute value (only if attribute is at least 1)
              checkbox.disabled = false;
            } else {
              // If attribute is 0, disable all levels
              checkbox.disabled = true;
              checkbox.checked = false;
            }
          });

          // Update visual state of the entire skill container
          console.log("attributeValue:", attributeValue);
          if (attributeValue === 0) {
            container.classList.add("disabled");
          } else {
            container.classList.remove("disabled");
          }
        });
      }

      // Function to calculate skill level cost
      function calculateSkillCost(level) {
        switch (level) {
          case 1:
            return 1;
          case 2:
            return 1 + 1;
          case 3:
            return 1 + 1 + 1;
          default:
            return 0;
        }
      }

      // Function to calculate total points
      function calculateTotalPoints() {
        let attributePoints = 0;
        let skillPoints = 0;
        let prestigioPoints = 0;

        // Calculate attribute points (1 point per level)
        document.querySelectorAll("input[data-attribute]").forEach((input) => {
          const value = parseInt(input.value) || 0;
          attributePoints += value;
        });

        // Calculate skill points (1/2/4 points for levels 1/2/3)
        // Exclude recursos section since it's now just text
        document.querySelectorAll(".skill-levels").forEach((skillContainer) => {
          const sectionId = skillContainer.dataset.section;

          // Skip recursos section
          if (sectionId === "recursos") return;

          const levelCheckboxes = skillContainer.querySelectorAll(
            ".skill-level:checked"
          );

          // Find the highest checked level for this skill
          let maxLevel = 0;
          levelCheckboxes.forEach((checkbox) => {
            const level = parseInt(checkbox.dataset.level);
            if (level > maxLevel) maxLevel = level;
          });

          skillPoints += calculateSkillCost(maxLevel);
        });

        // Calculate Prestigio points (1 attribute point each)
        document.querySelectorAll(".prestigio-level:checked").forEach(() => {
          prestigioPoints += 1;
        });

        // Get available points
        const availableAttributePoints =
          parseInt(
            document.getElementById("attribute-available").textContent
          ) || 5;
        const availableSkillPoints =
          parseInt(document.getElementById("skill-available").textContent) ||
          10;

        // Update the display
        document.getElementById("attribute-points").textContent =
          attributePoints;
        document.getElementById("skill-points").textContent = skillPoints;
        document.getElementById("prestigio-points").textContent =
          prestigioPoints;

        // Update used points display
        document.getElementById("attribute-used").textContent =
          attributePoints + prestigioPoints;
        document.getElementById("skill-used").textContent = skillPoints;
        document.getElementById("prestigio-used").textContent = prestigioPoints;

        // Apply warning colors if points are exceeded
        checkAndApplyWarningColors(
          attributePoints + prestigioPoints,
          skillPoints,
          availableAttributePoints,
          availableSkillPoints
        );

        return {
          attributes: attributePoints,
          skills: skillPoints,
          prestigio: prestigioPoints,
        };
      }

      // Function to check and apply warning colors when points are exceeded
      function checkAndApplyWarningColors(
        usedAttributePoints,
        usedSkillPoints,
        availableAttributePoints,
        availableSkillPoints
      ) {
        // Check attribute points
        const attributeExceeded =
          usedAttributePoints > availableAttributePoints;
        const skillExceeded = usedSkillPoints > availableSkillPoints;

        // Update point category colors
        const attributeCategory = document
          .querySelector("#attribute-points")
          .closest(".point-category");
        const skillCategory = document
          .querySelector("#skill-points")
          .closest(".point-category");

        if (attributeExceeded) {
          attributeCategory.classList.add("points-exceeded");
        } else {
          attributeCategory.classList.remove("points-exceeded");
        }

        if (skillExceeded) {
          skillCategory.classList.add("points-exceeded");
        } else {
          skillCategory.classList.remove("points-exceeded");
        }

        // Apply colors to individual attribute inputs
        document.querySelectorAll("input[data-attribute]").forEach((input) => {
          if (attributeExceeded) {
            input.classList.add("attribute-exceeded");
          } else {
            input.classList.remove("attribute-exceeded");
          }
        });

        // Apply colors to individual skill containers
        document.querySelectorAll(".skill-levels").forEach((skillContainer) => {
          const sectionId = skillContainer.dataset.section;

          // Skip recursos section
          if (sectionId === "recursos") return;

          if (skillExceeded) {
            skillContainer.classList.add("skill-exceeded");
          } else {
            skillContainer.classList.remove("skill-exceeded");
          }
        });
      }

      // Magic System Classes and Functions

      // MagicComponentField class to represent different component field types
      class MagicComponentField {
        constructor(id, title, description, options = [], required = false) {
          this.id = id;
          this.title = title;
          this.description = description;
          this.options = options; // Array of {id, name, costModifier}
          this.required = required;
        }

        // Create MagicComponentField from JSON
        static fromJSON(data) {
          return new MagicComponentField(
            data.id,
            data.title,
            data.description,
            data.options || [],
            data.required || false
          );
        }

        // Convert to JSON for storage
        toJSON() {
          return {
            id: this.id,
            title: this.title,
            description: this.description,
            options: this.options,
            required: this.required,
          };
        }
      }

      // Magic class to represent individual spells
      class Magic {
        constructor(
          name,
          componentSelections = {},
          essenceQuantities = {},
          baseCost = null,
          dice = null
        ) {
          this.id = Date.now() + Math.random(); // Simple unique ID
          this.name = name;
          this.componentSelections = componentSelections; // Object with fieldId: optionId
          this.essenceQuantities = essenceQuantities; // Object with essenceId: quantity
          this.baseCost = baseCost || this.calculateBaseCostFromEssences();
          this.dice = dice || this.getFinalDice(); // Final dice string
          this.createdAt = new Date();
        }

        // Calculate base cost from selected essences with hemisphere proximity modifiers
        calculateBaseCostFromEssences() {
          if (
            !this.essenceQuantities ||
            Object.keys(this.essenceQuantities).length === 0
          ) {
            return 1;
          }

          let totalCost = 0;

          // Calculate base cost from essence quantities
          Object.keys(this.essenceQuantities).forEach((essenceId) => {
            const quantity = this.essenceQuantities[essenceId];
            if (quantity > 0) {
              for (let hemisphere of essencesConfig) {
                const essence = hemisphere.essences.find(
                  (e) => e.id === essenceId
                );
                if (essence) {
                  totalCost += essence.cost * quantity;
                  break;
                }
              }
            }
          });

          // Apply hemisphere proximity modifiers
          const selectedEssenceIds = Object.keys(this.essenceQuantities).filter(
            (id) => this.essenceQuantities[id] > 0
          );
          const proximityResult =
            calculateHemisphereProximityModifier(selectedEssenceIds);
          totalCost *= proximityResult.modifier;

          return Math.max(Math.ceil(totalCost), 1); // Minimum cost of 1
        }

        // Calculate final cost based on component selections
        getFinalCost(componentFields) {
          let totalModifier = 1.0;

          // Apply modifiers from each field selection
          Object.keys(this.componentSelections).forEach((fieldId) => {
            const optionId = this.componentSelections[fieldId];
            if (!optionId) return;

            const field = componentFields.find((f) => f.id === fieldId);
            if (!field) return;

            const option = field.options.find((o) => o.id === optionId);
            if (option && option.costModifier) {
              totalModifier *= option.costModifier;
            }
          });

          return Math.ceil(this.baseCost * totalModifier);
        }

        // Calculate final dice from selected essences
        getFinalDice() {
          if (
            !this.essenceQuantities ||
            Object.keys(this.essenceQuantities).length === 0
          ) {
            return "0";
          }

          const diceMap = {};

          // Collect all dice from essence quantities
          Object.keys(this.essenceQuantities).forEach((essenceId) => {
            const quantity = this.essenceQuantities[essenceId];
            if (quantity > 0) {
              for (let hemisphere of essencesConfig) {
                const essence = hemisphere.essences.find(
                  (e) => e.id === essenceId
                );
                if (essence && essence.dice) {
                  // Parse dice (e.g., "1d4" -> {count: 1, sides: 4})
                  const diceMatch = essence.dice.match(/(\d+)d(\d+)/);
                  if (diceMatch) {
                    const count = parseInt(diceMatch[1]) * quantity; // Multiply by quantity
                    const sides = parseInt(diceMatch[2]);
                    const diceType = `d${sides}`;

                    if (diceMap[diceType]) {
                      diceMap[diceType] += count;
                    } else {
                      diceMap[diceType] = count;
                    }
                  }
                  break;
                }
              }
            }
          });

          let multiplier = 1;
          if (
            this.componentSelections &&
            this.componentSelections["dice_multiplier"]
          ) {
            const multValue = parseInt(
              this.componentSelections["dice_multiplier"]
            );
            if (!isNaN(multValue) && multValue > 0) {
              multiplier = multValue;
            }
          }

          Object.keys(diceMap).forEach((diceType) => {
            diceMap[diceType] *= multiplier;
          });

          // Format final dice string
          const diceStrings = Object.keys(diceMap)
            .sort((a, b) => {
              const aSize = parseInt(a.substring(1));
              const bSize = parseInt(b.substring(1));
              return bSize - aSize; // Sort descending by dice size
            })
            .map((diceType) => `${diceMap[diceType]}${diceType}`);

          return diceStrings.length > 0 ? diceStrings.join(" + ") : "0";
        }

        // Get final dice as display string
        getFinalDiceDisplay(finalDice) {
          return finalDice === "0" ? "Nenhum dado" : finalDice;
        }

        // Get selected essences as display string
        getEssencesDisplay() {
          if (
            !this.essenceQuantities ||
            Object.keys(this.essenceQuantities).length === 0
          ) {
            return "Nenhuma ess√™ncia";
          }

          const essenceNames = [];
          Object.keys(this.essenceQuantities).forEach((essenceId) => {
            const quantity = this.essenceQuantities[essenceId];
            if (quantity > 0) {
              for (let hemisphere of essencesConfig) {
                const essence = hemisphere.essences.find(
                  (e) => e.id === essenceId
                );
                if (essence) {
                  const displayName =
                    quantity > 1
                      ? `${essence.name} (x${quantity})`
                      : essence.name;
                  essenceNames.push(displayName);
                  break;
                }
              }
            }
          });

          return essenceNames.length > 0
            ? essenceNames.join(", ")
            : "Nenhuma ess√™ncia";
        }

        // Get hemisphere proximity modifier details
        getHemisphereProximityDetails() {
          if (
            !this.essenceQuantities ||
            Object.keys(this.essenceQuantities).length <= 1
          ) {
            return { modifier: 1.0, description: "" };
          }

          let rawCost = 0;

          // Calculate raw cost from essence quantities
          Object.keys(this.essenceQuantities).forEach((essenceId) => {
            const quantity = this.essenceQuantities[essenceId];
            if (quantity > 0) {
              for (let hemisphere of essencesConfig) {
                const essence = hemisphere.essences.find(
                  (e) => e.id === essenceId
                );
                if (essence) {
                  rawCost += essence.cost * quantity;
                  break;
                }
              }
            }
          });

          const selectedEssenceIds = Object.keys(this.essenceQuantities).filter(
            (id) => this.essenceQuantities[id] > 0
          );
          const proximityResult =
            calculateHemisphereProximityModifier(selectedEssenceIds);

          // Format description from details
          const description = proximityResult.details
            .map(
              (detail) =>
                `${detail.pair}: ${detail.relationship} (√ó${detail.modifier})`
            )
            .join(", ");

          return {
            modifier: proximityResult.modifier,
            description: description,
            rawCost: rawCost,
            finalCost: Math.ceil(rawCost * proximityResult.modifier),
          };
        }

        // Get component selections as display string
        getComponentSelectionsDisplay(componentFields) {
          const selections = [];

          Object.keys(this.componentSelections).forEach((fieldId) => {
            const optionId = this.componentSelections[fieldId];
            if (!optionId) return;

            const field = componentFields.find((f) => f.id === fieldId);
            if (!field) return;

            const option = field.options.find((o) => o.id === optionId);
            if (option) {
              selections.push(`${field.title}: ${option.name}`);
            }
          });

          return selections.length > 0 ? selections.join(" | ") : "Nenhum";
        }

        // Convert to JSON for storage
        toJSON() {
          return {
            id: this.id,
            name: this.name,
            componentSelections: this.componentSelections,
            essenceQuantities: this.essenceQuantities,
            baseCost: this.baseCost,
            dice: this.dice,
            createdAt: this.createdAt.toISOString(),
          };
        }

        // Create Magic from JSON data
        static fromJSON(data) {
          const magic = new Magic(
            data.name,
            data.componentSelections || {},
            data.essenceQuantities || data.selectedEssences || {}, // Support old format
            data.baseCost || 1,
            data.dice || null
          );
          magic.id = data.id;
          magic.createdAt = new Date(data.createdAt);
          return magic;
        }
      }

      // Essences configuration for calculating base cost
      const essencesConfig = [
        {
          id: "energetico",
          name: "Energ√©tico",
          essences: [
            {
              id: "ignis",
              name: "Ignis",
              cost: 1,
              dice: "1d4",
              info: " A ess√™ncia de Ignis √© a primeira ess√™ncia dispon√≠vel no hemisf√©rio de energia, associada diretamente com a ideia de energia t√©rmica, implicando no ganho de calor e at√© mesmo cria√ß√£o de plasma na forma de labaredas e chamas.<h3>Condi√ß√µes:</h3> <span>incendiado (3)</span> <br><h3>Efeitos:</h3> <span>Luz, brilho, aquecimento, igni√ß√£o, fervura, derretimento, descongelamento.</span>",
            },
            {
              id: "fax",
              name: "Fax",
              cost: 2,
              dice: "1d6",
              info: "Fax √© a segunda ess√™ncia pertencente ao hemisf√©rio de energia, ela √© associada a energia de natureza eletromagn√©tica, seja pela excita√ß√£o de el√©trons que geram raios, t√£o bem como forma√ß√£o de campos que podem manipular b√∫ssolas ou outros aparelhos.<h3>Condi√ß√µes:</h3> <span>Incendiado (1), atordoado (1), cego (1)</span> <br><h3>Efeitos:</h3> <span>Explos√£o, energia, raios, luz.</span>",
            },
            { id: "potentia", name: "Potentia", cost: 2, dice: "1d10" },
            { id: "kinetica", name: "Kinetica", cost: 2, dice: "1d6" },
            { id: "anarchia", name: "Anarchia", cost: 3 },
          ],
        },
        {
          id: "material",
          name: "Material",
          essences: [
            { id: "tatio", name: "Tatio", cost: 1 },
            { id: "aqua", name: "Aqua", cost: 2, dice: "1d8" },
            { id: "terra", name: "Terra", cost: 2, dice: "1d4" },
            { id: "aer", name: "Aer", cost: 2, dice: "1d4" },
            { id: "metallum", name: "Metallum", cost: 4, dice: "1d12" },
          ],
        },
        {
          id: "ilusorio",
          name: "Ilus√≥rio",
          essences: [
            { id: "ambiens", name: "Ambiens", cost: 1 },
            { id: "ego", name: "Ego", cost: 2 },
            { id: "suego", name: "Suego", cost: 5 },
            { id: "sensus", name: "Sensus", cost: 1 },
            { id: "realitas", name: "Realitas", cost: 10 },
          ],
        },
        {
          id: "conjurador",
          name: "Conjurador",
          essences: [
            { id: "for", name: "For", cost: 1 },
            { id: "dyn", name: "Dyn", cost: 2 },
            { id: "creatio", name: "Creatio", cost: 2 },
            { id: "clavis", name: "Clavis", cost: 1 },
            { id: "influentia", name: "Influentia", cost: 7 },
          ],
        },
        {
          id: "vida",
          name: "Vida",
          essences: [
            { id: "vita", name: "Vita", cost: 1, dice: "1d4" },
            { id: "roratio", name: "Roratio", cost: 2 },
            { id: "puri", name: "Puri", cost: 2, dice: "1d6" },
            { id: "bene", name: "Bene", cost: 5 },
            { id: "renatio", name: "Renatio", cost: 3 },
          ],
        },
        {
          id: "morte",
          name: "Morte",
          essences: [
            { id: "pest", name: "Pest", cost: 4 },
            { id: "infirmi", name: "Infirmi", cost: 2 },
            { id: "corruptio", name: "Corruptio", cost: 4, dice: "1d8" },
            { id: "maledictio", name: "Maledictio", cost: 2 },
            { id: "necro", name: "Necro", cost: 5, dice: "1d8" },
          ],
        },
      ];

      // Hemisphere proximity configuration for calculating modifiers
      const hemisphereProximity = {
        energetico: {
          close: ["morte", "ilusorio"],
        },
        material: {
          close: ["conjurador", "vida"],
        },
        ilusorio: {
          close: ["morte", "energetico"],
        },
        conjurador: {
          close: ["material", "vida"],
        },
        vida: {
          close: ["material", "conjurador"],
        },
        morte: {
          close: ["ilusorio", "energetico"],
        },
      };

      // Helper function to calculate hemisphere proximity modifier
      function calculateHemisphereProximityModifier(selectedEssences) {
        if (!selectedEssences || selectedEssences.length === 0) {
          return { modifier: 1.0, details: [] };
        }

        const selectedHemispheres = new Set();

        // Collect hemispheres from selected essences
        selectedEssences.forEach((essenceId) => {
          for (let hemisphere of essencesConfig) {
            const essence = hemisphere.essences.find((e) => e.id === essenceId);
            if (essence) {
              selectedHemispheres.add(hemisphere.id);
              break;
            }
          }
        });

        if (selectedHemispheres.size <= 1) {
          return { modifier: 1.0, details: [] };
        }

        const hemisphereArray = Array.from(selectedHemispheres);
        let proximityModifier = 1.0;
        const proximityDetails = [];

        // Check proximity between consecutive hemispheres only
        for (let i = 1; i < hemisphereArray.length; i++) {
          const hemisphere1 = hemisphereArray[i - 1];
          const hemisphere2 = hemisphereArray[i];

          const proximity1 = hemisphereProximity[hemisphere1];
          let pairModifier = 1.2; // Default: far modifier
          let relationship = "distante";

          if (proximity1) {
            if (proximity1.close && proximity1.close.includes(hemisphere2)) {
              pairModifier = 1.1; // Close modifier
              relationship = "pr√≥ximo";
            }
          }

          proximityModifier *= pairModifier;
          proximityDetails.push({
            pair: `${hemisphere1}+${hemisphere2}`,
            relationship,
            modifier: pairModifier,
          });
        }

        return {
          modifier: proximityModifier,
          details: proximityDetails,
        };
      }

      // Magic Component class to handle magic list management and rendering
      class MagicManager {
        constructor() {
          this.magics = [];
          this.componentFields = [];
          this.essencesConfig = essencesConfig;
          this.initializeDefaultComponentFields();
          this.loadMagicsFromStorage();
        }

        // Initialize default component fields from JSON configuration
        initializeDefaultComponentFields() {
          const defaultComponentFieldsConfig = [
            {
              id: "duration",
              title: "Dura√ß√£o",
              description: "Tempo de dura√ß√£o do efeito",
              required: true,
              options: [
                { id: "instant", name: "Instant√¢nea", costModifier: 1.0 },
                { id: "1_minute", name: "1 minuto", costModifier: 2.0 },
                { id: "5_minute", name: "5 minutos", costModifier: 2.2 },
                { id: "10_minute", name: "10 minutos", costModifier: 2.4 },
                { id: "1_hour", name: "1 hora", costModifier: 4.0 },
                { id: "3_hour", name: "3 horas", costModifier: 4.2 },
                { id: "6_hours", name: "At√© 6 horas", costModifier: 4.5 },
                { id: "1_day", name: "At√© 1 dia", costModifier: 6.0 },
                { id: "7_days", name: "At√© 7 dias", costModifier: 7.0 },
                { id: "14_days", name: "At√© 14 dias", costModifier: 9.0 },
                { id: "1_month", name: "At√© 1 m√™s", costModifier: 10.0 },
              ],
            },
            {
              id: "target",
              title: "Alvo",
              description: "Alvos da magia",
              required: true,
              options: [
                { id: "1_target", name: "1 alvo", costModifier: 1.0 },
                { id: "3_targets", name: "At√© 3 alvos", costModifier: 1.3 },
                { id: "6_targets", name: "At√© 6 alvos", costModifier: 1.6 },
                { id: "9_targets", name: "At√© 9 alvos", costModifier: 1.9 },
                { id: "12_targets", name: "At√© 12 alvos", costModifier: 2.2 },
                { id: "15_targets", name: "At√© 15 alvos", costModifier: 2.5 },
                { id: "18_targets", name: "At√© 18 alvos", costModifier: 2.8 },
                { id: "24_targets", name: "At√© 24 alvos", costModifier: 3.1 },
                { id: "30_targets", name: "At√© 30 alvos", costModifier: 4.0 },
              ],
            },
            {
              id: "distance",
              title: "Dist√¢ncia",
              description: "Dist√¢ncia da magia",
              required: true,
              options: [
                { id: "self_touch", name: "Self/Toque", costModifier: 1.0 },
                { id: "5_meters", name: "At√© 5 metros", costModifier: 1.1 },
                { id: "10_meters", name: "At√© 10 metros", costModifier: 1.2 },
                { id: "30_meters", name: "At√© 30 metros", costModifier: 1.5 },
                { id: "50_meters", name: "At√© 50 metros", costModifier: 2.0 },
                { id: "100_meters", name: "At√© 100 metros", costModifier: 2.5 },
                { id: "500_meters", name: "At√© 500 metros", costModifier: 5.0 },
                { id: "10_km", name: "At√© 10 Km", costModifier: 10.0 },
              ],
            },
            {
              id: "area",
              title: "√Årea",
              description: "√Årea de efeito da magia",
              required: true,
              options: [
                { id: "point", name: "Pontual", costModifier: 1.0 },
                {
                  id: "5_m2",
                  name: "5 m¬≤",
                  costModifier: 1.3,
                  description: "Tenda",
                },
                {
                  id: "15_m2",
                  name: "15 m¬≤",
                  costModifier: 1.4,
                  description: "Banheiro",
                },
                {
                  id: "30_m2",
                  name: "30 m¬≤",
                  costModifier: 1.5,
                  description: "Quarto",
                },
                {
                  id: "50_m2",
                  name: "50 m¬≤",
                  costModifier: 1.6,
                  description: "Sal√£o",
                },
                {
                  id: "100_m2",
                  name: "100 m¬≤",
                  costModifier: 1.7,
                  description: "Casebre",
                },
                {
                  id: "250_m2",
                  name: "250 m¬≤",
                  costModifier: 1.8,
                  description: "Casa",
                },
                {
                  id: "500_m2",
                  name: "500 m¬≤",
                  costModifier: 1.9,
                  description: "Casar√£o",
                },
                {
                  id: "1000_m2",
                  name: "1000 m¬≤",
                  costModifier: 2.0,
                  description: "Mans√£o",
                },
                {
                  id: "5000_m2",
                  name: "5000 m¬≤",
                  costModifier: 2.2,
                  description: "Catedral",
                },
                {
                  id: "10000_m2",
                  name: "10000 m¬≤",
                  costModifier: 2.4,
                  description: "Castelo",
                },
                {
                  id: "25000_m2",
                  name: "25000 m¬≤",
                  costModifier: 2.6,
                  description: "Pal√°cio",
                },
                {
                  id: "50000_m2",
                  name: "50000 m¬≤",
                  costModifier: 2.8,
                  description: "Distrito",
                },
                {
                  id: "75000_m2",
                  name: "75000 m¬≤",
                  costModifier: 3.0,
                  description: "Vilarejo",
                },
                {
                  id: "100000_m2",
                  name: "100000 m¬≤",
                  costModifier: 4.0,
                  description: "Cidade",
                },
              ],
            },
            {
              id: "areaType",
              title: "Tipo de √Årea",
              description: "Tipo de √°rea da magia",
              required: true,
              options: [
                { id: "grupal", name: "Grupal", costModifier: 1.0 },
                { id: "seletivo", name: "Seletivo", costModifier: 4.0 },
              ],
            },
            {
              id: "concentracao",
              title: "Concentra√ß√£o",
              description: "N√≠vel de concentra√ß√£o necess√°rio para a magia",
              required: true,
              options: [
                { id: "moderado", name: "Moderado", costModifier: 1.0 },
                { id: "baixa", name: "Instant√¢neo", costModifier: 1.4 },
                { id: "pesado", name: "Pesado", costModifier: 0.8 },
              ],
            },
            {
              id: "dice_multiplier",
              title: "Multiplicador de Dados",
              description: "Multiplicador de dados para a magia",
              required: true,
              options: [
                { id: "1", name: "1", costModifier: 1.0 },
                { id: "2", name: "2", costModifier: 3 },
                { id: "3", name: "3", costModifier: 6 },
                { id: "4", name: "4", costModifier: 9 },
                { id: "5", name: "5", costModifier: 12 },
              ],
            },
          ];

          this.componentFields = defaultComponentFieldsConfig.map((config) =>
            MagicComponentField.fromJSON(config)
          );
        }

        // Add a new magic to the list
        addMagic(name, componentSelections, baseCost = 1) {
          if (!name || !name.trim()) {
            alert("Por favor, digite um nome para a magia.");
            return false;
          }

          // Check if any required fields are missing
          const missingRequired = this.componentFields
            .filter((field) => field.required && !componentSelections[field.id])
            .map((field) => field.title);

          if (missingRequired.length > 0) {
            alert(`Por favor, selecione: ${missingRequired.join(", ")}`);
            return false;
          }

          // Check if magic with same name already exists
          const existingMagic = this.magics.find(
            (magic) => magic.name.toLowerCase() === name.trim().toLowerCase()
          );

          if (existingMagic) {
            alert(`A magia "${name.trim()}" j√° existe na lista.`);
            return false;
          }

          const magic = new Magic(name.trim(), componentSelections, baseCost);
          this.magics.push(magic);
          this.saveMagicsToStorage();
          this.renderMagicList();
          return true;
        }

        // Add a new magic with essences to the list
        addMagicWithEssences(
          name,
          componentSelections,
          essenceQuantities,
          baseCost = 1,
          dice = null
        ) {
          if (!name || !name.trim()) {
            alert("Por favor, digite um nome para a magia.");
            return false;
          }

          // Check if any required fields are missing
          const missingRequired = this.componentFields
            .filter((field) => field.required && !componentSelections[field.id])
            .map((field) => field.title);

          if (missingRequired.length > 0) {
            alert(`Por favor, selecione: ${missingRequired.join(", ")}`);
            return false;
          }

          // Check if magic with same name already exists
          const existingMagic = this.magics.find(
            (magic) => magic.name.toLowerCase() === name.trim().toLowerCase()
          );

          if (existingMagic) {
            alert(`A magia "${name.trim()}" j√° existe na lista.`);
            return false;
          }

          const magic = new Magic(
            name.trim(),
            componentSelections,
            essenceQuantities,
            baseCost,
            dice
          );
          this.magics.push(magic);
          this.saveMagicsToStorage();
          this.renderMagicList();
          return true;
        }

        // Remove a magic from the list
        removeMagic(magicId) {
          const index = this.magics.findIndex((magic) => magic.id === magicId);
          if (index !== -1) {
            const magic = this.magics[index];
            if (
              confirm(`Tem certeza que deseja remover a magia "${magic.name}"?`)
            ) {
              this.magics.splice(index, 1);
              this.saveMagicsToStorage();
              this.renderMagicList();
              return true;
            }
          }
          return false;
        }

        // Render component field selects
        renderComponentOptions() {
          const container = document.getElementById(
            "magic-components-container"
          );
          if (!container) return;

          // Clear existing content
          container.innerHTML = "";

          // Add component field selects
          this.componentFields.forEach((field) => {
            const fieldDiv = document.createElement("div");
            fieldDiv.className = "mb-3";

            const selectId = `magic-field-${field.id}`;
            const requiredLabel = field.required ? " *" : "";

            fieldDiv.innerHTML = `
              <label for="${selectId}" class="form-label">
                <strong>${field.title}${requiredLabel}</strong>
              </label>
              <select class="form-control magic-component-select" 
                      id="${selectId}" 
                      data-field-id="${field.id}"
                      title="${field.description}"
                      onchange="updateFinalCostDisplay()">
                ${
                  field.required
                    ? ""
                    : '<option value="">-- Selecione ' +
                      field.title +
                      " --</option>"
                }
                ${field.options
                  .map(
                    (option, index) =>
                      `<option value="${option.id}" title="Custo: √ó${
                        option.costModifier
                      }" ${field.required && index === 0 ? "selected" : ""}>
                    ${option.name} (√ó${option.costModifier})
                   </option>`
                  )
                  .join("")}
              </select>
              ${
                field.description
                  ? `<small class="form-text text-muted">${field.description}</small>`
                  : ""
              }
            `;

            container.appendChild(fieldDiv);
          });
        }

        // Render essences selection interface
        renderEssencesSelection() {
          const container = document.getElementById("magic-essences-container");
          if (!container) return;

          container.innerHTML = "";

          // Create header
          const headerDiv = document.createElement("div");
          headerDiv.className = "mb-3";
          headerDiv.innerHTML = `
            <h6 class="mb-2">üîÆ Sele√ß√£o de Ess√™ncias</h6>
            <small class="text-muted">Selecione as ess√™ncias para calcular o custo base da magia.</small>
            <div class="mt-2">
              <span id="calculated-base-cost" class="badge bg-info">Custo Base: 1</span>
              <span id="calculated-final-cost" class="badge bg-success ms-2">Custo Final: 1</span>
              <span id="calculated-final-dice" class="badge bg-warning ms-2">Dados: Nenhum dado</span>
            </div>
          `;
          container.appendChild(headerDiv);

          // Create essences by hemisphere
          this.essencesConfig.forEach((hemisphere) => {
            const hemisphereDiv = document.createElement("div");
            hemisphereDiv.className = "mb-3 p-2 border rounded";
            hemisphereDiv.innerHTML = `
              <h6 class="mb-2 text-primary">${hemisphere.name}</h6>
              <div class="essence-checkboxes" data-hemisphere="${
                hemisphere.id
              }">
                ${hemisphere.essences
                  .map(
                    (essence) => `
                  <div class="form-check form-check-inline essence-quantity-container d-flex align-items-center">
                    <div class="d-flex align-items-center">
                      <label class="form-check-label essence-label me-2" for="essence-${
                        essence.id
                      }">
                        ${essence.name} (${essence.cost})${
                      essence.info
                        ? `<button class="essence-info-btn" 
                                               onclick="showInfo('${essence.id}', '${essence.name}', \`${essence.info}\`)" 
                                               title="Ver informa√ß√µes sobre ${essence.name}">‚Ñπ</button>`
                        : ""
                    }
                      </label>
                      <input class="form-check-input essence-checkbox me-2" 
                             type="checkbox" 
                             id="essence-checkbox-${essence.id}" 
                             data-essence-id="${essence.id}"
                             onchange="toggleEssenceQuantity('${essence.id}')"
                             title="Habilitar sele√ß√£o de ${essence.name}">
                      <input class="form-control essence-quantity" 
                             type="number" 
                             id="essence-${essence.id}" 
                             value="0"
                             min="0"
                             max="10"
                             data-essence-id="${essence.id}"
                             onchange="updateBaseCostFromEssences(); updateFinalDiceDisplay()"
                             title="Quantidade de ${essence.name} (custo: ${
                      essence.cost
                    } cada)"
                             disabled>
                    </div>
                  </div>
                `
                  )
                  .join("")}
              </div>
            `;
            container.appendChild(hemisphereDiv);
          });
        }

        // Render the complete magic list
        renderMagicList() {
          const container = document.getElementById("magic-list-container");
          const countElement = document.getElementById("magic-count");
          const noMagicMessage = document.getElementById("no-magic-message");

          if (!container) return;

          // Update count
          if (countElement) {
            countElement.textContent = this.magics.length;
          }

          // Clear container
          container.innerHTML = "";

          if (this.magics.length === 0) {
            if (noMagicMessage) {
              container.appendChild(noMagicMessage);
            } else {
              container.innerHTML =
                '<p class="text-muted text-center">Nenhuma magia adicionada ainda.</p>';
            }
            return;
          }

          // Hide no magic message
          if (noMagicMessage) {
            noMagicMessage.style.display = "none";
          }

          // Render each magic
          this.magics.forEach((magic) => {
            const magicElement = this.renderMagicItem(magic);
            container.appendChild(magicElement);
          });

          // Update total cost display
          this.updateTotalCostDisplay();
        }

        // Render individual magic item
        renderMagicItem(magic) {
          const magicDiv = document.createElement("div");
          magicDiv.className = "magic-item";
          magicDiv.dataset.magicId = magic.id;

          const finalCost = magic.getFinalCost(this.componentFields);
          const componentDisplay = magic.getComponentSelectionsDisplay(
            this.componentFields
          );
          const essencesDisplay = magic.getEssencesDisplay();
          const proximityDetails = magic.getHemisphereProximityDetails();
          const finalDice = magic.getFinalDice();
          const diceDisplay =
            magic.dice || magic.getFinalDiceDisplay(finalDice);
          const hasDice =
            diceDisplay && diceDisplay !== "Nenhum dado" && diceDisplay !== "0";

          let proximityInfo = "";
          if (proximityDetails.modifier > 1.0) {
            proximityInfo = `
              <div class="magic-proximity">
                <small class="text-info">Modificador Hemisf√©rios: √ó${proximityDetails.modifier.toFixed(
                  2
                )}</small>
              </div>
            `;
          }

          // Create roll button if dice are available
          let rollButton = "";
          if (hasDice) {
            rollButton = `
              <button class="magic-roll-btn btn btn-sm btn-outline-primary" 
                      onclick="rollMagicDice(${magic.id})" 
                      title="Rolar dados da magia">
                üé≤ Rolar
              </button>
            `;
          }

          magicDiv.innerHTML = `
            <button class="magic-remove-btn" onclick="magicManager.removeMagic(${
              magic.id
            })" title="Remover magia">
              ‚úï
            </button>
            <div class="magic-name">${this.escapeHtml(magic.name)}</div>
            <div class="magic-details">
              <div class="magic-essences">
                <small class="text-muted">Ess√™ncias:</small> ${this.escapeHtml(
                  essencesDisplay
                )}
              </div>
              ${proximityInfo}
              <div class="magic-components">
                <small class="text-muted">Componentes:</small> ${this.escapeHtml(
                  componentDisplay
                )}
              </div>
              <div class="magic-cost-breakdown">
                <span class="magic-base-cost">Base: ${magic.baseCost}</span>
                <span class="magic-final-cost">Final: ${finalCost}</span>
                <span class="magic-dice">Dados: ${this.escapeHtml(
                  diceDisplay
                )}</span>
                ${rollButton}
              </div>
            </div>
          `;

          return magicDiv;
        }

        // Update total cost display
        updateTotalCostDisplay() {
          const totalCost = this.magics.reduce(
            (sum, magic) => sum + magic.getFinalCost(this.componentFields),
            0
          );

          const totalCostElement = document.getElementById("magic-total-cost");
          if (totalCostElement) {
            totalCostElement.textContent = totalCost;
          }
        }

        // Utility function to escape HTML
        escapeHtml(text) {
          const div = document.createElement("div");
          div.textContent = text;
          return div.innerHTML;
        }

        // Save magics to localStorage
        saveMagicsToStorage() {
          try {
            const data = this.magics.map((magic) => magic.toJSON());
            localStorage.setItem(
              "fac_09_character_magics",
              JSON.stringify(data)
            );
            console.log("Magics saved to localStorage");
          } catch (error) {
            console.error("Error saving magics to localStorage:", error);
          }
        }

        // Load magics from localStorage
        loadMagicsFromStorage() {
          try {
            const data = localStorage.getItem("fac_09_character_magics");
            if (data) {
              const magicsData = JSON.parse(data);
              this.magics = magicsData.map((magicData) =>
                Magic.fromJSON(magicData)
              );
              console.log("Magics loaded from localStorage");
            }
          } catch (error) {
            console.error("Error loading magics from localStorage:", error);
            this.magics = [];
          }
        }

        // Clear all magics
        clearAllMagics() {
          if (this.magics.length === 0) {
            alert("N√£o h√° magias para remover.");
            return;
          }

          if (
            confirm(
              "Tem certeza que deseja remover todas as magias? Esta a√ß√£o n√£o pode ser desfeita."
            )
          ) {
            this.magics = [];
            this.saveMagicsToStorage();
            this.renderMagicList();
          }
        }

        // Get magics data for character save
        getMagicsData() {
          return this.magics.map((magic) => magic.toJSON());
        }

        // Load magics data from character load
        loadMagicsData(magicsData) {
          if (Array.isArray(magicsData)) {
            this.magics = magicsData.map((magicData) =>
              Magic.fromJSON(magicData)
            );
            this.renderMagicList();
          }
        }
      }

      // Global magic manager instance
      let magicManager;

      // Function to toggle essence quantity input based on checkbox state
      function toggleEssenceQuantity(essenceId) {
        const checkbox = document.getElementById(
          `essence-checkbox-${essenceId}`
        );
        const quantityInput = document.getElementById(`essence-${essenceId}`);

        if (!checkbox || !quantityInput) return;

        if (checkbox.checked) {
          // Enable the quantity input and set minimum value to 1
          quantityInput.disabled = false;
          quantityInput.value = Math.max(parseInt(quantityInput.value) || 1, 1);
        } else {
          // Disable the quantity input and reset value to 0
          quantityInput.disabled = true;
          quantityInput.value = 0;
        }

        // Update calculations after toggling
        updateBaseCostFromEssences();
        updateFinalDiceDisplay();

        // Auto-save when essence selection changes
        clearTimeout(window.saveTimeout);
        window.saveTimeout = setTimeout(() => {
          saveCharacterDataToStorage();
        }, 500);
      }

      // Function to get current essence selection state
      function getCurrentEssenceSelectionState() {
        const essenceSelection = {
          checkboxStates: {},
          quantityValues: {},
        };

        const essenceQuantityInputs =
          document.querySelectorAll(".essence-quantity");
        essenceQuantityInputs.forEach((input) => {
          const essenceId = input.dataset.essenceId;
          const checkbox = document.getElementById(
            `essence-checkbox-${essenceId}`
          );

          if (checkbox) {
            essenceSelection.checkboxStates[essenceId] = checkbox.checked;
            essenceSelection.quantityValues[essenceId] =
              parseInt(input.value) || 0;
          }
        });

        return essenceSelection;
      }

      // Function to load essence selection state
      function loadEssenceSelectionState(essenceSelection) {
        if (!essenceSelection) {
          // If no saved data, leave all checkboxes unchecked and inputs disabled (default state)
          updateBaseCostFromEssences();
          updateFinalDiceDisplay();
          return;
        }

        // Load checkbox states and quantity values from saved data
        Object.keys(essenceSelection.checkboxStates || {}).forEach(
          (essenceId) => {
            const checkbox = document.getElementById(
              `essence-checkbox-${essenceId}`
            );
            const quantityInput = document.getElementById(
              `essence-${essenceId}`
            );

            if (checkbox && quantityInput) {
              const isChecked = essenceSelection.checkboxStates[essenceId];
              const quantity = essenceSelection.quantityValues[essenceId] || 0;

              checkbox.checked = isChecked;
              quantityInput.value = quantity;
              quantityInput.disabled = !isChecked;
            }
          }
        );

        // Update calculations after loading
        updateBaseCostFromEssences();
        updateFinalDiceDisplay();
      }

      // Function to clear essence selection state
      function clearEssenceSelectionState() {
        const essenceQuantityInputs =
          document.querySelectorAll(".essence-quantity");
        essenceQuantityInputs.forEach((input) => {
          const essenceId = input.dataset.essenceId;
          const checkbox = document.getElementById(
            `essence-checkbox-${essenceId}`
          );

          if (checkbox) {
            checkbox.checked = false;
            input.value = 0;
            input.disabled = true;
          }
        });

        // Update calculations after clearing
        updateBaseCostFromEssences();
        updateFinalDiceDisplay();
      }

      // Function to update base cost based on selected essences with hemisphere proximity modifiers
      // Function to update base cost based on selected essence quantities
      function updateBaseCostFromEssences() {
        const essenceQuantityInputs =
          document.querySelectorAll(".essence-quantity");
        let totalCost = 0;
        const essenceQuantities = {};

        // Calculate base cost from essence quantities
        essenceQuantityInputs.forEach((input) => {
          const essenceId = input.dataset.essenceId;
          const checkbox = document.getElementById(
            `essence-checkbox-${essenceId}`
          );
          const quantity = parseInt(input.value) || 0;

          // Only consider essences where checkbox is checked and quantity > 0
          if (checkbox && checkbox.checked && quantity > 0) {
            essenceQuantities[essenceId] = quantity;

            for (let hemisphere of essencesConfig) {
              const essence = hemisphere.essences.find(
                (e) => e.id === essenceId
              );
              if (essence) {
                totalCost += essence.cost * quantity;
                break;
              }
            }
          }
        });

        // Apply hemisphere proximity modifiers
        const selectedEssenceIds = Object.keys(essenceQuantities);
        const proximityResult =
          calculateHemisphereProximityModifier(selectedEssenceIds);
        totalCost *= proximityResult.modifier;

        // Update the display and input
        const baseCost = totalCost;
        const costInput = document.getElementById("magic-cost-input");
        const costDisplay = document.getElementById("calculated-base-cost");

        if (costInput) {
          costInput.value = Number(baseCost).toFixed(2);
        }

        if (costDisplay) {
          // Show proximity modifier info if applicable
          let displayText = `Custo Base: ${Number(baseCost).toFixed(2)}`;
          if (proximityResult.details.length > 0) {
            displayText += ` (√ó${proximityResult.modifier.toFixed(
              2
            )} por hemisf√©rios diferentes)`;
          }
          costDisplay.textContent = displayText;
        }

        // Also update final cost when base cost changes
        updateFinalCostDisplay();
      }

      // Function to calculate and update final cost display
      function updateFinalCostDisplay() {
        // Get base cost
        const costInput = document.getElementById("magic-cost-input");
        const baseCost = costInput ? parseInt(costInput.value) || 1 : 1;

        // Get component selections
        const componentSelects = document.querySelectorAll(
          ".magic-component-select"
        );

        let totalModifier = 1.0;

        // Apply modifiers from each field selection
        componentSelects.forEach((select) => {
          const fieldId = select.dataset.fieldId;
          const optionId = select.value;

          if (!optionId) return;

          const field = magicManager.componentFields.find(
            (f) => f.id === fieldId
          );
          if (!field) return;

          const option = field.options.find((o) => o.id === optionId);
          if (option && option.costModifier) {
            totalModifier *= option.costModifier;
          }
        });

        const finalCost = Math.ceil(baseCost * totalModifier);
        const finalCostDisplay = document.getElementById(
          "calculated-final-cost"
        );
        const finalCostInput = document.getElementById(
          "magic-final-cost-input"
        );

        if (finalCostDisplay) {
          finalCostDisplay.textContent = `Custo Final: ${finalCost}`;
        }

        if (finalCostInput) {
          finalCostInput.textContent = `Custo Final: ${finalCost}`;
        }

        // Update dice display
        updateFinalDiceDisplay();
      }

      // Update dice display based on selected essences
      // Update dice display based on selected essence quantities
      function updateFinalDiceDisplay() {
        const essenceQuantityInputs =
          document.querySelectorAll(".essence-quantity");
        const essenceQuantities = {};

        // Collect essence quantities (only from checked essences)
        essenceQuantityInputs.forEach((input) => {
          const essenceId = input.dataset.essenceId;
          const checkbox = document.getElementById(
            `essence-checkbox-${essenceId}`
          );
          const quantity = parseInt(input.value) || 0;

          // Only include essences where checkbox is checked and quantity > 0
          if (checkbox && checkbox.checked && quantity > 0) {
            essenceQuantities[essenceId] = quantity;
          }
        });

        // Create temporary magic to calculate dice
        const componentSelects = document.querySelectorAll(
          ".magic-component-select"
        );
        const componentSelections = {};
        componentSelects.forEach((select) => {
          const fieldId = select.dataset.fieldId;
          const value = select.value;
          if (value) {
            componentSelections[fieldId] = value;
          }
        });

        const tempMagic = new Magic(
          "temp",
          componentSelections,
          essenceQuantities
        );

        const finalDice = tempMagic.getFinalDice();
        const finalDiceDisplay = tempMagic.getFinalDiceDisplay(finalDice);

        const finalDiceDisplayElement = document.getElementById(
          "calculated-final-dice"
        );
        const diceInput = document.getElementById("magic-dice-input");

        if (finalDiceDisplayElement) {
          finalDiceDisplayElement.textContent = `Dados: ${finalDiceDisplay}`;
        }

        if (diceInput) {
          diceInput.value = finalDice === "0" ? "" : finalDice;
          diceInput.placeholder = finalDice === "0" ? "Nenhum dado" : finalDice;
        }
      }

      // Functions for UI interaction
      function addMagicSpell() {
        const nameInput = document.getElementById("magic-name-input");
        const costInput = document.getElementById("magic-cost-input");
        const diceInput = document.getElementById("magic-dice-input");
        const componentSelects = document.querySelectorAll(
          ".magic-component-select"
        );
        const essenceQuantityInputs =
          document.querySelectorAll(".essence-quantity");

        if (!nameInput || !costInput || !diceInput) {
          alert("Erro: Elementos de entrada n√£o encontrados.");
          return;
        }

        const name = nameInput.value;
        const baseCost = parseInt(costInput.value) || 1;
        const dice = diceInput.value.trim() || null;

        // Collect essence quantities (only from checked essences)
        const essenceQuantities = {};
        essenceQuantityInputs.forEach((input) => {
          const essenceId = input.dataset.essenceId;
          const checkbox = document.getElementById(
            `essence-checkbox-${essenceId}`
          );
          const quantity = parseInt(input.value) || 0;

          // Only include essences where checkbox is checked and quantity > 0
          if (checkbox && checkbox.checked && quantity > 0) {
            essenceQuantities[essenceId] = quantity;
          }
        });

        // Collect component selections
        const componentSelections = {};
        componentSelects.forEach((select) => {
          const fieldId = select.dataset.fieldId;
          const value = select.value;
          if (value) {
            componentSelections[fieldId] = value;
          }
        });

        if (
          magicManager.addMagicWithEssences(
            name,
            componentSelections,
            essenceQuantities,
            baseCost,
            dice
          )
        ) {
          // Clear inputs on success
          nameInput.value = "";
          costInput.value = "1";
          diceInput.value = "";
          diceInput.placeholder = "Nenhum dado";

          // Reset all component selects to default values
          componentSelects.forEach((select) => {
            const fieldId = select.dataset.fieldId;
            const field = magicManager.componentFields.find(
              (f) => f.id === fieldId
            );

            if (field && field.required && field.options.length > 0) {
              // Set required fields to their first option
              select.value = field.options[0].id;
            } else {
              // Set optional fields to empty
              select.value = "";
            }
          });

          // Reset essence quantity inputs to 0 but keep checkboxes checked
          essenceQuantityInputs.forEach((input) => {
            const essenceId = input.dataset.essenceId;
            const checkbox = document.getElementById(
              `essence-checkbox-${essenceId}`
            );

            // Only reset quantity to 0, keep checkboxes and enabled state as they are
            input.value = "0";

            // If checkbox is unchecked, keep input disabled; if checked, keep it enabled
            if (checkbox && !checkbox.checked) {
              input.disabled = true;
            }
          });

          // Update base cost display
          updateBaseCostFromEssences();

          // Trigger auto-save
          clearTimeout(window.saveTimeout);
          window.saveTimeout = setTimeout(() => {
            saveCharacterDataToStorage();
          }, 500);
        }
      }

      // Handle keyboard input for magic creation
      function handleMagicInputKeypress(event) {
        if (event.key === "Enter") {
          event.preventDefault();
          addMagicSpell();
        }
      }

      // Function to roll magic dice
      function rollMagicDice(magicId) {
        if (!magicManager) return;

        const magic = magicManager.magics.find((m) => m.id === magicId);
        if (!magic) return;

        const diceString = magic.dice || magic.getFinalDice();
        if (!diceString || diceString === "0") {
          alert("Esta magia n√£o possui dados para rolar.");
          return;
        }

        // Parse and roll the dice
        const rollResult = parseDiceStringAndRoll(diceString);

        if (rollResult.error) {
          alert(`Erro ao rolar dados: ${rollResult.error}`);
          return;
        }

        // Show roll result
        const resultMessage = `üé≤ ${
          magic.name
        }\n\nDados: ${diceString}\nResultado: ${
          rollResult.total
        }\n\nDetalhes: ${rollResult.details.join(", ")}`;
        alert(resultMessage);
      }

      // Function to parse dice string and roll dice
      function parseDiceStringAndRoll(diceString) {
        try {
          // Split by + to handle multiple dice types (e.g., "2d4 + 1d6")
          const diceParts = diceString.split("+").map((part) => part.trim());
          let total = 0;
          const details = [];

          for (const part of diceParts) {
            // Parse each dice part (e.g., "2d4")
            const diceMatch = part.match(/(\d+)d(\d+)/);
            if (!diceMatch) {
              return { error: `Formato de dado inv√°lido: ${part}` };
            }

            const count = parseInt(diceMatch[1]);
            const sides = parseInt(diceMatch[2]);

            if (count <= 0 || sides <= 0) {
              return { error: `Valores inv√°lidos: ${count}d${sides}` };
            }

            // Roll the dice
            const rolls = [];
            let partTotal = 0;
            for (let i = 0; i < count; i++) {
              const roll = Math.floor(Math.random() * sides) + 1;
              rolls.push(roll);
              partTotal += roll;
            }

            total += partTotal;
            details.push(
              `${count}d${sides}: [${rolls.join(", ")}] = ${partTotal}`
            );
          }

          return {
            total: total,
            details: details,
            error: null,
          };
        } catch (error) {
          return { error: `Erro ao processar dados: ${error.message}` };
        }
      }

      // Function to clear all magics (can be called from UI)
      function clearAllMagics() {
        if (magicManager) {
          magicManager.clearAllMagics();

          // Trigger auto-save
          clearTimeout(window.saveTimeout);
          window.saveTimeout = setTimeout(() => {
            saveCharacterDataToStorage();
          }, 500);
        }
      }
      function toggleAllSectionsPreview() {
        const previewDiv = document.getElementById("all-sections-preview");
        if (previewDiv) {
          if (previewDiv.style.display === "none") {
            previewDiv.style.display = "block";
          } else {
            previewDiv.style.display = "none";
          }
        }
      }

      // Generic info popup functions that can be reused for any type of content
      function showInfo(type, title, content, customClasses = "") {
        const overlayId = `${type}-info-overlay`;
        const popupId = `${type}-info-popup`;

        // Create overlay if it doesn't exist
        let overlay = document.getElementById(overlayId);
        if (!overlay) {
          overlay = document.createElement("div");
          overlay.id = overlayId;
          overlay.className = `essence-info-popup-overlay ${customClasses}`;
          overlay.onclick = () => hideInfo(type);
          document.body.appendChild(overlay);
        }

        // Create popup if it doesn't exist
        let popup = document.getElementById(popupId);
        if (!popup) {
          popup = document.createElement("div");
          popup.id = popupId;
          popup.className = `essence-info-popup ${customClasses}`;
          document.body.appendChild(popup);
        }

        // Set popup content
        popup.innerHTML = `
          <div class="essence-info-popup-header">
            <h3 class="essence-info-popup-title">${title}</h3>
            <button class="essence-info-popup-close" onclick="hideInfo('${type}')" title="Fechar">√ó</button>
          </div>
          <div class="essence-info-popup-content">
            ${content}
          </div>
        `;

        // Show overlay and popup
        overlay.classList.add("show");
        popup.classList.add("show");

        // Store current popup type for escape key handling
        document.body.dataset.currentPopupType = type;

        // Prevent body scroll
        document.body.style.overflow = "hidden";
      }

      function hideInfo(type) {
        const overlayId = `${type}-info-overlay`;
        const popupId = `${type}-info-popup`;

        const overlay = document.getElementById(overlayId);
        const popup = document.getElementById(popupId);

        if (overlay) {
          overlay.classList.remove("show");
        }
        if (popup) {
          popup.classList.remove("show");
        }

        // Clear current popup type
        delete document.body.dataset.currentPopupType;

        // Restore body scroll
        document.body.style.overflow = "";
      }

      // Hide any currently visible popup
      function hideCurrentPopup() {
        const currentType = document.body.dataset.currentPopupType;
        if (currentType) {
          hideInfo(currentType);
        }
      }

      // Close popup with Escape key - now works with any popup type
      document.addEventListener("keydown", function (event) {
        if (event.key === "Escape") {
          hideCurrentPopup();
        }
      });
    </script>
  </body>
</html>
